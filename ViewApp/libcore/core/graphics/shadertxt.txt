 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform mat4x4 ViewProj;

in vec4 _input_attrib0;
in vec2 _input_attrib1;

out vec2 _vertex_shader_attrib0;

out gl_PerVertex {
    vec4 gl_Position;
};

struct VertInOut {
    vec4 pos;
    vec2 uv;
};

VertInOut VSDefault(VertInOut vert_in)
{
    VertInOut vert_out;
    vert_out.pos = ((vec4(vert_in.pos.xyz, 1.0)) * (ViewProj));
    vert_out.uv  = vert_in.uv;
    return vert_out;
}

VertInOut _main_wrap(VertInOut vert_in)
{
    return VSDefault(vert_in);
}

void main(void)
{
    VertInOut vert_in;
    VertInOut outputval;

    vert_in.pos = _input_attrib0;
    vert_in.uv = _input_attrib1;

    outputval = _main_wrap(vert_in);

    gl_Position = outputval.pos;
    _vertex_shader_attrib0 = outputval.uv;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform sampler2D image;

in vec2 _vertex_shader_attrib0;

out vec4 _pixel_shader_attrib0;

struct VertInOut {
    vec4 pos;
    vec2 uv;
};

vec4 PSDrawBare(VertInOut vert_in)
{
    return texture(image, vert_in.uv);
}

vec4 _main_wrap(VertInOut vert_in)
{
    return PSDrawBare(vert_in);
}

void main(void)
{
    VertInOut vert_in;
    vert_in.pos = gl_FragCoord;
    vert_in.uv = _vertex_shader_attrib0;

    _pixel_shader_attrib0 = _main_wrap(vert_in);
}

info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform mat4x4 ViewProj;

in vec4 _input_attrib0;
in vec2 _input_attrib1;

out vec2 _vertex_shader_attrib0;

out gl_PerVertex {
    vec4 gl_Position;
};

struct VertInOut {
    vec4 pos;
    vec2 uv;
};

VertInOut VSDefault(VertInOut vert_in)
{
    VertInOut vert_out;
    vert_out.pos = ((vec4(vert_in.pos.xyz, 1.0)) * (ViewProj));
    vert_out.uv  = vert_in.uv;
    return vert_out;
}

VertInOut _main_wrap(VertInOut vert_in)
{
    return VSDefault(vert_in);
}

void main(void)
{
    VertInOut vert_in;
    VertInOut outputval;

    vert_in.pos = _input_attrib0;
    vert_in.uv = _input_attrib1;

    outputval = _main_wrap(vert_in);

    gl_Position = outputval.pos;
    _vertex_shader_attrib0 = outputval.uv;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform sampler2D image;

in vec2 _vertex_shader_attrib0;

out vec4 _pixel_shader_attrib0;

struct VertInOut {
    vec4 pos;
    vec2 uv;
};

vec4 PSDrawAlphaDivide(VertInOut vert_in)
{
    vec4 rgba = texture(image, vert_in.uv);
    rgba.rgb *= max(1. / rgba.a, 0.);
    return rgba;
}

vec4 _main_wrap(VertInOut vert_in)
{
    return PSDrawAlphaDivide(vert_in);
}

void main(void)
{
    VertInOut vert_in;
    vert_in.pos = gl_FragCoord;
    vert_in.uv = _vertex_shader_attrib0;

    _pixel_shader_attrib0 = _main_wrap(vert_in);
}

info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform mat4x4 ViewProj;

in vec4 _input_attrib0;
in vec2 _input_attrib1;

out vec2 _vertex_shader_attrib0;

out gl_PerVertex {
    vec4 gl_Position;
};

struct VertInOut {
    vec4 pos;
    vec2 uv;
};

VertInOut VSDefault(VertInOut vert_in)
{
    VertInOut vert_out;
    vert_out.pos = ((vec4(vert_in.pos.xyz, 1.0)) * (ViewProj));
    vert_out.uv  = vert_in.uv;
    return vert_out;
}

VertInOut _main_wrap(VertInOut vert_in)
{
    return VSDefault(vert_in);
}

void main(void)
{
    VertInOut vert_in;
    VertInOut outputval;

    vert_in.pos = _input_attrib0;
    vert_in.uv = _input_attrib1;

    outputval = _main_wrap(vert_in);

    gl_Position = outputval.pos;
    _vertex_shader_attrib0 = outputval.uv;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform sampler2D image;

in vec2 _vertex_shader_attrib0;

out vec4 _pixel_shader_attrib0;

struct VertInOut {
    vec4 pos;
    vec2 uv;
};

float srgb_linear_to_nonlinear_channel(float u)
{
    return (u <= 0.0031308) ? (12.92 * u) : ((1.055 * pow(u, 1. / 2.4)) - 0.055);
}

vec3 srgb_linear_to_nonlinear(vec3 v)
{
    return vec3(srgb_linear_to_nonlinear_channel(v.r), srgb_linear_to_nonlinear_channel(v.g), srgb_linear_to_nonlinear_channel(v.b));
}

float srgb_nonlinear_to_linear_channel(float u)
{
    return (u <= 0.04045) ? (u / 12.92) : pow((u + 0.055) / 1.055, 2.4);
}

vec3 srgb_nonlinear_to_linear(vec3 v)
{
    return vec3(srgb_nonlinear_to_linear_channel(v.r), srgb_nonlinear_to_linear_channel(v.g), srgb_nonlinear_to_linear_channel(v.b));
}

vec4 PSDrawNonlinearAlpha(VertInOut vert_in)
{
    vec4 rgba = texture(image, vert_in.uv);
    rgba.rgb = srgb_linear_to_nonlinear(rgba.rgb);
    rgba.rgb *= rgba.a;
    rgba.rgb = srgb_nonlinear_to_linear(rgba.rgb);
    return rgba;
}

vec4 _main_wrap(VertInOut vert_in)
{
    return PSDrawNonlinearAlpha(vert_in);
}

void main(void)
{
    VertInOut vert_in;
    vert_in.pos = gl_FragCoord;
    vert_in.uv = _vertex_shader_attrib0;

    _pixel_shader_attrib0 = _main_wrap(vert_in);
}

info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform mat4x4 ViewProj;

in vec4 _input_attrib0;
in vec2 _input_attrib1;

out vec2 _vertex_shader_attrib0;

out gl_PerVertex {
    vec4 gl_Position;
};

struct VertInOut {
    vec4 pos;
    vec2 uv;
};

VertInOut VSDefault(VertInOut vert_in)
{
    VertInOut vert_out;
    vert_out.pos = ((vec4(vert_in.pos.xyz, 1.0)) * (ViewProj));
    vert_out.uv  = vert_in.uv;
    return vert_out;
}

VertInOut _main_wrap(VertInOut vert_in)
{
    return VSDefault(vert_in);
}

void main(void)
{
    VertInOut vert_in;
    VertInOut outputval;

    vert_in.pos = _input_attrib0;
    vert_in.uv = _input_attrib1;

    outputval = _main_wrap(vert_in);

    gl_Position = outputval.pos;
    _vertex_shader_attrib0 = outputval.uv;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform sampler2D image;
uniform float multiplier;

in vec2 _vertex_shader_attrib0;

out vec4 _pixel_shader_attrib0;

struct VertInOut {
    vec4 pos;
    vec2 uv;
};

float srgb_linear_to_nonlinear_channel(float u)
{
    return (u <= 0.0031308) ? (12.92 * u) : ((1.055 * pow(u, 1. / 2.4)) - 0.055);
}

vec3 srgb_linear_to_nonlinear(vec3 v)
{
    return vec3(srgb_linear_to_nonlinear_channel(v.r), srgb_linear_to_nonlinear_channel(v.g), srgb_linear_to_nonlinear_channel(v.b));
}

float srgb_nonlinear_to_linear_channel(float u)
{
    return (u <= 0.04045) ? (u / 12.92) : pow((u + 0.055) / 1.055, 2.4);
}

vec3 srgb_nonlinear_to_linear(vec3 v)
{
    return vec3(srgb_nonlinear_to_linear_channel(v.r), srgb_nonlinear_to_linear_channel(v.g), srgb_nonlinear_to_linear_channel(v.b));
}

vec4 PSDrawNonlinearAlphaMultiply(VertInOut vert_in)
{
    vec4 rgba = texture(image, vert_in.uv);
    rgba.rgb = srgb_linear_to_nonlinear(rgba.rgb);
    rgba.rgb *= rgba.a;
    rgba.rgb = srgb_nonlinear_to_linear(rgba.rgb);
    rgba.rgb *= multiplier;
    return rgba;
}

vec4 _main_wrap(VertInOut vert_in)
{
    return PSDrawNonlinearAlphaMultiply(vert_in);
}

void main(void)
{
    VertInOut vert_in;
    vert_in.pos = gl_FragCoord;
    vert_in.uv = _vertex_shader_attrib0;

    _pixel_shader_attrib0 = _main_wrap(vert_in);
}

info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform mat4x4 ViewProj;

in vec4 _input_attrib0;
in vec2 _input_attrib1;

out vec2 _vertex_shader_attrib0;

out gl_PerVertex {
    vec4 gl_Position;
};

struct VertInOut {
    vec4 pos;
    vec2 uv;
};

VertInOut VSDefault(VertInOut vert_in)
{
    VertInOut vert_out;
    vert_out.pos = ((vec4(vert_in.pos.xyz, 1.0)) * (ViewProj));
    vert_out.uv  = vert_in.uv;
    return vert_out;
}

VertInOut _main_wrap(VertInOut vert_in)
{
    return VSDefault(vert_in);
}

void main(void)
{
    VertInOut vert_in;
    VertInOut outputval;

    vert_in.pos = _input_attrib0;
    vert_in.uv = _input_attrib1;

    outputval = _main_wrap(vert_in);

    gl_Position = outputval.pos;
    _vertex_shader_attrib0 = outputval.uv;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform sampler2D image;

in vec2 _vertex_shader_attrib0;

out vec4 _pixel_shader_attrib0;

struct VertInOut {
    vec4 pos;
    vec2 uv;
};

float srgb_nonlinear_to_linear_channel(float u)
{
    return (u <= 0.04045) ? (u / 12.92) : pow((u + 0.055) / 1.055, 2.4);
}

vec3 srgb_nonlinear_to_linear(vec3 v)
{
    return vec3(srgb_nonlinear_to_linear_channel(v.r), srgb_nonlinear_to_linear_channel(v.g), srgb_nonlinear_to_linear_channel(v.b));
}

vec4 PSDrawSrgbDecompress(VertInOut vert_in)
{
    vec4 rgba = texture(image, vert_in.uv);
    rgba.rgb = srgb_nonlinear_to_linear(rgba.rgb);
    return rgba;
}

vec4 _main_wrap(VertInOut vert_in)
{
    return PSDrawSrgbDecompress(vert_in);
}

void main(void)
{
    VertInOut vert_in;
    vert_in.pos = gl_FragCoord;
    vert_in.uv = _vertex_shader_attrib0;

    _pixel_shader_attrib0 = _main_wrap(vert_in);
}

info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform mat4x4 ViewProj;

in vec4 _input_attrib0;
in vec2 _input_attrib1;

out vec2 _vertex_shader_attrib0;

out gl_PerVertex {
    vec4 gl_Position;
};

struct VertInOut {
    vec4 pos;
    vec2 uv;
};

VertInOut VSDefault(VertInOut vert_in)
{
    VertInOut vert_out;
    vert_out.pos = ((vec4(vert_in.pos.xyz, 1.0)) * (ViewProj));
    vert_out.uv  = vert_in.uv;
    return vert_out;
}

VertInOut _main_wrap(VertInOut vert_in)
{
    return VSDefault(vert_in);
}

void main(void)
{
    VertInOut vert_in;
    VertInOut outputval;

    vert_in.pos = _input_attrib0;
    vert_in.uv = _input_attrib1;

    outputval = _main_wrap(vert_in);

    gl_Position = outputval.pos;
    _vertex_shader_attrib0 = outputval.uv;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform sampler2D image;
uniform float multiplier;

in vec2 _vertex_shader_attrib0;

out vec4 _pixel_shader_attrib0;

struct VertInOut {
    vec4 pos;
    vec2 uv;
};

float srgb_nonlinear_to_linear_channel(float u)
{
    return (u <= 0.04045) ? (u / 12.92) : pow((u + 0.055) / 1.055, 2.4);
}

vec3 srgb_nonlinear_to_linear(vec3 v)
{
    return vec3(srgb_nonlinear_to_linear_channel(v.r), srgb_nonlinear_to_linear_channel(v.g), srgb_nonlinear_to_linear_channel(v.b));
}

vec4 PSDrawSrgbDecompressMultiply(VertInOut vert_in)
{
    vec4 rgba = texture(image, vert_in.uv);
    rgba.rgb = srgb_nonlinear_to_linear(rgba.rgb);
    rgba.rgb *= multiplier;
    return rgba;
}

vec4 _main_wrap(VertInOut vert_in)
{
    return PSDrawSrgbDecompressMultiply(vert_in);
}

void main(void)
{
    VertInOut vert_in;
    vert_in.pos = gl_FragCoord;
    vert_in.uv = _vertex_shader_attrib0;

    _pixel_shader_attrib0 = _main_wrap(vert_in);
}

info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform mat4x4 ViewProj;

in vec4 _input_attrib0;
in vec2 _input_attrib1;

out vec2 _vertex_shader_attrib0;

out gl_PerVertex {
    vec4 gl_Position;
};

struct VertInOut {
    vec4 pos;
    vec2 uv;
};

VertInOut VSDefault(VertInOut vert_in)
{
    VertInOut vert_out;
    vert_out.pos = ((vec4(vert_in.pos.xyz, 1.0)) * (ViewProj));
    vert_out.uv  = vert_in.uv;
    return vert_out;
}

VertInOut _main_wrap(VertInOut vert_in)
{
    return VSDefault(vert_in);
}

void main(void)
{
    VertInOut vert_in;
    VertInOut outputval;

    vert_in.pos = _input_attrib0;
    vert_in.uv = _input_attrib1;

    outputval = _main_wrap(vert_in);

    gl_Position = outputval.pos;
    _vertex_shader_attrib0 = outputval.uv;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform sampler2D image;
uniform float multiplier;

in vec2 _vertex_shader_attrib0;

out vec4 _pixel_shader_attrib0;

struct VertInOut {
    vec4 pos;
    vec2 uv;
};

vec4 PSDrawMultiply(VertInOut vert_in)
{
    vec4 rgba = texture(image, vert_in.uv);
    rgba.rgb *= multiplier;
    return rgba;
}

vec4 _main_wrap(VertInOut vert_in)
{
    return PSDrawMultiply(vert_in);
}

void main(void)
{
    VertInOut vert_in;
    vert_in.pos = gl_FragCoord;
    vert_in.uv = _vertex_shader_attrib0;

    _pixel_shader_attrib0 = _main_wrap(vert_in);
}

info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform mat4x4 ViewProj;

in vec4 _input_attrib0;
in vec2 _input_attrib1;

out vec2 _vertex_shader_attrib0;

out gl_PerVertex {
    vec4 gl_Position;
};

struct VertInOut {
    vec4 pos;
    vec2 uv;
};

VertInOut VSDefault(VertInOut vert_in)
{
    VertInOut vert_out;
    vert_out.pos = ((vec4(vert_in.pos.xyz, 1.0)) * (ViewProj));
    vert_out.uv  = vert_in.uv;
    return vert_out;
}

VertInOut _main_wrap(VertInOut vert_in)
{
    return VSDefault(vert_in);
}

void main(void)
{
    VertInOut vert_in;
    VertInOut outputval;

    vert_in.pos = _input_attrib0;
    vert_in.uv = _input_attrib1;

    outputval = _main_wrap(vert_in);

    gl_Position = outputval.pos;
    _vertex_shader_attrib0 = outputval.uv;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform sampler2D image;

in vec2 _vertex_shader_attrib0;

out vec4 _pixel_shader_attrib0;

struct VertInOut {
    vec4 pos;
    vec2 uv;
};

vec3 rec709_to_rec2020(vec3 v)
{
    float r = dot(v, vec3(0.62740389593469903, 0.32928303837788370, 0.043313065687417225));
    float g = dot(v, vec3(0.069097289358232075, 0.91954039507545871, 0.011362315566309178));
    float b = dot(v, vec3(0.016391438875150280, 0.088013307877225749, 0.89559525324762401));
    return vec3(r, g, b);
}

float srgb_nonlinear_to_linear_channel(float u)
{
    return (u <= 0.04045) ? (u / 12.92) : pow((u + 0.055) / 1.055, 2.4);
}

vec3 srgb_nonlinear_to_linear(vec3 v)
{
    return vec3(srgb_nonlinear_to_linear_channel(v.r), srgb_nonlinear_to_linear_channel(v.g), srgb_nonlinear_to_linear_channel(v.b));
}

vec3 reinhard(vec3 rgb)
{
    rgb /= rgb + vec3(1., 1., 1.);
    rgb = pow(rgb, vec3(1. / 2.4, 1. / 2.4, 1. / 2.4));
    rgb = srgb_nonlinear_to_linear(rgb);
    return rgb;
}

vec3 rec2020_to_rec709(vec3 v)
{
    float r = dot(v, vec3(1.6604910021084345, -0.58764113878854951, -0.072849863319884883));
    float g = dot(v, vec3(-0.12455047452159074, 1.1328998971259603, -0.0083494226043694768));
    float b = dot(v, vec3(-0.018150763354905303, -0.10057889800800739, 1.1187296613629127));
    return vec3(r, g, b);
}

vec4 PSDrawTonemap(VertInOut vert_in)
{
    vec4 rgba = texture(image, vert_in.uv);
    rgba.rgb = rec709_to_rec2020(rgba.rgb);
    rgba.rgb = reinhard(rgba.rgb);
    rgba.rgb = rec2020_to_rec709(rgba.rgb);
    return rgba;
}

vec4 _main_wrap(VertInOut vert_in)
{
    return PSDrawTonemap(vert_in);
}

void main(void)
{
    VertInOut vert_in;
    vert_in.pos = gl_FragCoord;
    vert_in.uv = _vertex_shader_attrib0;

    _pixel_shader_attrib0 = _main_wrap(vert_in);
}

info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform mat4x4 ViewProj;

in vec4 _input_attrib0;
in vec2 _input_attrib1;

out vec2 _vertex_shader_attrib0;

out gl_PerVertex {
    vec4 gl_Position;
};

struct VertInOut {
    vec4 pos;
    vec2 uv;
};

VertInOut VSDefault(VertInOut vert_in)
{
    VertInOut vert_out;
    vert_out.pos = ((vec4(vert_in.pos.xyz, 1.0)) * (ViewProj));
    vert_out.uv  = vert_in.uv;
    return vert_out;
}

VertInOut _main_wrap(VertInOut vert_in)
{
    return VSDefault(vert_in);
}

void main(void)
{
    VertInOut vert_in;
    VertInOut outputval;

    vert_in.pos = _input_attrib0;
    vert_in.uv = _input_attrib1;

    outputval = _main_wrap(vert_in);

    gl_Position = outputval.pos;
    _vertex_shader_attrib0 = outputval.uv;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform sampler2D image;
uniform float multiplier;

in vec2 _vertex_shader_attrib0;

out vec4 _pixel_shader_attrib0;

struct VertInOut {
    vec4 pos;
    vec2 uv;
};

vec3 rec709_to_rec2020(vec3 v)
{
    float r = dot(v, vec3(0.62740389593469903, 0.32928303837788370, 0.043313065687417225));
    float g = dot(v, vec3(0.069097289358232075, 0.91954039507545871, 0.011362315566309178));
    float b = dot(v, vec3(0.016391438875150280, 0.088013307877225749, 0.89559525324762401));
    return vec3(r, g, b);
}

float srgb_nonlinear_to_linear_channel(float u)
{
    return (u <= 0.04045) ? (u / 12.92) : pow((u + 0.055) / 1.055, 2.4);
}

vec3 srgb_nonlinear_to_linear(vec3 v)
{
    return vec3(srgb_nonlinear_to_linear_channel(v.r), srgb_nonlinear_to_linear_channel(v.g), srgb_nonlinear_to_linear_channel(v.b));
}

vec3 reinhard(vec3 rgb)
{
    rgb /= rgb + vec3(1., 1., 1.);
    rgb = pow(rgb, vec3(1. / 2.4, 1. / 2.4, 1. / 2.4));
    rgb = srgb_nonlinear_to_linear(rgb);
    return rgb;
}

vec3 rec2020_to_rec709(vec3 v)
{
    float r = dot(v, vec3(1.6604910021084345, -0.58764113878854951, -0.072849863319884883));
    float g = dot(v, vec3(-0.12455047452159074, 1.1328998971259603, -0.0083494226043694768));
    float b = dot(v, vec3(-0.018150763354905303, -0.10057889800800739, 1.1187296613629127));
    return vec3(r, g, b);
}

vec4 PSDrawMultiplyTonemap(VertInOut vert_in)
{
    vec4 rgba = texture(image, vert_in.uv);
    rgba.rgb *= multiplier;
    rgba.rgb = rec709_to_rec2020(rgba.rgb);
    rgba.rgb = reinhard(rgba.rgb);
    rgba.rgb = rec2020_to_rec709(rgba.rgb);
    return rgba;
}

vec4 _main_wrap(VertInOut vert_in)
{
    return PSDrawMultiplyTonemap(vert_in);
}

void main(void)
{
    VertInOut vert_in;
    vert_in.pos = gl_FragCoord;
    vert_in.uv = _vertex_shader_attrib0;

    _pixel_shader_attrib0 = _main_wrap(vert_in);
}

info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform mat4x4 ViewProj;

in vec4 _input_attrib0;
in vec2 _input_attrib1;

out vec2 _vertex_shader_attrib0;

out gl_PerVertex {
    vec4 gl_Position;
};

struct VertInOut {
    vec4 pos;
    vec2 uv;
};

VertInOut VSDefault(VertInOut vert_in)
{
    VertInOut vert_out;
    vert_out.pos = ((vec4(vert_in.pos.xyz, 1.0)) * (ViewProj));
    vert_out.uv  = vert_in.uv;
    return vert_out;
}

VertInOut _main_wrap(VertInOut vert_in)
{
    return VSDefault(vert_in);
}

void main(void)
{
    VertInOut vert_in;
    VertInOut outputval;

    vert_in.pos = _input_attrib0;
    vert_in.uv = _input_attrib1;

    outputval = _main_wrap(vert_in);

    gl_Position = outputval.pos;
    _vertex_shader_attrib0 = outputval.uv;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform sampler2D image;
uniform float multiplier;

in vec2 _vertex_shader_attrib0;

out vec4 _pixel_shader_attrib0;

struct VertInOut {
    vec4 pos;
    vec2 uv;
};

float st2084_to_linear_channel(float u)
{
    float c = pow(abs(u), 1. / 78.84375);
    return pow(abs(max(c - 0.8359375, 0.) / (18.8515625 - 18.6875 * c)), 1. / 0.1593017578);
}

vec3 st2084_to_linear(vec3 rgb)
{
    return vec3(st2084_to_linear_channel(rgb.r), st2084_to_linear_channel(rgb.g), st2084_to_linear_channel(rgb.b));
}

vec3 rec2020_to_rec709(vec3 v)
{
    float r = dot(v, vec3(1.6604910021084345, -0.58764113878854951, -0.072849863319884883));
    float g = dot(v, vec3(-0.12455047452159074, 1.1328998971259603, -0.0083494226043694768));
    float b = dot(v, vec3(-0.018150763354905303, -0.10057889800800739, 1.1187296613629127));
    return vec3(r, g, b);
}

vec4 PSDrawPQ(VertInOut vert_in)
{
    vec4 rgba = texture(image, vert_in.uv);
    rgba.rgb = st2084_to_linear(rgba.rgb) * multiplier;
    rgba.rgb = rec2020_to_rec709(rgba.rgb);
    return rgba;
}

vec4 _main_wrap(VertInOut vert_in)
{
    return PSDrawPQ(vert_in);
}

void main(void)
{
    VertInOut vert_in;
    vert_in.pos = gl_FragCoord;
    vert_in.uv = _vertex_shader_attrib0;

    _pixel_shader_attrib0 = _main_wrap(vert_in);
}

info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform mat4x4 ViewProj;

in vec4 _input_attrib0;
in vec2 _input_attrib1;

out vec2 _vertex_shader_attrib0;

out gl_PerVertex {
    vec4 gl_Position;
};

struct VertInOut {
    vec4 pos;
    vec2 uv;
};

VertInOut VSDefault(VertInOut vert_in)
{
    VertInOut vert_out;
    vert_out.pos = ((vec4(vert_in.pos.xyz, 1.0)) * (ViewProj));
    vert_out.uv  = vert_in.uv;
    return vert_out;
}

VertInOut _main_wrap(VertInOut vert_in)
{
    return VSDefault(vert_in);
}

void main(void)
{
    VertInOut vert_in;
    VertInOut outputval;

    vert_in.pos = _input_attrib0;
    vert_in.uv = _input_attrib1;

    outputval = _main_wrap(vert_in);

    gl_Position = outputval.pos;
    _vertex_shader_attrib0 = outputval.uv;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform sampler2D image;
uniform float multiplier;

in vec2 _vertex_shader_attrib0;

out vec4 _pixel_shader_attrib0;

struct VertInOut {
    vec4 pos;
    vec2 uv;
};

float st2084_to_linear_channel(float u)
{
    float c = pow(abs(u), 1. / 78.84375);
    return pow(abs(max(c - 0.8359375, 0.) / (18.8515625 - 18.6875 * c)), 1. / 0.1593017578);
}

vec3 st2084_to_linear(vec3 rgb)
{
    return vec3(st2084_to_linear_channel(rgb.r), st2084_to_linear_channel(rgb.g), st2084_to_linear_channel(rgb.b));
}

float srgb_nonlinear_to_linear_channel(float u)
{
    return (u <= 0.04045) ? (u / 12.92) : pow((u + 0.055) / 1.055, 2.4);
}

vec3 srgb_nonlinear_to_linear(vec3 v)
{
    return vec3(srgb_nonlinear_to_linear_channel(v.r), srgb_nonlinear_to_linear_channel(v.g), srgb_nonlinear_to_linear_channel(v.b));
}

vec3 reinhard(vec3 rgb)
{
    rgb /= rgb + vec3(1., 1., 1.);
    rgb = pow(rgb, vec3(1. / 2.4, 1. / 2.4, 1. / 2.4));
    rgb = srgb_nonlinear_to_linear(rgb);
    return rgb;
}

vec3 rec2020_to_rec709(vec3 v)
{
    float r = dot(v, vec3(1.6604910021084345, -0.58764113878854951, -0.072849863319884883));
    float g = dot(v, vec3(-0.12455047452159074, 1.1328998971259603, -0.0083494226043694768));
    float b = dot(v, vec3(-0.018150763354905303, -0.10057889800800739, 1.1187296613629127));
    return vec3(r, g, b);
}

vec4 PSDrawTonemapPQ(VertInOut vert_in)
{
    vec4 rgba = texture(image, vert_in.uv);
    rgba.rgb = st2084_to_linear(rgba.rgb) * multiplier;
    rgba.rgb = reinhard(rgba.rgb);
    rgba.rgb = rec2020_to_rec709(rgba.rgb);
    return rgba;
}

vec4 _main_wrap(VertInOut vert_in)
{
    return PSDrawTonemapPQ(vert_in);
}

void main(void)
{
    VertInOut vert_in;
    vert_in.pos = gl_FragCoord;
    vert_in.uv = _vertex_shader_attrib0;

    _pixel_shader_attrib0 = _main_wrap(vert_in);
}

info: ======funcs =======
info: fname:srgb_linear_to_nonlinear_channel rtype:float mapping:(null) content:{
    return (u <= 0.0031308) ? (12.92 * u) : ((1.055 * pow(u, 1. / 2.4)) - 0.055);
}
info: fname:srgb_linear_to_nonlinear rtype:float3 mapping:(null) content:{
    return float3(srgb_linear_to_nonlinear_channel(v.r), srgb_linear_to_nonlinear_channel(v.g), srgb_linear_to_nonlinear_channel(v.b));
}
info: fname:srgb_nonlinear_to_linear_channel rtype:float mapping:(null) content:{
    return (u <= 0.04045) ? (u / 12.92) : pow((u + 0.055) / 1.055, 2.4);
}
info: fname:srgb_nonlinear_to_linear rtype:float3 mapping:(null) content:{
    return float3(srgb_nonlinear_to_linear_channel(v.r), srgb_nonlinear_to_linear_channel(v.g), srgb_nonlinear_to_linear_channel(v.b));
}
info: fname:rec709_to_rec2020 rtype:float3 mapping:(null) content:{
    float r = dot(v, float3(0.62740389593469903, 0.32928303837788370, 0.043313065687417225));
    float g = dot(v, float3(0.069097289358232075, 0.91954039507545871, 0.011362315566309178));
    float b = dot(v, float3(0.016391438875150280, 0.088013307877225749, 0.89559525324762401));
    return float3(r, g, b);
}
info: fname:d65p3_to_rec709 rtype:float3 mapping:(null) content:{
    float r = dot(v, float3(1.2249401762805598, -0.22494017628055996, 0.));
    float g = dot(v, float3(-0.042056954709688163, 1.0420569547096881, 0.));
    float b = dot(v, float3(-0.019637554590334432, -0.078636045550631889, 1.0982736001409663));
    return float3(r, g, b);
}
info: fname:rec2020_to_rec709 rtype:float3 mapping:(null) content:{
    float r = dot(v, float3(1.6604910021084345, -0.58764113878854951, -0.072849863319884883));
    float g = dot(v, float3(-0.12455047452159074, 1.1328998971259603, -0.0083494226043694768));
    float b = dot(v, float3(-0.018150763354905303, -0.10057889800800739, 1.1187296613629127));
    return float3(r, g, b);
}
info: fname:reinhard rtype:float3 mapping:(null) content:{
    rgb /= rgb + float3(1., 1., 1.);
    rgb = pow(rgb, float3(1. / 2.4, 1. / 2.4, 1. / 2.4));
    rgb = srgb_nonlinear_to_linear(rgb);
    return rgb;
}
info: fname:linear_to_st2084_channel rtype:float mapping:(null) content:{
    float c = pow(abs(x), 0.1593017578);
    return pow((0.8359375 + 18.8515625 * c) / (1. + 18.6875 * c), 78.84375);
}
info: fname:linear_to_st2084 rtype:float3 mapping:(null) content:{
    return float3(linear_to_st2084_channel(rgb.r), linear_to_st2084_channel(rgb.g), linear_to_st2084_channel(rgb.b));
}
info: fname:st2084_to_linear_channel rtype:float mapping:(null) content:{
    float c = pow(abs(u), 1. / 78.84375);
    return pow(abs(max(c - 0.8359375, 0.) / (18.8515625 - 18.6875 * c)), 1. / 0.1593017578);
}
info: fname:st2084_to_linear rtype:float3 mapping:(null) content:{
    return float3(st2084_to_linear_channel(rgb.r), st2084_to_linear_channel(rgb.g), st2084_to_linear_channel(rgb.b));
}
info: fname:eetf_0_Lmax rtype:float mapping:(null) content:{
    float Lw_pq = linear_to_st2084_channel(Lw / 10000.);
    float E1 = saturate(maxRGB1_pq / Lw_pq);
    float maxLum = linear_to_st2084_channel(Lmax / 10000.) / Lw_pq;
    float KS = (1.5 * maxLum) - 0.5;
    float E2 = E1;
    if (E1 > KS)
    {
        float T = (E1 - KS) / (1. - KS);
        float Tsquared = T * T;
        float Tcubed = Tsquared * T;
        float P = (2. * Tcubed - 3. * Tsquared + 1.) * KS + (Tcubed - 2. * Tsquared + T) * (1. - KS) + (-2. * Tcubed + 3. * Tsquared) * maxLum;
        E2 = P;
    }
    float E3 = E2;
    float E4 = E3 * Lw_pq;
    return E4;
}
info: fname:maxRGB_eetf_internal rtype:float3 mapping:(null) content:{
    float maxRGB2_pq = eetf_0_Lmax(maxRGB1_pq, Lw, Lmax);
    float maxRGB2_linear = st2084_to_linear_channel(maxRGB2_pq);

     
    maxRGB1_linear = max(6.10352e-5, maxRGB1_linear);

    rgb_linear *= maxRGB2_linear / maxRGB1_linear;
    return rgb_linear;
}
info: fname:maxRGB_eetf_pq_to_linear rtype:float3 mapping:(null) content:{
    float3 rgb_linear = st2084_to_linear(rgb_pq);
    float maxRGB1_linear = max(max(rgb_linear.r, rgb_linear.g), rgb_linear.b);
    float maxRGB1_pq = max(max(rgb_pq.r, rgb_pq.g), rgb_pq.b);
    return maxRGB_eetf_internal(rgb_linear, maxRGB1_linear, maxRGB1_pq, Lw, Lmax);
}
info: fname:maxRGB_eetf_linear_to_linear rtype:float3 mapping:(null) content:{
    float maxRGB1_linear = max(max(rgb_linear.r, rgb_linear.g), rgb_linear.b);
    float maxRGB1_pq = linear_to_st2084_channel(maxRGB1_linear);
    return maxRGB_eetf_internal(rgb_linear, maxRGB1_linear, maxRGB1_pq, Lw, Lmax);
}
info: fname:st2084_to_linear_eetf rtype:float3 mapping:(null) content:{
    return (Lw > Lmax) ? maxRGB_eetf_pq_to_linear(rgb, Lw, Lmax) : st2084_to_linear(rgb);
}
info: fname:linear_to_hlg_channel rtype:float mapping:(null) content:{
    float ln2_i = 1. / log(2.);
    float m = 0.17883277 / ln2_i;
    return (u <= (1. / 12.)) ? sqrt(3. * u) : ((log2((12. * u) - 0.28466892) * m) + 0.55991073);
}
info: fname:linear_to_hlg rtype:float3 mapping:(null) content:{
    rgb = saturate(rgb);

    if (Lw > 1000.)
    {
        rgb = maxRGB_eetf_linear_to_linear(rgb, Lw, 1000.);
        rgb *= 10000. / Lw;
    }
    else
    {
        rgb *= 10.;
    }

    float Yd = dot(rgb, float3(0.2627, 0.678, 0.0593));

     
    Yd = max(6.10352e-5, Yd);

    rgb *= pow(Yd, -1. / 6.);
    return float3(linear_to_hlg_channel(rgb.r), linear_to_hlg_channel(rgb.g), linear_to_hlg_channel(rgb.b));
}
info: fname:hlg_to_linear_channel rtype:float mapping:(null) content:{
    float ln2_i = 1. / log(2.);
    float m = ln2_i / 0.17883277;
    float a = -ln2_i * 0.55991073 / 0.17883277;
    return (u <= 0.5) ? ((u * u) / 3.) : ((exp2(u * m + a) + 0.28466892) / 12.);
}
info: fname:hlg_to_linear rtype:float3 mapping:(null) content:{
    float3 rgb = float3(hlg_to_linear_channel(v.r), hlg_to_linear_channel(v.g), hlg_to_linear_channel(v.b));
    float Ys = dot(rgb, float3(0.2627, 0.678, 0.0593));
    rgb *= pow(Ys, exponent);
    return rgb;
}
info: fname:VSDefault rtype:VertInOut mapping:(null) content:{
    VertInOut vert_out;
    vert_out.pos = mul(float4(vert_in.pos.xyz, 1.0), ViewProj);
    vert_out.uv  = vert_in.uv;
    return vert_out;
}
info: fname:PSDrawBare rtype:float4 mapping:TARGET content:{
    return image.Sample(def_sampler, vert_in.uv);
}
info: fname:PSDrawAlphaDivide rtype:float4 mapping:TARGET content:{
    float4 rgba = image.Sample(def_sampler, vert_in.uv);
    rgba.rgb *= max(1. / rgba.a, 0.);
    return rgba;
}
info: fname:PSDrawNonlinearAlpha rtype:float4 mapping:TARGET content:{
    float4 rgba = image.Sample(def_sampler, vert_in.uv);
    rgba.rgb = srgb_linear_to_nonlinear(rgba.rgb);
    rgba.rgb *= rgba.a;
    rgba.rgb = srgb_nonlinear_to_linear(rgba.rgb);
    return rgba;
}
info: fname:PSDrawNonlinearAlphaMultiply rtype:float4 mapping:TARGET content:{
    float4 rgba = image.Sample(def_sampler, vert_in.uv);
    rgba.rgb = srgb_linear_to_nonlinear(rgba.rgb);
    rgba.rgb *= rgba.a;
    rgba.rgb = srgb_nonlinear_to_linear(rgba.rgb);
    rgba.rgb *= multiplier;
    return rgba;
}
info: fname:PSDrawSrgbDecompress rtype:float4 mapping:TARGET content:{
    float4 rgba = image.Sample(def_sampler, vert_in.uv);
    rgba.rgb = srgb_nonlinear_to_linear(rgba.rgb);
    return rgba;
}
info: fname:PSDrawSrgbDecompressMultiply rtype:float4 mapping:TARGET content:{
    float4 rgba = image.Sample(def_sampler, vert_in.uv);
    rgba.rgb = srgb_nonlinear_to_linear(rgba.rgb);
    rgba.rgb *= multiplier;
    return rgba;
}
info: fname:PSDrawMultiply rtype:float4 mapping:TARGET content:{
    float4 rgba = image.Sample(def_sampler, vert_in.uv);
    rgba.rgb *= multiplier;
    return rgba;
}
info: fname:PSDrawTonemap rtype:float4 mapping:TARGET content:{
    float4 rgba = image.Sample(def_sampler, vert_in.uv);
    rgba.rgb = rec709_to_rec2020(rgba.rgb);
    rgba.rgb = reinhard(rgba.rgb);
    rgba.rgb = rec2020_to_rec709(rgba.rgb);
    return rgba;
}
info: fname:PSDrawMultiplyTonemap rtype:float4 mapping:TARGET content:{
    float4 rgba = image.Sample(def_sampler, vert_in.uv);
    rgba.rgb *= multiplier;
    rgba.rgb = rec709_to_rec2020(rgba.rgb);
    rgba.rgb = reinhard(rgba.rgb);
    rgba.rgb = rec2020_to_rec709(rgba.rgb);
    return rgba;
}
info: fname:PSDrawPQ rtype:float4 mapping:TARGET content:{
    float4 rgba = image.Sample(def_sampler, vert_in.uv);
    rgba.rgb = st2084_to_linear(rgba.rgb) * multiplier;
    rgba.rgb = rec2020_to_rec709(rgba.rgb);
    return rgba;
}
info: fname:PSDrawTonemapPQ rtype:float4 mapping:TARGET content:{
    float4 rgba = image.Sample(def_sampler, vert_in.uv);
    rgba.rgb = st2084_to_linear(rgba.rgb) * multiplier;
    rgba.rgb = reinhard(rgba.rgb);
    rgba.rgb = rec2020_to_rec709(rgba.rgb);
    return rgba;
}
info: ======params =======
info: fname:ViewProj type:float4x4
info: fname:image type:texture2d
info: fname:multiplier type:float
info: ======structs =======
info: fname:VertInOut
info: ======samplers =======
info: fname:def_sampler
info: ======techniques =======
info: fname:Draw
info: fname:DrawAlphaDivide
info: fname:DrawNonlinearAlpha
info: fname:DrawNonlinearAlphaMultiply
info: fname:DrawSrgbDecompress
info: fname:DrawSrgbDecompressMultiply
info: fname:DrawMultiply
info: fname:DrawTonemap
info: fname:DrawMultiplyTonemap
info: fname:DrawPQ
info: fname:DrawTonemapPQ
info: ======files =======
info: ======tokens =======
info: ======techniques =======
info: tname:Draw
info: tname:(null)
info: tname:DrawAlphaDivide
info: tname:(null)
info: tname:DrawNonlinearAlpha
info: tname:(null)
info: tname:DrawNonlinearAlphaMultiply
info: tname:(null)
info: tname:DrawSrgbDecompress
info: tname:(null)
info: tname:DrawSrgbDecompressMultiply
info: tname:(null)
info: tname:DrawMultiply
info: tname:(null)
info: tname:DrawTonemap
info: tname:(null)
info: tname:DrawMultiplyTonemap
info: tname:(null)
info: tname:DrawPQ
info: tname:(null)
info: tname:DrawTonemapPQ
info: tname:(null)
info: ======params =======
info: tname:ViewProj
info: tname:image
info: tname:multiplier
info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform mat4x4 ViewProj;

in vec4 _input_attrib0;
in vec2 _input_attrib1;

out vec2 _vertex_shader_attrib0;

out gl_PerVertex {
    vec4 gl_Position;
};

struct VertInOut {
    vec4 pos;
    vec2 uv;
};

VertInOut VSDefault(VertInOut vert_in)
{
    VertInOut vert_out;
    vert_out.pos = ((vec4(vert_in.pos.xyz, 1.0)) * (ViewProj));
    vert_out.uv  = vert_in.uv;
    return vert_out;
}

VertInOut _main_wrap(VertInOut vert_in)
{
    return VSDefault(vert_in);
}

void main(void)
{
    VertInOut vert_in;
    VertInOut outputval;

    vert_in.pos = _input_attrib0;
    vert_in.uv = _input_attrib1;

    outputval = _main_wrap(vert_in);

    gl_Position = outputval.pos;
    _vertex_shader_attrib0 = outputval.uv;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform sampler2DRect image;

in vec2 _vertex_shader_attrib0;

out vec4 _pixel_shader_attrib0;

struct VertInOut {
    vec4 pos;
    vec2 uv;
};

vec4 PSDrawBare(VertInOut vert_in)
{
    return texture(image, vert_in.uv);
}

vec4 _main_wrap(VertInOut vert_in)
{
    return PSDrawBare(vert_in);
}

void main(void)
{
    VertInOut vert_in;
    vert_in.pos = gl_FragCoord;
    vert_in.uv = _vertex_shader_attrib0;

    _pixel_shader_attrib0 = _main_wrap(vert_in);
}

info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform mat4x4 ViewProj;

in vec4 _input_attrib0;
in vec2 _input_attrib1;

out vec2 _vertex_shader_attrib0;

out gl_PerVertex {
    vec4 gl_Position;
};

struct VertInOut {
    vec4 pos;
    vec2 uv;
};

VertInOut VSDefault(VertInOut vert_in)
{
    VertInOut vert_out;
    vert_out.pos = ((vec4(vert_in.pos.xyz, 1.0)) * (ViewProj));
    vert_out.uv  = vert_in.uv;
    return vert_out;
}

VertInOut _main_wrap(VertInOut vert_in)
{
    return VSDefault(vert_in);
}

void main(void)
{
    VertInOut vert_in;
    VertInOut outputval;

    vert_in.pos = _input_attrib0;
    vert_in.uv = _input_attrib1;

    outputval = _main_wrap(vert_in);

    gl_Position = outputval.pos;
    _vertex_shader_attrib0 = outputval.uv;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform sampler2DRect image;

in vec2 _vertex_shader_attrib0;

out vec4 _pixel_shader_attrib0;

struct VertInOut {
    vec4 pos;
    vec2 uv;
};

float srgb_nonlinear_to_linear_channel(float u)
{
    return (u <= 0.04045) ? (u / 12.92) : pow((u + 0.055) / 1.055, 2.4);
}

vec3 srgb_nonlinear_to_linear(vec3 v)
{
    return vec3(srgb_nonlinear_to_linear_channel(v.r), srgb_nonlinear_to_linear_channel(v.g), srgb_nonlinear_to_linear_channel(v.b));
}

vec3 d65p3_to_rec709(vec3 v)
{
    float r = dot(v, vec3(1.2249401762805598, -0.22494017628055996, 0.));
    float g = dot(v, vec3(-0.042056954709688163, 1.0420569547096881, 0.));
    float b = dot(v, vec3(-0.019637554590334432, -0.078636045550631889, 1.0982736001409663));
    return vec3(r, g, b);
}

vec4 PSDrawD65P3(VertInOut vert_in)
{
    vec4 rgba = texture(image, vert_in.uv);
    rgba.rgb = srgb_nonlinear_to_linear(rgba.rgb);
    rgba.rgb = d65p3_to_rec709(rgba.rgb);
    return rgba;
}

vec4 _main_wrap(VertInOut vert_in)
{
    return PSDrawD65P3(vert_in);
}

void main(void)
{
    VertInOut vert_in;
    vert_in.pos = gl_FragCoord;
    vert_in.uv = _vertex_shader_attrib0;

    _pixel_shader_attrib0 = _main_wrap(vert_in);
}

info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform mat4x4 ViewProj;

in vec4 _input_attrib0;
in vec2 _input_attrib1;

out vec2 _vertex_shader_attrib0;

out gl_PerVertex {
    vec4 gl_Position;
};

struct VertInOut {
    vec4 pos;
    vec2 uv;
};

VertInOut VSDefault(VertInOut vert_in)
{
    VertInOut vert_out;
    vert_out.pos = ((vec4(vert_in.pos.xyz, 1.0)) * (ViewProj));
    vert_out.uv  = vert_in.uv;
    return vert_out;
}

VertInOut _main_wrap(VertInOut vert_in)
{
    return VSDefault(vert_in);
}

void main(void)
{
    VertInOut vert_in;
    VertInOut outputval;

    vert_in.pos = _input_attrib0;
    vert_in.uv = _input_attrib1;

    outputval = _main_wrap(vert_in);

    gl_Position = outputval.pos;
    _vertex_shader_attrib0 = outputval.uv;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform sampler2DRect image;

in vec2 _vertex_shader_attrib0;

out vec4 _pixel_shader_attrib0;

struct VertInOut {
    vec4 pos;
    vec2 uv;
};

vec4 PSDrawOpaque(VertInOut vert_in)
{
    return vec4(texture(image, vert_in.uv).rgb, 1.0);
}

vec4 _main_wrap(VertInOut vert_in)
{
    return PSDrawOpaque(vert_in);
}

void main(void)
{
    VertInOut vert_in;
    vert_in.pos = gl_FragCoord;
    vert_in.uv = _vertex_shader_attrib0;

    _pixel_shader_attrib0 = _main_wrap(vert_in);
}

info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform mat4x4 ViewProj;

in vec4 _input_attrib0;
in vec2 _input_attrib1;

out vec2 _vertex_shader_attrib0;

out gl_PerVertex {
    vec4 gl_Position;
};

struct VertInOut {
    vec4 pos;
    vec2 uv;
};

VertInOut VSDefault(VertInOut vert_in)
{
    VertInOut vert_out;
    vert_out.pos = ((vec4(vert_in.pos.xyz, 1.0)) * (ViewProj));
    vert_out.uv  = vert_in.uv;
    return vert_out;
}

VertInOut _main_wrap(VertInOut vert_in)
{
    return VSDefault(vert_in);
}

void main(void)
{
    VertInOut vert_in;
    VertInOut outputval;

    vert_in.pos = _input_attrib0;
    vert_in.uv = _input_attrib1;

    outputval = _main_wrap(vert_in);

    gl_Position = outputval.pos;
    _vertex_shader_attrib0 = outputval.uv;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform sampler2DRect image;

in vec2 _vertex_shader_attrib0;

out vec4 _pixel_shader_attrib0;

struct VertInOut {
    vec4 pos;
    vec2 uv;
};

float srgb_nonlinear_to_linear_channel(float u)
{
    return (u <= 0.04045) ? (u / 12.92) : pow((u + 0.055) / 1.055, 2.4);
}

vec3 srgb_nonlinear_to_linear(vec3 v)
{
    return vec3(srgb_nonlinear_to_linear_channel(v.r), srgb_nonlinear_to_linear_channel(v.g), srgb_nonlinear_to_linear_channel(v.b));
}

vec4 PSDrawSrgbDecompress(VertInOut vert_in)
{
    vec4 rgba = texture(image, vert_in.uv);
    rgba.rgb = srgb_nonlinear_to_linear(rgba.rgb);
    return rgba;
}

vec4 _main_wrap(VertInOut vert_in)
{
    return PSDrawSrgbDecompress(vert_in);
}

void main(void)
{
    VertInOut vert_in;
    vert_in.pos = gl_FragCoord;
    vert_in.uv = _vertex_shader_attrib0;

    _pixel_shader_attrib0 = _main_wrap(vert_in);
}

info: ======funcs =======
info: fname:srgb_linear_to_nonlinear_channel rtype:float mapping:(null) content:{
    return (u <= 0.0031308) ? (12.92 * u) : ((1.055 * pow(u, 1. / 2.4)) - 0.055);
}
info: fname:srgb_linear_to_nonlinear rtype:float3 mapping:(null) content:{
    return float3(srgb_linear_to_nonlinear_channel(v.r), srgb_linear_to_nonlinear_channel(v.g), srgb_linear_to_nonlinear_channel(v.b));
}
info: fname:srgb_nonlinear_to_linear_channel rtype:float mapping:(null) content:{
    return (u <= 0.04045) ? (u / 12.92) : pow((u + 0.055) / 1.055, 2.4);
}
info: fname:srgb_nonlinear_to_linear rtype:float3 mapping:(null) content:{
    return float3(srgb_nonlinear_to_linear_channel(v.r), srgb_nonlinear_to_linear_channel(v.g), srgb_nonlinear_to_linear_channel(v.b));
}
info: fname:rec709_to_rec2020 rtype:float3 mapping:(null) content:{
    float r = dot(v, float3(0.62740389593469903, 0.32928303837788370, 0.043313065687417225));
    float g = dot(v, float3(0.069097289358232075, 0.91954039507545871, 0.011362315566309178));
    float b = dot(v, float3(0.016391438875150280, 0.088013307877225749, 0.89559525324762401));
    return float3(r, g, b);
}
info: fname:d65p3_to_rec709 rtype:float3 mapping:(null) content:{
    float r = dot(v, float3(1.2249401762805598, -0.22494017628055996, 0.));
    float g = dot(v, float3(-0.042056954709688163, 1.0420569547096881, 0.));
    float b = dot(v, float3(-0.019637554590334432, -0.078636045550631889, 1.0982736001409663));
    return float3(r, g, b);
}
info: fname:rec2020_to_rec709 rtype:float3 mapping:(null) content:{
    float r = dot(v, float3(1.6604910021084345, -0.58764113878854951, -0.072849863319884883));
    float g = dot(v, float3(-0.12455047452159074, 1.1328998971259603, -0.0083494226043694768));
    float b = dot(v, float3(-0.018150763354905303, -0.10057889800800739, 1.1187296613629127));
    return float3(r, g, b);
}
info: fname:reinhard rtype:float3 mapping:(null) content:{
    rgb /= rgb + float3(1., 1., 1.);
    rgb = pow(rgb, float3(1. / 2.4, 1. / 2.4, 1. / 2.4));
    rgb = srgb_nonlinear_to_linear(rgb);
    return rgb;
}
info: fname:linear_to_st2084_channel rtype:float mapping:(null) content:{
    float c = pow(abs(x), 0.1593017578);
    return pow((0.8359375 + 18.8515625 * c) / (1. + 18.6875 * c), 78.84375);
}
info: fname:linear_to_st2084 rtype:float3 mapping:(null) content:{
    return float3(linear_to_st2084_channel(rgb.r), linear_to_st2084_channel(rgb.g), linear_to_st2084_channel(rgb.b));
}
info: fname:st2084_to_linear_channel rtype:float mapping:(null) content:{
    float c = pow(abs(u), 1. / 78.84375);
    return pow(abs(max(c - 0.8359375, 0.) / (18.8515625 - 18.6875 * c)), 1. / 0.1593017578);
}
info: fname:st2084_to_linear rtype:float3 mapping:(null) content:{
    return float3(st2084_to_linear_channel(rgb.r), st2084_to_linear_channel(rgb.g), st2084_to_linear_channel(rgb.b));
}
info: fname:eetf_0_Lmax rtype:float mapping:(null) content:{
    float Lw_pq = linear_to_st2084_channel(Lw / 10000.);
    float E1 = saturate(maxRGB1_pq / Lw_pq);
    float maxLum = linear_to_st2084_channel(Lmax / 10000.) / Lw_pq;
    float KS = (1.5 * maxLum) - 0.5;
    float E2 = E1;
    if (E1 > KS)
    {
        float T = (E1 - KS) / (1. - KS);
        float Tsquared = T * T;
        float Tcubed = Tsquared * T;
        float P = (2. * Tcubed - 3. * Tsquared + 1.) * KS + (Tcubed - 2. * Tsquared + T) * (1. - KS) + (-2. * Tcubed + 3. * Tsquared) * maxLum;
        E2 = P;
    }
    float E3 = E2;
    float E4 = E3 * Lw_pq;
    return E4;
}
info: fname:maxRGB_eetf_internal rtype:float3 mapping:(null) content:{
    float maxRGB2_pq = eetf_0_Lmax(maxRGB1_pq, Lw, Lmax);
    float maxRGB2_linear = st2084_to_linear_channel(maxRGB2_pq);

     
    maxRGB1_linear = max(6.10352e-5, maxRGB1_linear);

    rgb_linear *= maxRGB2_linear / maxRGB1_linear;
    return rgb_linear;
}
info: fname:maxRGB_eetf_pq_to_linear rtype:float3 mapping:(null) content:{
    float3 rgb_linear = st2084_to_linear(rgb_pq);
    float maxRGB1_linear = max(max(rgb_linear.r, rgb_linear.g), rgb_linear.b);
    float maxRGB1_pq = max(max(rgb_pq.r, rgb_pq.g), rgb_pq.b);
    return maxRGB_eetf_internal(rgb_linear, maxRGB1_linear, maxRGB1_pq, Lw, Lmax);
}
info: fname:maxRGB_eetf_linear_to_linear rtype:float3 mapping:(null) content:{
    float maxRGB1_linear = max(max(rgb_linear.r, rgb_linear.g), rgb_linear.b);
    float maxRGB1_pq = linear_to_st2084_channel(maxRGB1_linear);
    return maxRGB_eetf_internal(rgb_linear, maxRGB1_linear, maxRGB1_pq, Lw, Lmax);
}
info: fname:st2084_to_linear_eetf rtype:float3 mapping:(null) content:{
    return (Lw > Lmax) ? maxRGB_eetf_pq_to_linear(rgb, Lw, Lmax) : st2084_to_linear(rgb);
}
info: fname:linear_to_hlg_channel rtype:float mapping:(null) content:{
    float ln2_i = 1. / log(2.);
    float m = 0.17883277 / ln2_i;
    return (u <= (1. / 12.)) ? sqrt(3. * u) : ((log2((12. * u) - 0.28466892) * m) + 0.55991073);
}
info: fname:linear_to_hlg rtype:float3 mapping:(null) content:{
    rgb = saturate(rgb);

    if (Lw > 1000.)
    {
        rgb = maxRGB_eetf_linear_to_linear(rgb, Lw, 1000.);
        rgb *= 10000. / Lw;
    }
    else
    {
        rgb *= 10.;
    }

    float Yd = dot(rgb, float3(0.2627, 0.678, 0.0593));

     
    Yd = max(6.10352e-5, Yd);

    rgb *= pow(Yd, -1. / 6.);
    return float3(linear_to_hlg_channel(rgb.r), linear_to_hlg_channel(rgb.g), linear_to_hlg_channel(rgb.b));
}
info: fname:hlg_to_linear_channel rtype:float mapping:(null) content:{
    float ln2_i = 1. / log(2.);
    float m = ln2_i / 0.17883277;
    float a = -ln2_i * 0.55991073 / 0.17883277;
    return (u <= 0.5) ? ((u * u) / 3.) : ((exp2(u * m + a) + 0.28466892) / 12.);
}
info: fname:hlg_to_linear rtype:float3 mapping:(null) content:{
    float3 rgb = float3(hlg_to_linear_channel(v.r), hlg_to_linear_channel(v.g), hlg_to_linear_channel(v.b));
    float Ys = dot(rgb, float3(0.2627, 0.678, 0.0593));
    rgb *= pow(Ys, exponent);
    return rgb;
}
info: fname:VSDefault rtype:VertInOut mapping:(null) content:{
    VertInOut vert_out;
    vert_out.pos = mul(float4(vert_in.pos.xyz, 1.0), ViewProj);
    vert_out.uv  = vert_in.uv;
    return vert_out;
}
info: fname:PSDrawBare rtype:float4 mapping:TARGET content:{
    return image.Sample(def_sampler, vert_in.uv);
}
info: fname:PSDrawD65P3 rtype:float4 mapping:TARGET content:{
    float4 rgba = image.Sample(def_sampler, vert_in.uv);
    rgba.rgb = srgb_nonlinear_to_linear(rgba.rgb);
    rgba.rgb = d65p3_to_rec709(rgba.rgb);
    return rgba;
}
info: fname:PSDrawOpaque rtype:float4 mapping:TARGET content:{
    return float4(image.Sample(def_sampler, vert_in.uv).rgb, 1.0);
}
info: fname:PSDrawSrgbDecompress rtype:float4 mapping:TARGET content:{
    float4 rgba = image.Sample(def_sampler, vert_in.uv);
    rgba.rgb = srgb_nonlinear_to_linear(rgba.rgb);
    return rgba;
}
info: ======params =======
info: fname:ViewProj type:float4x4
info: fname:image type:texture_rect
info: ======structs =======
info: fname:VertInOut
info: ======samplers =======
info: fname:def_sampler
info: ======techniques =======
info: fname:Draw
info: fname:DrawD65P3
info: fname:DrawOpaque
info: fname:DrawSrgbDecompress
info: ======files =======
info: ======tokens =======
info: ======techniques =======
info: tname:Draw
info: tname:(null)
info: tname:DrawD65P3
info: tname:(null)
info: tname:DrawOpaque
info: tname:(null)
info: tname:DrawSrgbDecompress
info: tname:(null)
info: ======params =======
info: tname:ViewProj
info: tname:image
info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform mat4x4 ViewProj;

in vec4 _input_attrib0;
in vec2 _input_attrib1;

out vec2 _vertex_shader_attrib0;

out gl_PerVertex {
    vec4 gl_Position;
};

struct VertInOut {
    vec4 pos;
    vec2 uv;
};

VertInOut VSDefault(VertInOut vert_in)
{
    VertInOut vert_out;
    vert_out.pos = ((vec4(vert_in.pos.xyz, 1.0)) * (ViewProj));
    vert_out.uv  = vert_in.uv;
    return vert_out;
}

VertInOut _main_wrap(VertInOut vert_in)
{
    return VSDefault(vert_in);
}

void main(void)
{
    VertInOut vert_in;
    VertInOut outputval;

    vert_in.pos = _input_attrib0;
    vert_in.uv = _input_attrib1;

    outputval = _main_wrap(vert_in);

    gl_Position = outputval.pos;
    _vertex_shader_attrib0 = outputval.uv;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform sampler2D image;

in vec2 _vertex_shader_attrib0;

out vec4 _pixel_shader_attrib0;

struct VertInOut {
    vec4 pos;
    vec2 uv;
};

vec4 PSDraw(VertInOut vert_in)
{
    return vec4(texture(image, vert_in.uv).rgb, 1.0);
}

vec4 _main_wrap(VertInOut vert_in)
{
    return PSDraw(vert_in);
}

void main(void)
{
    VertInOut vert_in;
    vert_in.pos = gl_FragCoord;
    vert_in.uv = _vertex_shader_attrib0;

    _pixel_shader_attrib0 = _main_wrap(vert_in);
}

info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform mat4x4 ViewProj;

in vec4 _input_attrib0;
in vec2 _input_attrib1;

out vec2 _vertex_shader_attrib0;

out gl_PerVertex {
    vec4 gl_Position;
};

struct VertInOut {
    vec4 pos;
    vec2 uv;
};

VertInOut VSDefault(VertInOut vert_in)
{
    VertInOut vert_out;
    vert_out.pos = ((vec4(vert_in.pos.xyz, 1.0)) * (ViewProj));
    vert_out.uv  = vert_in.uv;
    return vert_out;
}

VertInOut _main_wrap(VertInOut vert_in)
{
    return VSDefault(vert_in);
}

void main(void)
{
    VertInOut vert_in;
    VertInOut outputval;

    vert_in.pos = _input_attrib0;
    vert_in.uv = _input_attrib1;

    outputval = _main_wrap(vert_in);

    gl_Position = outputval.pos;
    _vertex_shader_attrib0 = outputval.uv;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform sampler2D image;

in vec2 _vertex_shader_attrib0;

out vec4 _pixel_shader_attrib0;

struct VertInOut {
    vec4 pos;
    vec2 uv;
};

float srgb_nonlinear_to_linear_channel(float u)
{
    return (u <= 0.04045) ? (u / 12.92) : pow((u + 0.055) / 1.055, 2.4);
}

vec3 srgb_nonlinear_to_linear(vec3 v)
{
    return vec3(srgb_nonlinear_to_linear_channel(v.r), srgb_nonlinear_to_linear_channel(v.g), srgb_nonlinear_to_linear_channel(v.b));
}

vec4 PSDrawSrgbDecompress(VertInOut vert_in)
{
    vec3 rgb = texture(image, vert_in.uv).rgb;
    rgb = srgb_nonlinear_to_linear(rgb);
    return vec4(rgb, 1.0);
}

vec4 _main_wrap(VertInOut vert_in)
{
    return PSDrawSrgbDecompress(vert_in);
}

void main(void)
{
    VertInOut vert_in;
    vert_in.pos = gl_FragCoord;
    vert_in.uv = _vertex_shader_attrib0;

    _pixel_shader_attrib0 = _main_wrap(vert_in);
}

info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform mat4x4 ViewProj;

in vec4 _input_attrib0;
in vec2 _input_attrib1;

out vec2 _vertex_shader_attrib0;

out gl_PerVertex {
    vec4 gl_Position;
};

struct VertInOut {
    vec4 pos;
    vec2 uv;
};

VertInOut VSDefault(VertInOut vert_in)
{
    VertInOut vert_out;
    vert_out.pos = ((vec4(vert_in.pos.xyz, 1.0)) * (ViewProj));
    vert_out.uv  = vert_in.uv;
    return vert_out;
}

VertInOut _main_wrap(VertInOut vert_in)
{
    return VSDefault(vert_in);
}

void main(void)
{
    VertInOut vert_in;
    VertInOut outputval;

    vert_in.pos = _input_attrib0;
    vert_in.uv = _input_attrib1;

    outputval = _main_wrap(vert_in);

    gl_Position = outputval.pos;
    _vertex_shader_attrib0 = outputval.uv;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform sampler2D image;
uniform float multiplier;

in vec2 _vertex_shader_attrib0;

out vec4 _pixel_shader_attrib0;

struct VertInOut {
    vec4 pos;
    vec2 uv;
};

float srgb_nonlinear_to_linear_channel(float u)
{
    return (u <= 0.04045) ? (u / 12.92) : pow((u + 0.055) / 1.055, 2.4);
}

vec3 srgb_nonlinear_to_linear(vec3 v)
{
    return vec3(srgb_nonlinear_to_linear_channel(v.r), srgb_nonlinear_to_linear_channel(v.g), srgb_nonlinear_to_linear_channel(v.b));
}

vec4 PSDrawSrgbDecompressMultiply(VertInOut vert_in)
{
    vec3 rgb = texture(image, vert_in.uv).rgb;
    rgb = srgb_nonlinear_to_linear(rgb);
    rgb *= multiplier;
    return vec4(rgb, 1.0);
}

vec4 _main_wrap(VertInOut vert_in)
{
    return PSDrawSrgbDecompressMultiply(vert_in);
}

void main(void)
{
    VertInOut vert_in;
    vert_in.pos = gl_FragCoord;
    vert_in.uv = _vertex_shader_attrib0;

    _pixel_shader_attrib0 = _main_wrap(vert_in);
}

info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform mat4x4 ViewProj;

in vec4 _input_attrib0;
in vec2 _input_attrib1;

out vec2 _vertex_shader_attrib0;

out gl_PerVertex {
    vec4 gl_Position;
};

struct VertInOut {
    vec4 pos;
    vec2 uv;
};

VertInOut VSDefault(VertInOut vert_in)
{
    VertInOut vert_out;
    vert_out.pos = ((vec4(vert_in.pos.xyz, 1.0)) * (ViewProj));
    vert_out.uv  = vert_in.uv;
    return vert_out;
}

VertInOut _main_wrap(VertInOut vert_in)
{
    return VSDefault(vert_in);
}

void main(void)
{
    VertInOut vert_in;
    VertInOut outputval;

    vert_in.pos = _input_attrib0;
    vert_in.uv = _input_attrib1;

    outputval = _main_wrap(vert_in);

    gl_Position = outputval.pos;
    _vertex_shader_attrib0 = outputval.uv;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform sampler2D image;
uniform float multiplier;

in vec2 _vertex_shader_attrib0;

out vec4 _pixel_shader_attrib0;

struct VertInOut {
    vec4 pos;
    vec2 uv;
};

vec4 PSDrawMultiply(VertInOut vert_in)
{
    vec3 rgb = texture(image, vert_in.uv).rgb;
    rgb *= multiplier;
    return vec4(rgb, 1.0);
}

vec4 _main_wrap(VertInOut vert_in)
{
    return PSDrawMultiply(vert_in);
}

void main(void)
{
    VertInOut vert_in;
    vert_in.pos = gl_FragCoord;
    vert_in.uv = _vertex_shader_attrib0;

    _pixel_shader_attrib0 = _main_wrap(vert_in);
}

info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform mat4x4 ViewProj;

in vec4 _input_attrib0;
in vec2 _input_attrib1;

out vec2 _vertex_shader_attrib0;

out gl_PerVertex {
    vec4 gl_Position;
};

struct VertInOut {
    vec4 pos;
    vec2 uv;
};

VertInOut VSDefault(VertInOut vert_in)
{
    VertInOut vert_out;
    vert_out.pos = ((vec4(vert_in.pos.xyz, 1.0)) * (ViewProj));
    vert_out.uv  = vert_in.uv;
    return vert_out;
}

VertInOut _main_wrap(VertInOut vert_in)
{
    return VSDefault(vert_in);
}

void main(void)
{
    VertInOut vert_in;
    VertInOut outputval;

    vert_in.pos = _input_attrib0;
    vert_in.uv = _input_attrib1;

    outputval = _main_wrap(vert_in);

    gl_Position = outputval.pos;
    _vertex_shader_attrib0 = outputval.uv;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform sampler2D image;

in vec2 _vertex_shader_attrib0;

out vec4 _pixel_shader_attrib0;

struct VertInOut {
    vec4 pos;
    vec2 uv;
};

vec3 rec709_to_rec2020(vec3 v)
{
    float r = dot(v, vec3(0.62740389593469903, 0.32928303837788370, 0.043313065687417225));
    float g = dot(v, vec3(0.069097289358232075, 0.91954039507545871, 0.011362315566309178));
    float b = dot(v, vec3(0.016391438875150280, 0.088013307877225749, 0.89559525324762401));
    return vec3(r, g, b);
}

float srgb_nonlinear_to_linear_channel(float u)
{
    return (u <= 0.04045) ? (u / 12.92) : pow((u + 0.055) / 1.055, 2.4);
}

vec3 srgb_nonlinear_to_linear(vec3 v)
{
    return vec3(srgb_nonlinear_to_linear_channel(v.r), srgb_nonlinear_to_linear_channel(v.g), srgb_nonlinear_to_linear_channel(v.b));
}

vec3 reinhard(vec3 rgb)
{
    rgb /= rgb + vec3(1., 1., 1.);
    rgb = pow(rgb, vec3(1. / 2.4, 1. / 2.4, 1. / 2.4));
    rgb = srgb_nonlinear_to_linear(rgb);
    return rgb;
}

vec3 rec2020_to_rec709(vec3 v)
{
    float r = dot(v, vec3(1.6604910021084345, -0.58764113878854951, -0.072849863319884883));
    float g = dot(v, vec3(-0.12455047452159074, 1.1328998971259603, -0.0083494226043694768));
    float b = dot(v, vec3(-0.018150763354905303, -0.10057889800800739, 1.1187296613629127));
    return vec3(r, g, b);
}

vec4 PSDrawTonemap(VertInOut vert_in)
{
    vec3 rgb = texture(image, vert_in.uv).rgb;
    rgb = rec709_to_rec2020(rgb);
    rgb = reinhard(rgb);
    rgb = rec2020_to_rec709(rgb);
    return vec4(rgb, 1.0);
}

vec4 _main_wrap(VertInOut vert_in)
{
    return PSDrawTonemap(vert_in);
}

void main(void)
{
    VertInOut vert_in;
    vert_in.pos = gl_FragCoord;
    vert_in.uv = _vertex_shader_attrib0;

    _pixel_shader_attrib0 = _main_wrap(vert_in);
}

info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform mat4x4 ViewProj;

in vec4 _input_attrib0;
in vec2 _input_attrib1;

out vec2 _vertex_shader_attrib0;

out gl_PerVertex {
    vec4 gl_Position;
};

struct VertInOut {
    vec4 pos;
    vec2 uv;
};

VertInOut VSDefault(VertInOut vert_in)
{
    VertInOut vert_out;
    vert_out.pos = ((vec4(vert_in.pos.xyz, 1.0)) * (ViewProj));
    vert_out.uv  = vert_in.uv;
    return vert_out;
}

VertInOut _main_wrap(VertInOut vert_in)
{
    return VSDefault(vert_in);
}

void main(void)
{
    VertInOut vert_in;
    VertInOut outputval;

    vert_in.pos = _input_attrib0;
    vert_in.uv = _input_attrib1;

    outputval = _main_wrap(vert_in);

    gl_Position = outputval.pos;
    _vertex_shader_attrib0 = outputval.uv;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform sampler2D image;
uniform float multiplier;

in vec2 _vertex_shader_attrib0;

out vec4 _pixel_shader_attrib0;

struct VertInOut {
    vec4 pos;
    vec2 uv;
};

vec3 rec709_to_rec2020(vec3 v)
{
    float r = dot(v, vec3(0.62740389593469903, 0.32928303837788370, 0.043313065687417225));
    float g = dot(v, vec3(0.069097289358232075, 0.91954039507545871, 0.011362315566309178));
    float b = dot(v, vec3(0.016391438875150280, 0.088013307877225749, 0.89559525324762401));
    return vec3(r, g, b);
}

float srgb_nonlinear_to_linear_channel(float u)
{
    return (u <= 0.04045) ? (u / 12.92) : pow((u + 0.055) / 1.055, 2.4);
}

vec3 srgb_nonlinear_to_linear(vec3 v)
{
    return vec3(srgb_nonlinear_to_linear_channel(v.r), srgb_nonlinear_to_linear_channel(v.g), srgb_nonlinear_to_linear_channel(v.b));
}

vec3 reinhard(vec3 rgb)
{
    rgb /= rgb + vec3(1., 1., 1.);
    rgb = pow(rgb, vec3(1. / 2.4, 1. / 2.4, 1. / 2.4));
    rgb = srgb_nonlinear_to_linear(rgb);
    return rgb;
}

vec3 rec2020_to_rec709(vec3 v)
{
    float r = dot(v, vec3(1.6604910021084345, -0.58764113878854951, -0.072849863319884883));
    float g = dot(v, vec3(-0.12455047452159074, 1.1328998971259603, -0.0083494226043694768));
    float b = dot(v, vec3(-0.018150763354905303, -0.10057889800800739, 1.1187296613629127));
    return vec3(r, g, b);
}

vec4 PSDrawMultiplyTonemap(VertInOut vert_in)
{
    vec3 rgb = texture(image, vert_in.uv).rgb;
    rgb *= multiplier;
    rgb = rec709_to_rec2020(rgb);
    rgb = reinhard(rgb);
    rgb = rec2020_to_rec709(rgb);
    return vec4(rgb, 1.0);
}

vec4 _main_wrap(VertInOut vert_in)
{
    return PSDrawMultiplyTonemap(vert_in);
}

void main(void)
{
    VertInOut vert_in;
    vert_in.pos = gl_FragCoord;
    vert_in.uv = _vertex_shader_attrib0;

    _pixel_shader_attrib0 = _main_wrap(vert_in);
}

info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform mat4x4 ViewProj;

in vec4 _input_attrib0;
in vec2 _input_attrib1;

out vec2 _vertex_shader_attrib0;

out gl_PerVertex {
    vec4 gl_Position;
};

struct VertInOut {
    vec4 pos;
    vec2 uv;
};

VertInOut VSDefault(VertInOut vert_in)
{
    VertInOut vert_out;
    vert_out.pos = ((vec4(vert_in.pos.xyz, 1.0)) * (ViewProj));
    vert_out.uv  = vert_in.uv;
    return vert_out;
}

VertInOut _main_wrap(VertInOut vert_in)
{
    return VSDefault(vert_in);
}

void main(void)
{
    VertInOut vert_in;
    VertInOut outputval;

    vert_in.pos = _input_attrib0;
    vert_in.uv = _input_attrib1;

    outputval = _main_wrap(vert_in);

    gl_Position = outputval.pos;
    _vertex_shader_attrib0 = outputval.uv;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform sampler2D image;
uniform float multiplier;

in vec2 _vertex_shader_attrib0;

out vec4 _pixel_shader_attrib0;

struct VertInOut {
    vec4 pos;
    vec2 uv;
};

float st2084_to_linear_channel(float u)
{
    float c = pow(abs(u), 1. / 78.84375);
    return pow(abs(max(c - 0.8359375, 0.) / (18.8515625 - 18.6875 * c)), 1. / 0.1593017578);
}

vec3 st2084_to_linear(vec3 rgb)
{
    return vec3(st2084_to_linear_channel(rgb.r), st2084_to_linear_channel(rgb.g), st2084_to_linear_channel(rgb.b));
}

vec3 rec2020_to_rec709(vec3 v)
{
    float r = dot(v, vec3(1.6604910021084345, -0.58764113878854951, -0.072849863319884883));
    float g = dot(v, vec3(-0.12455047452159074, 1.1328998971259603, -0.0083494226043694768));
    float b = dot(v, vec3(-0.018150763354905303, -0.10057889800800739, 1.1187296613629127));
    return vec3(r, g, b);
}

vec4 PSDrawPQ(VertInOut vert_in)
{
    vec3 rgb = texture(image, vert_in.uv).rgb;
    rgb = st2084_to_linear(rgb) * multiplier;
    rgb = rec2020_to_rec709(rgb);
    return vec4(rgb, 1.0);
}

vec4 _main_wrap(VertInOut vert_in)
{
    return PSDrawPQ(vert_in);
}

void main(void)
{
    VertInOut vert_in;
    vert_in.pos = gl_FragCoord;
    vert_in.uv = _vertex_shader_attrib0;

    _pixel_shader_attrib0 = _main_wrap(vert_in);
}

info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform mat4x4 ViewProj;

in vec4 _input_attrib0;
in vec2 _input_attrib1;

out vec2 _vertex_shader_attrib0;

out gl_PerVertex {
    vec4 gl_Position;
};

struct VertInOut {
    vec4 pos;
    vec2 uv;
};

VertInOut VSDefault(VertInOut vert_in)
{
    VertInOut vert_out;
    vert_out.pos = ((vec4(vert_in.pos.xyz, 1.0)) * (ViewProj));
    vert_out.uv  = vert_in.uv;
    return vert_out;
}

VertInOut _main_wrap(VertInOut vert_in)
{
    return VSDefault(vert_in);
}

void main(void)
{
    VertInOut vert_in;
    VertInOut outputval;

    vert_in.pos = _input_attrib0;
    vert_in.uv = _input_attrib1;

    outputval = _main_wrap(vert_in);

    gl_Position = outputval.pos;
    _vertex_shader_attrib0 = outputval.uv;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform sampler2D image;
uniform float multiplier;

in vec2 _vertex_shader_attrib0;

out vec4 _pixel_shader_attrib0;

struct VertInOut {
    vec4 pos;
    vec2 uv;
};

float st2084_to_linear_channel(float u)
{
    float c = pow(abs(u), 1. / 78.84375);
    return pow(abs(max(c - 0.8359375, 0.) / (18.8515625 - 18.6875 * c)), 1. / 0.1593017578);
}

vec3 st2084_to_linear(vec3 rgb)
{
    return vec3(st2084_to_linear_channel(rgb.r), st2084_to_linear_channel(rgb.g), st2084_to_linear_channel(rgb.b));
}

float srgb_nonlinear_to_linear_channel(float u)
{
    return (u <= 0.04045) ? (u / 12.92) : pow((u + 0.055) / 1.055, 2.4);
}

vec3 srgb_nonlinear_to_linear(vec3 v)
{
    return vec3(srgb_nonlinear_to_linear_channel(v.r), srgb_nonlinear_to_linear_channel(v.g), srgb_nonlinear_to_linear_channel(v.b));
}

vec3 reinhard(vec3 rgb)
{
    rgb /= rgb + vec3(1., 1., 1.);
    rgb = pow(rgb, vec3(1. / 2.4, 1. / 2.4, 1. / 2.4));
    rgb = srgb_nonlinear_to_linear(rgb);
    return rgb;
}

vec3 rec2020_to_rec709(vec3 v)
{
    float r = dot(v, vec3(1.6604910021084345, -0.58764113878854951, -0.072849863319884883));
    float g = dot(v, vec3(-0.12455047452159074, 1.1328998971259603, -0.0083494226043694768));
    float b = dot(v, vec3(-0.018150763354905303, -0.10057889800800739, 1.1187296613629127));
    return vec3(r, g, b);
}

vec4 PSDrawTonemapPQ(VertInOut vert_in)
{
    vec3 rgb = texture(image, vert_in.uv).rgb;
    rgb = st2084_to_linear(rgb) * multiplier;
    rgb = reinhard(rgb);
    rgb = rec2020_to_rec709(rgb);
    return vec4(rgb, 1.0);
}

vec4 _main_wrap(VertInOut vert_in)
{
    return PSDrawTonemapPQ(vert_in);
}

void main(void)
{
    VertInOut vert_in;
    vert_in.pos = gl_FragCoord;
    vert_in.uv = _vertex_shader_attrib0;

    _pixel_shader_attrib0 = _main_wrap(vert_in);
}

info: ======funcs =======
info: fname:srgb_linear_to_nonlinear_channel rtype:float mapping:(null) content:{
    return (u <= 0.0031308) ? (12.92 * u) : ((1.055 * pow(u, 1. / 2.4)) - 0.055);
}
info: fname:srgb_linear_to_nonlinear rtype:float3 mapping:(null) content:{
    return float3(srgb_linear_to_nonlinear_channel(v.r), srgb_linear_to_nonlinear_channel(v.g), srgb_linear_to_nonlinear_channel(v.b));
}
info: fname:srgb_nonlinear_to_linear_channel rtype:float mapping:(null) content:{
    return (u <= 0.04045) ? (u / 12.92) : pow((u + 0.055) / 1.055, 2.4);
}
info: fname:srgb_nonlinear_to_linear rtype:float3 mapping:(null) content:{
    return float3(srgb_nonlinear_to_linear_channel(v.r), srgb_nonlinear_to_linear_channel(v.g), srgb_nonlinear_to_linear_channel(v.b));
}
info: fname:rec709_to_rec2020 rtype:float3 mapping:(null) content:{
    float r = dot(v, float3(0.62740389593469903, 0.32928303837788370, 0.043313065687417225));
    float g = dot(v, float3(0.069097289358232075, 0.91954039507545871, 0.011362315566309178));
    float b = dot(v, float3(0.016391438875150280, 0.088013307877225749, 0.89559525324762401));
    return float3(r, g, b);
}
info: fname:d65p3_to_rec709 rtype:float3 mapping:(null) content:{
    float r = dot(v, float3(1.2249401762805598, -0.22494017628055996, 0.));
    float g = dot(v, float3(-0.042056954709688163, 1.0420569547096881, 0.));
    float b = dot(v, float3(-0.019637554590334432, -0.078636045550631889, 1.0982736001409663));
    return float3(r, g, b);
}
info: fname:rec2020_to_rec709 rtype:float3 mapping:(null) content:{
    float r = dot(v, float3(1.6604910021084345, -0.58764113878854951, -0.072849863319884883));
    float g = dot(v, float3(-0.12455047452159074, 1.1328998971259603, -0.0083494226043694768));
    float b = dot(v, float3(-0.018150763354905303, -0.10057889800800739, 1.1187296613629127));
    return float3(r, g, b);
}
info: fname:reinhard rtype:float3 mapping:(null) content:{
    rgb /= rgb + float3(1., 1., 1.);
    rgb = pow(rgb, float3(1. / 2.4, 1. / 2.4, 1. / 2.4));
    rgb = srgb_nonlinear_to_linear(rgb);
    return rgb;
}
info: fname:linear_to_st2084_channel rtype:float mapping:(null) content:{
    float c = pow(abs(x), 0.1593017578);
    return pow((0.8359375 + 18.8515625 * c) / (1. + 18.6875 * c), 78.84375);
}
info: fname:linear_to_st2084 rtype:float3 mapping:(null) content:{
    return float3(linear_to_st2084_channel(rgb.r), linear_to_st2084_channel(rgb.g), linear_to_st2084_channel(rgb.b));
}
info: fname:st2084_to_linear_channel rtype:float mapping:(null) content:{
    float c = pow(abs(u), 1. / 78.84375);
    return pow(abs(max(c - 0.8359375, 0.) / (18.8515625 - 18.6875 * c)), 1. / 0.1593017578);
}
info: fname:st2084_to_linear rtype:float3 mapping:(null) content:{
    return float3(st2084_to_linear_channel(rgb.r), st2084_to_linear_channel(rgb.g), st2084_to_linear_channel(rgb.b));
}
info: fname:eetf_0_Lmax rtype:float mapping:(null) content:{
    float Lw_pq = linear_to_st2084_channel(Lw / 10000.);
    float E1 = saturate(maxRGB1_pq / Lw_pq);
    float maxLum = linear_to_st2084_channel(Lmax / 10000.) / Lw_pq;
    float KS = (1.5 * maxLum) - 0.5;
    float E2 = E1;
    if (E1 > KS)
    {
        float T = (E1 - KS) / (1. - KS);
        float Tsquared = T * T;
        float Tcubed = Tsquared * T;
        float P = (2. * Tcubed - 3. * Tsquared + 1.) * KS + (Tcubed - 2. * Tsquared + T) * (1. - KS) + (-2. * Tcubed + 3. * Tsquared) * maxLum;
        E2 = P;
    }
    float E3 = E2;
    float E4 = E3 * Lw_pq;
    return E4;
}
info: fname:maxRGB_eetf_internal rtype:float3 mapping:(null) content:{
    float maxRGB2_pq = eetf_0_Lmax(maxRGB1_pq, Lw, Lmax);
    float maxRGB2_linear = st2084_to_linear_channel(maxRGB2_pq);

     
    maxRGB1_linear = max(6.10352e-5, maxRGB1_linear);

    rgb_linear *= maxRGB2_linear / maxRGB1_linear;
    return rgb_linear;
}
info: fname:maxRGB_eetf_pq_to_linear rtype:float3 mapping:(null) content:{
    float3 rgb_linear = st2084_to_linear(rgb_pq);
    float maxRGB1_linear = max(max(rgb_linear.r, rgb_linear.g), rgb_linear.b);
    float maxRGB1_pq = max(max(rgb_pq.r, rgb_pq.g), rgb_pq.b);
    return maxRGB_eetf_internal(rgb_linear, maxRGB1_linear, maxRGB1_pq, Lw, Lmax);
}
info: fname:maxRGB_eetf_linear_to_linear rtype:float3 mapping:(null) content:{
    float maxRGB1_linear = max(max(rgb_linear.r, rgb_linear.g), rgb_linear.b);
    float maxRGB1_pq = linear_to_st2084_channel(maxRGB1_linear);
    return maxRGB_eetf_internal(rgb_linear, maxRGB1_linear, maxRGB1_pq, Lw, Lmax);
}
info: fname:st2084_to_linear_eetf rtype:float3 mapping:(null) content:{
    return (Lw > Lmax) ? maxRGB_eetf_pq_to_linear(rgb, Lw, Lmax) : st2084_to_linear(rgb);
}
info: fname:linear_to_hlg_channel rtype:float mapping:(null) content:{
    float ln2_i = 1. / log(2.);
    float m = 0.17883277 / ln2_i;
    return (u <= (1. / 12.)) ? sqrt(3. * u) : ((log2((12. * u) - 0.28466892) * m) + 0.55991073);
}
info: fname:linear_to_hlg rtype:float3 mapping:(null) content:{
    rgb = saturate(rgb);

    if (Lw > 1000.)
    {
        rgb = maxRGB_eetf_linear_to_linear(rgb, Lw, 1000.);
        rgb *= 10000. / Lw;
    }
    else
    {
        rgb *= 10.;
    }

    float Yd = dot(rgb, float3(0.2627, 0.678, 0.0593));

     
    Yd = max(6.10352e-5, Yd);

    rgb *= pow(Yd, -1. / 6.);
    return float3(linear_to_hlg_channel(rgb.r), linear_to_hlg_channel(rgb.g), linear_to_hlg_channel(rgb.b));
}
info: fname:hlg_to_linear_channel rtype:float mapping:(null) content:{
    float ln2_i = 1. / log(2.);
    float m = ln2_i / 0.17883277;
    float a = -ln2_i * 0.55991073 / 0.17883277;
    return (u <= 0.5) ? ((u * u) / 3.) : ((exp2(u * m + a) + 0.28466892) / 12.);
}
info: fname:hlg_to_linear rtype:float3 mapping:(null) content:{
    float3 rgb = float3(hlg_to_linear_channel(v.r), hlg_to_linear_channel(v.g), hlg_to_linear_channel(v.b));
    float Ys = dot(rgb, float3(0.2627, 0.678, 0.0593));
    rgb *= pow(Ys, exponent);
    return rgb;
}
info: fname:VSDefault rtype:VertInOut mapping:(null) content:{
    VertInOut vert_out;
    vert_out.pos = mul(float4(vert_in.pos.xyz, 1.0), ViewProj);
    vert_out.uv  = vert_in.uv;
    return vert_out;
}
info: fname:PSDraw rtype:float4 mapping:TARGET content:{
    return float4(image.Sample(def_sampler, vert_in.uv).rgb, 1.0);
}
info: fname:PSDrawSrgbDecompress rtype:float4 mapping:TARGET content:{
    float3 rgb = image.Sample(def_sampler, vert_in.uv).rgb;
    rgb = srgb_nonlinear_to_linear(rgb);
    return float4(rgb, 1.0);
}
info: fname:PSDrawSrgbDecompressMultiply rtype:float4 mapping:TARGET content:{
    float3 rgb = image.Sample(def_sampler, vert_in.uv).rgb;
    rgb = srgb_nonlinear_to_linear(rgb);
    rgb *= multiplier;
    return float4(rgb, 1.0);
}
info: fname:PSDrawMultiply rtype:float4 mapping:TARGET content:{
    float3 rgb = image.Sample(def_sampler, vert_in.uv).rgb;
    rgb *= multiplier;
    return float4(rgb, 1.0);
}
info: fname:PSDrawTonemap rtype:float4 mapping:TARGET content:{
    float3 rgb = image.Sample(def_sampler, vert_in.uv).rgb;
    rgb = rec709_to_rec2020(rgb);
    rgb = reinhard(rgb);
    rgb = rec2020_to_rec709(rgb);
    return float4(rgb, 1.0);
}
info: fname:PSDrawMultiplyTonemap rtype:float4 mapping:TARGET content:{
    float3 rgb = image.Sample(def_sampler, vert_in.uv).rgb;
    rgb *= multiplier;
    rgb = rec709_to_rec2020(rgb);
    rgb = reinhard(rgb);
    rgb = rec2020_to_rec709(rgb);
    return float4(rgb, 1.0);
}
info: fname:PSDrawPQ rtype:float4 mapping:TARGET content:{
    float3 rgb = image.Sample(def_sampler, vert_in.uv).rgb;
    rgb = st2084_to_linear(rgb) * multiplier;
    rgb = rec2020_to_rec709(rgb);
    return float4(rgb, 1.0);
}
info: fname:PSDrawTonemapPQ rtype:float4 mapping:TARGET content:{
    float3 rgb = image.Sample(def_sampler, vert_in.uv).rgb;
    rgb = st2084_to_linear(rgb) * multiplier;
    rgb = reinhard(rgb);
    rgb = rec2020_to_rec709(rgb);
    return float4(rgb, 1.0);
}
info: ======params =======
info: fname:ViewProj type:float4x4
info: fname:image type:texture2d
info: fname:multiplier type:float
info: ======structs =======
info: fname:VertInOut
info: ======samplers =======
info: fname:def_sampler
info: ======techniques =======
info: fname:Draw
info: fname:DrawSrgbDecompress
info: fname:DrawSrgbDecompressMultiply
info: fname:DrawMultiply
info: fname:DrawTonemap
info: fname:DrawMultiplyTonemap
info: fname:DrawPQ
info: fname:DrawTonemapPQ
info: ======files =======
info: ======tokens =======
info: ======techniques =======
info: tname:Draw
info: tname:(null)
info: tname:DrawSrgbDecompress
info: tname:(null)
info: tname:DrawSrgbDecompressMultiply
info: tname:(null)
info: tname:DrawMultiply
info: tname:(null)
info: tname:DrawTonemap
info: tname:(null)
info: tname:DrawMultiplyTonemap
info: tname:(null)
info: tname:DrawPQ
info: tname:(null)
info: tname:DrawTonemapPQ
info: tname:(null)
info: ======params =======
info: tname:ViewProj
info: tname:image
info: tname:multiplier
info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform mat4x4 ViewProj;

in vec4 _input_attrib0;


out gl_PerVertex {
    vec4 gl_Position;
};

struct SolidVertInOut {
    vec4 pos;
};

SolidVertInOut VSSolid(SolidVertInOut vert_in)
{
    SolidVertInOut vert_out;
    vert_out.pos = ((vec4(vert_in.pos.xyz, 1.0)) * (ViewProj));
    return vert_out;
}

SolidVertInOut _main_wrap(SolidVertInOut vert_in)
{
    return VSSolid(vert_in);
}

void main(void)
{
    SolidVertInOut vert_in;
    SolidVertInOut outputval;

    vert_in.pos = _input_attrib0;

    outputval = _main_wrap(vert_in);

    gl_Position = outputval.pos;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform vec4 color;


out vec4 _pixel_shader_attrib0;

struct SolidVertInOut {
    vec4 pos;
};

vec4 PSSolid(SolidVertInOut vert_in)
{
    return color;
}

vec4 _main_wrap(SolidVertInOut vert_in)
{
    return PSSolid(vert_in);
}

void main(void)
{
    SolidVertInOut vert_in;
    vert_in.pos = gl_FragCoord;

    _pixel_shader_attrib0 = _main_wrap(vert_in);
}

info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform mat4x4 ViewProj;
uniform vec4 color;

in vec4 _input_attrib0;
in vec4 _input_attrib1;

out vec4 _vertex_shader_attrib0;

out gl_PerVertex {
    vec4 gl_Position;
};

struct SolidColoredVertInOut {
    vec4 pos;
    vec4 color;
};

SolidColoredVertInOut VSSolidColored(SolidColoredVertInOut vert_in)
{
    SolidColoredVertInOut vert_out;
    vert_out.pos   = ((vec4(vert_in.pos.xyz, 1.0)) * (ViewProj));
    vert_out.color = vert_in.color;
    return vert_out;
}

SolidColoredVertInOut _main_wrap(SolidColoredVertInOut vert_in)
{
    return VSSolidColored(vert_in);
}

void main(void)
{
    SolidColoredVertInOut vert_in;
    SolidColoredVertInOut outputval;

    vert_in.pos = _input_attrib0;
    vert_in.color = _input_attrib1;

    outputval = _main_wrap(vert_in);

    gl_Position = outputval.pos;
    _vertex_shader_attrib0 = outputval.color;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform vec4 color;

in vec4 _vertex_shader_attrib0;

out vec4 _pixel_shader_attrib0;

struct SolidColoredVertInOut {
    vec4 pos;
    vec4 color;
};

vec4 PSSolidColored(SolidColoredVertInOut vert_in)
{
    return vert_in.color * color;
}

vec4 _main_wrap(SolidColoredVertInOut vert_in)
{
    return PSSolidColored(vert_in);
}

void main(void)
{
    SolidColoredVertInOut vert_in;
    vert_in.pos = gl_FragCoord;
    vert_in.color = _vertex_shader_attrib0;

    _pixel_shader_attrib0 = _main_wrap(vert_in);
}

info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform mat4x4 ViewProj;

in vec4 _input_attrib0;


out gl_PerVertex {
    vec4 gl_Position;
};

struct SolidVertInOut {
    vec4 pos;
};

SolidVertInOut VSSolid(SolidVertInOut vert_in)
{
    SolidVertInOut vert_out;
    vert_out.pos = ((vec4(vert_in.pos.xyz, 1.0)) * (ViewProj));
    return vert_out;
}

SolidVertInOut _main_wrap(SolidVertInOut vert_in)
{
    return VSSolid(vert_in);
}

void main(void)
{
    SolidVertInOut vert_in;
    SolidVertInOut outputval;

    vert_in.pos = _input_attrib0;

    outputval = _main_wrap(vert_in);

    gl_Position = outputval.pos;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform vec4 randomvals1;
uniform vec4 randomvals2;
uniform vec4 randomvals3;


out vec4 _pixel_shader_attrib0;

struct SolidVertInOut {
    vec4 pos;
};

float rand(vec4 pos, vec4 rand_vals)
{
    return 0.5 + 0.5 * fract(sin(dot(pos.xy, vec2(rand_vals.x, rand_vals.y))) * rand_vals.z);
}

vec4 PSRandom(SolidVertInOut vert_in)
{
    return vec4(rand(vert_in.pos, randomvals1),
                  rand(vert_in.pos, randomvals2),
                  rand(vert_in.pos, randomvals3),
                  1.0);
}

vec4 _main_wrap(SolidVertInOut vert_in)
{
    return PSRandom(vert_in);
}

void main(void)
{
    SolidVertInOut vert_in;
    vert_in.pos = gl_FragCoord;

    _pixel_shader_attrib0 = _main_wrap(vert_in);
}

info: ======funcs =======
info: fname:VSSolid rtype:SolidVertInOut mapping:(null) content:{
    SolidVertInOut vert_out;
    vert_out.pos = mul(float4(vert_in.pos.xyz, 1.0), ViewProj);
    return vert_out;
}
info: fname:PSSolid rtype:float4 mapping:TARGET content:{
    return color;
}
info: fname:rand rtype:float mapping:(null) content:{
    return 0.5 + 0.5 * frac(sin(dot(pos.xy, float2(rand_vals.x, rand_vals.y))) * rand_vals.z);
}
info: fname:PSRandom rtype:float4 mapping:TARGET content:{
    return float4(rand(vert_in.pos, randomvals1),
                  rand(vert_in.pos, randomvals2),
                  rand(vert_in.pos, randomvals3),
                  1.0);
}
info: fname:VSSolidColored rtype:SolidColoredVertInOut mapping:(null) content:{
    SolidColoredVertInOut vert_out;
    vert_out.pos   = mul(float4(vert_in.pos.xyz, 1.0), ViewProj);
    vert_out.color = vert_in.color;
    return vert_out;
}
info: fname:PSSolidColored rtype:float4 mapping:TARGET content:{
    return vert_in.color * color;
}
info: ======params =======
info: fname:ViewProj type:float4x4
info: fname:color type:float4
info: fname:randomvals1 type:float4
info: fname:randomvals2 type:float4
info: fname:randomvals3 type:float4
info: ======structs =======
info: fname:SolidVertInOut
info: fname:SolidColoredVertInOut
info: ======samplers =======
info: ======techniques =======
info: fname:Solid
info: fname:SolidColored
info: fname:Random
info: ======files =======
info: ======tokens =======
info: ======techniques =======
info: tname:Solid
info: tname:(null)
info: tname:SolidColored
info: tname:(null)
info: tname:Random
info: tname:(null)
info: ======params =======
info: tname:ViewProj
info: tname:color
info: tname:randomvals1
info: tname:randomvals2
info: tname:randomvals3
info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform mat4x4 ViewProj;
uniform vec2 scale;

in vec4 _input_attrib0;
in vec2 _input_attrib1;

out vec2 _vertex_shader_attrib0;

out gl_PerVertex {
    vec4 gl_Position;
};

struct VertInOut {
    vec4 pos;
    vec2 uv;
};

VertInOut VSDefault(VertInOut vert_in)
{
    VertInOut vert_out;
    vert_out.pos = ((vec4(vert_in.pos.xyz, 1.0)) * (ViewProj));
    vert_out.uv  = vert_in.uv * scale;
    return vert_out;
}

VertInOut _main_wrap(VertInOut vert_in)
{
    return VSDefault(vert_in);
}

void main(void)
{
    VertInOut vert_in;
    VertInOut outputval;

    vert_in.pos = _input_attrib0;
    vert_in.uv = _input_attrib1;

    outputval = _main_wrap(vert_in);

    gl_Position = outputval.pos;
    _vertex_shader_attrib0 = outputval.uv;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform sampler2D image;

in vec2 _vertex_shader_attrib0;

out vec4 _pixel_shader_attrib0;

struct VertInOut {
    vec4 pos;
    vec2 uv;
};

vec4 PSDrawBare(VertInOut vert_in)
{
    return texture(image, vert_in.uv);
}

vec4 _main_wrap(VertInOut vert_in)
{
    return PSDrawBare(vert_in);
}

void main(void)
{
    VertInOut vert_in;
    vert_in.pos = gl_FragCoord;
    vert_in.uv = _vertex_shader_attrib0;

    _pixel_shader_attrib0 = _main_wrap(vert_in);
}

info: ======funcs =======
info: fname:VSDefault rtype:VertInOut mapping:(null) content:{
    VertInOut vert_out;
    vert_out.pos = mul(float4(vert_in.pos.xyz, 1.0), ViewProj);
    vert_out.uv  = vert_in.uv * scale;
    return vert_out;
}
info: fname:PSDrawBare rtype:float4 mapping:TARGET content:{
    return image.Sample(def_sampler, vert_in.uv);
}
info: ======params =======
info: fname:ViewProj type:float4x4
info: fname:image type:texture2d
info: fname:scale type:float2
info: ======structs =======
info: fname:VertInOut
info: ======samplers =======
info: fname:def_sampler
info: ======techniques =======
info: fname:Draw
info: ======files =======
info: ======tokens =======
info: ======techniques =======
info: tname:Draw
info: tname:(null)
info: ======params =======
info: tname:ViewProj
info: tname:image
info: tname:scale
info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}




out gl_PerVertex {
    vec4 gl_Position;
};

struct FragPos {
    vec4 pos;
};

FragPos VSPos(uint id)
{
    float idHigh = float(id >> 1);
    float idLow = float(id & uint(1));

    float x = idHigh * 4.0 - 1.0;
    float y = idLow * 4.0 - 1.0;

    FragPos vert_out;
    vert_out.pos = vec4(x, y, 0.0, 1.0);
    return vert_out;
}

FragPos _main_wrap(uint id)
{
    return VSPos(id);
}

void main(void)
{
    uint id;
    FragPos outputval;

    id = uint(gl_VertexID);

    outputval = _main_wrap(id);

    gl_Position = outputval.pos;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform sampler2D image;
uniform vec4 color_vec0;


out float _pixel_shader_attrib0;

struct FragPos {
    vec4 pos;
};

float PS_Y(FragPos frag_in)
{
    vec3 rgb = obs_load_2d(image, ivec3(frag_in.pos.xy, 0)).rgb;
    float y = dot(color_vec0.xyz, rgb) + color_vec0.w;
    return y;
}

float _main_wrap(FragPos frag_in)
{
    return PS_Y(frag_in);
}

void main(void)
{
    FragPos frag_in;
    frag_in.pos = gl_FragCoord;

    _pixel_shader_attrib0 = _main_wrap(frag_in);
}

info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}




out gl_PerVertex {
    vec4 gl_Position;
};

struct FragPos {
    vec4 pos;
};

FragPos VSPos(uint id)
{
    float idHigh = float(id >> 1);
    float idLow = float(id & uint(1));

    float x = idHigh * 4.0 - 1.0;
    float y = idLow * 4.0 - 1.0;

    FragPos vert_out;
    vert_out.pos = vec4(x, y, 0.0, 1.0);
    return vert_out;
}

FragPos _main_wrap(uint id)
{
    return VSPos(id);
}

void main(void)
{
    uint id;
    FragPos outputval;

    id = uint(gl_VertexID);

    outputval = _main_wrap(id);

    gl_Position = outputval.pos;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform sampler2D image;
uniform vec4 color_vec1;


out float _pixel_shader_attrib0;

struct FragPos {
    vec4 pos;
};

float PS_U(FragPos frag_in)
{
    vec3 rgb = obs_load_2d(image, ivec3(frag_in.pos.xy, 0)).rgb;
    float u = dot(color_vec1.xyz, rgb) + color_vec1.w;
    return u;
}

float _main_wrap(FragPos frag_in)
{
    return PS_U(frag_in);
}

void main(void)
{
    FragPos frag_in;
    frag_in.pos = gl_FragCoord;

    _pixel_shader_attrib0 = _main_wrap(frag_in);
}

info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}




out gl_PerVertex {
    vec4 gl_Position;
};

struct FragPos {
    vec4 pos;
};

FragPos VSPos(uint id)
{
    float idHigh = float(id >> 1);
    float idLow = float(id & uint(1));

    float x = idHigh * 4.0 - 1.0;
    float y = idLow * 4.0 - 1.0;

    FragPos vert_out;
    vert_out.pos = vec4(x, y, 0.0, 1.0);
    return vert_out;
}

FragPos _main_wrap(uint id)
{
    return VSPos(id);
}

void main(void)
{
    uint id;
    FragPos outputval;

    id = uint(gl_VertexID);

    outputval = _main_wrap(id);

    gl_Position = outputval.pos;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform sampler2D image;
uniform vec4 color_vec2;


out float _pixel_shader_attrib0;

struct FragPos {
    vec4 pos;
};

float PS_V(FragPos frag_in)
{
    vec3 rgb = obs_load_2d(image, ivec3(frag_in.pos.xy, 0)).rgb;
    float v = dot(color_vec2.xyz, rgb) + color_vec2.w;
    return v;
}

float _main_wrap(FragPos frag_in)
{
    return PS_V(frag_in);
}

void main(void)
{
    FragPos frag_in;
    frag_in.pos = gl_FragCoord;

    _pixel_shader_attrib0 = _main_wrap(frag_in);
}

info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform float width_i;


out vec3 _vertex_shader_attrib0;

out gl_PerVertex {
    vec4 gl_Position;
};

struct VertTexPosWide {
    vec3 uuv;
    vec4 pos;
};

VertTexPosWide VSTexPos_Left(uint id)
{
    float idHigh = float(id >> 1);
    float idLow = float(id & uint(1));

    float x = idHigh * 4.0 - 1.0;
    float y = idLow * 4.0 - 1.0;

    float u_right = idHigh * 2.0;
    float u_left = u_right - width_i;
    float v = obs_glsl_compile ? (idLow * 2.0) : (1.0 - idLow * 2.0);

    VertTexPosWide vert_out;
    vert_out.uuv = vec3(u_left, u_right, v);
    vert_out.pos = vec4(x, y, 0.0, 1.0);
    return vert_out;
}

VertTexPosWide _main_wrap(uint id)
{
    return VSTexPos_Left(id);
}

void main(void)
{
    uint id;
    VertTexPosWide outputval;

    id = uint(gl_VertexID);

    outputval = _main_wrap(id);

    _vertex_shader_attrib0 = outputval.uuv;
    gl_Position = outputval.pos;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform sampler2D image;
uniform vec4 color_vec1;

in vec3 _vertex_shader_attrib0;

out float _pixel_shader_attrib0;

struct FragTexWide {
    vec3 uuv;
};

float PS_U_Wide(FragTexWide frag_in)
{
    vec3 rgb_left = texture(image, frag_in.uuv.xz).rgb;
    vec3 rgb_right = texture(image, frag_in.uuv.yz).rgb;
    vec3 rgb = (rgb_left + rgb_right) * 0.5;
    float u = dot(color_vec1.xyz, rgb) + color_vec1.w;
    return u;
}

float _main_wrap(FragTexWide frag_in)
{
    return PS_U_Wide(frag_in);
}

void main(void)
{
    FragTexWide frag_in;
    frag_in.uuv = _vertex_shader_attrib0;

    _pixel_shader_attrib0 = _main_wrap(frag_in);
}

info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform float width_i;


out vec3 _vertex_shader_attrib0;

out gl_PerVertex {
    vec4 gl_Position;
};

struct VertTexPosWide {
    vec3 uuv;
    vec4 pos;
};

VertTexPosWide VSTexPos_Left(uint id)
{
    float idHigh = float(id >> 1);
    float idLow = float(id & uint(1));

    float x = idHigh * 4.0 - 1.0;
    float y = idLow * 4.0 - 1.0;

    float u_right = idHigh * 2.0;
    float u_left = u_right - width_i;
    float v = obs_glsl_compile ? (idLow * 2.0) : (1.0 - idLow * 2.0);

    VertTexPosWide vert_out;
    vert_out.uuv = vec3(u_left, u_right, v);
    vert_out.pos = vec4(x, y, 0.0, 1.0);
    return vert_out;
}

VertTexPosWide _main_wrap(uint id)
{
    return VSTexPos_Left(id);
}

void main(void)
{
    uint id;
    VertTexPosWide outputval;

    id = uint(gl_VertexID);

    outputval = _main_wrap(id);

    _vertex_shader_attrib0 = outputval.uuv;
    gl_Position = outputval.pos;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform sampler2D image;
uniform vec4 color_vec2;

in vec3 _vertex_shader_attrib0;

out float _pixel_shader_attrib0;

struct FragTexWide {
    vec3 uuv;
};

float PS_V_Wide(FragTexWide frag_in)
{
    vec3 rgb_left = texture(image, frag_in.uuv.xz).rgb;
    vec3 rgb_right = texture(image, frag_in.uuv.yz).rgb;
    vec3 rgb = (rgb_left + rgb_right) * 0.5;
    float v = dot(color_vec2.xyz, rgb) + color_vec2.w;
    return v;
}

float _main_wrap(FragTexWide frag_in)
{
    return PS_V_Wide(frag_in);
}

void main(void)
{
    FragTexWide frag_in;
    frag_in.uuv = _vertex_shader_attrib0;

    _pixel_shader_attrib0 = _main_wrap(frag_in);
}

info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}




out gl_PerVertex {
    vec4 gl_Position;
};

struct FragPos {
    vec4 pos;
};

FragPos VSPos(uint id)
{
    float idHigh = float(id >> 1);
    float idLow = float(id & uint(1));

    float x = idHigh * 4.0 - 1.0;
    float y = idLow * 4.0 - 1.0;

    FragPos vert_out;
    vert_out.pos = vec4(x, y, 0.0, 1.0);
    return vert_out;
}

FragPos _main_wrap(uint id)
{
    return VSPos(id);
}

void main(void)
{
    uint id;
    FragPos outputval;

    id = uint(gl_VertexID);

    outputval = _main_wrap(id);

    gl_Position = outputval.pos;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform sampler2D image;
uniform vec4 color_vec0;


out float _pixel_shader_attrib0;

struct FragPos {
    vec4 pos;
};

float PS_Y(FragPos frag_in)
{
    vec3 rgb = obs_load_2d(image, ivec3(frag_in.pos.xy, 0)).rgb;
    float y = dot(color_vec0.xyz, rgb) + color_vec0.w;
    return y;
}

float _main_wrap(FragPos frag_in)
{
    return PS_Y(frag_in);
}

void main(void)
{
    FragPos frag_in;
    frag_in.pos = gl_FragCoord;

    _pixel_shader_attrib0 = _main_wrap(frag_in);
}

info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform float width_i;


out vec3 _vertex_shader_attrib0;

out gl_PerVertex {
    vec4 gl_Position;
};

struct VertTexPosWide {
    vec3 uuv;
    vec4 pos;
};

VertTexPosWide VSTexPos_Left(uint id)
{
    float idHigh = float(id >> 1);
    float idLow = float(id & uint(1));

    float x = idHigh * 4.0 - 1.0;
    float y = idLow * 4.0 - 1.0;

    float u_right = idHigh * 2.0;
    float u_left = u_right - width_i;
    float v = obs_glsl_compile ? (idLow * 2.0) : (1.0 - idLow * 2.0);

    VertTexPosWide vert_out;
    vert_out.uuv = vec3(u_left, u_right, v);
    vert_out.pos = vec4(x, y, 0.0, 1.0);
    return vert_out;
}

VertTexPosWide _main_wrap(uint id)
{
    return VSTexPos_Left(id);
}

void main(void)
{
    uint id;
    VertTexPosWide outputval;

    id = uint(gl_VertexID);

    outputval = _main_wrap(id);

    _vertex_shader_attrib0 = outputval.uuv;
    gl_Position = outputval.pos;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform sampler2D image;
uniform vec4 color_vec1;
uniform vec4 color_vec2;

in vec3 _vertex_shader_attrib0;

out vec2 _pixel_shader_attrib0;

struct FragTexWide {
    vec3 uuv;
};

vec2 PS_UV_Wide(FragTexWide frag_in)
{
    vec3 rgb_left = texture(image, frag_in.uuv.xz).rgb;
    vec3 rgb_right = texture(image, frag_in.uuv.yz).rgb;
    vec3 rgb = (rgb_left + rgb_right) * 0.5;
    float u = dot(color_vec1.xyz, rgb) + color_vec1.w;
    float v = dot(color_vec2.xyz, rgb) + color_vec2.w;
    return vec2(u, v);
}

vec2 _main_wrap(FragTexWide frag_in)
{
    return PS_UV_Wide(frag_in);
}

void main(void)
{
    FragTexWide frag_in;
    frag_in.uuv = _vertex_shader_attrib0;

    _pixel_shader_attrib0 = _main_wrap(frag_in);
}

info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}




out gl_PerVertex {
    vec4 gl_Position;
};

struct FragPos {
    vec4 pos;
};

FragPos VSPos(uint id)
{
    float idHigh = float(id >> 1);
    float idLow = float(id & uint(1));

    float x = idHigh * 4.0 - 1.0;
    float y = idLow * 4.0 - 1.0;

    FragPos vert_out;
    vert_out.pos = vec4(x, y, 0.0, 1.0);
    return vert_out;
}

FragPos _main_wrap(uint id)
{
    return VSPos(id);
}

void main(void)
{
    uint id;
    FragPos outputval;

    id = uint(gl_VertexID);

    outputval = _main_wrap(id);

    gl_Position = outputval.pos;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform sampler2D image;
uniform float sdr_white_nits_over_maximum;
uniform vec4 color_vec0;


out float _pixel_shader_attrib0;

struct FragPos {
    vec4 pos;
};

vec3 rec709_to_rec2020(vec3 v)
{
    float r = dot(v, vec3(0.62740389593469903, 0.32928303837788370, 0.043313065687417225));
    float g = dot(v, vec3(0.069097289358232075, 0.91954039507545871, 0.011362315566309178));
    float b = dot(v, vec3(0.016391438875150280, 0.088013307877225749, 0.89559525324762401));
    return vec3(r, g, b);
}

float linear_to_st2084_channel(float x)
{
    float c = pow(abs(x), 0.1593017578);
    return pow((0.8359375 + 18.8515625 * c) / (1. + 18.6875 * c), 78.84375);
}

vec3 linear_to_st2084(vec3 rgb)
{
    return vec3(linear_to_st2084_channel(rgb.r), linear_to_st2084_channel(rgb.g), linear_to_st2084_channel(rgb.b));
}

float PS_I010_PQ_Y_709_2020(FragPos frag_in)
{
    vec3 rgb = obs_load_2d(image, ivec3(frag_in.pos.xy, 0)).rgb * sdr_white_nits_over_maximum;
    rgb = rec709_to_rec2020(rgb);
    rgb = linear_to_st2084(rgb);
    float y = dot(color_vec0.xyz, rgb) + color_vec0.w;
    return y * (1023. / 65535.);
}

float _main_wrap(FragPos frag_in)
{
    return PS_I010_PQ_Y_709_2020(frag_in);
}

void main(void)
{
    FragPos frag_in;
    frag_in.pos = gl_FragCoord;

    _pixel_shader_attrib0 = _main_wrap(frag_in);
}

info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}




out gl_PerVertex {
    vec4 gl_Position;
};

struct FragPos {
    vec4 pos;
};

FragPos VSPos(uint id)
{
    float idHigh = float(id >> 1);
    float idLow = float(id & uint(1));

    float x = idHigh * 4.0 - 1.0;
    float y = idLow * 4.0 - 1.0;

    FragPos vert_out;
    vert_out.pos = vec4(x, y, 0.0, 1.0);
    return vert_out;
}

FragPos _main_wrap(uint id)
{
    return VSPos(id);
}

void main(void)
{
    uint id;
    FragPos outputval;

    id = uint(gl_VertexID);

    outputval = _main_wrap(id);

    gl_Position = outputval.pos;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform sampler2D image;
uniform float sdr_white_nits_over_maximum;
uniform float hdr_lw;
uniform vec4 color_vec0;


out float _pixel_shader_attrib0;

struct FragPos {
    vec4 pos;
};

vec3 rec709_to_rec2020(vec3 v)
{
    float r = dot(v, vec3(0.62740389593469903, 0.32928303837788370, 0.043313065687417225));
    float g = dot(v, vec3(0.069097289358232075, 0.91954039507545871, 0.011362315566309178));
    float b = dot(v, vec3(0.016391438875150280, 0.088013307877225749, 0.89559525324762401));
    return vec3(r, g, b);
}

float linear_to_st2084_channel(float x)
{
    float c = pow(abs(x), 0.1593017578);
    return pow((0.8359375 + 18.8515625 * c) / (1. + 18.6875 * c), 78.84375);
}

float eetf_0_Lmax(float maxRGB1_pq, float Lw, float Lmax)
{
    float Lw_pq = linear_to_st2084_channel(Lw / 10000.);
    float E1 = clamp(maxRGB1_pq / Lw_pq, 0.0, 1.0);
    float maxLum = linear_to_st2084_channel(Lmax / 10000.) / Lw_pq;
    float KS = (1.5 * maxLum) - 0.5;
    float E2 = E1;
    if (E1 > KS)
    {
        float T = (E1 - KS) / (1. - KS);
        float Tsquared = T * T;
        float Tcubed = Tsquared * T;
        float P = (2. * Tcubed - 3. * Tsquared + 1.) * KS + (Tcubed - 2. * Tsquared + T) * (1. - KS) + (-2. * Tcubed + 3. * Tsquared) * maxLum;
        E2 = P;
    }
    float E3 = E2;
    float E4 = E3 * Lw_pq;
    return E4;
}

float st2084_to_linear_channel(float u)
{
    float c = pow(abs(u), 1. / 78.84375);
    return pow(abs(max(c - 0.8359375, 0.) / (18.8515625 - 18.6875 * c)), 1. / 0.1593017578);
}

vec3 maxRGB_eetf_internal(vec3 rgb_linear, float maxRGB1_linear, float maxRGB1_pq, float Lw, float Lmax)
{
    float maxRGB2_pq = eetf_0_Lmax(maxRGB1_pq, Lw, Lmax);
    float maxRGB2_linear = st2084_to_linear_channel(maxRGB2_pq);

     
    maxRGB1_linear = max(6.10352e-5, maxRGB1_linear);

    rgb_linear *= maxRGB2_linear / maxRGB1_linear;
    return rgb_linear;
}

vec3 maxRGB_eetf_linear_to_linear(vec3 rgb_linear, float Lw, float Lmax)
{
    float maxRGB1_linear = max(max(rgb_linear.r, rgb_linear.g), rgb_linear.b);
    float maxRGB1_pq = linear_to_st2084_channel(maxRGB1_linear);
    return maxRGB_eetf_internal(rgb_linear, maxRGB1_linear, maxRGB1_pq, Lw, Lmax);
}

float linear_to_hlg_channel(float u)
{
    float ln2_i = 1. / log(2.);
    float m = 0.17883277 / ln2_i;
    return (u <= (1. / 12.)) ? sqrt(3. * u) : ((log2((12. * u) - 0.28466892) * m) + 0.55991073);
}

vec3 linear_to_hlg(vec3 rgb, float Lw)
{
    rgb = clamp(rgb, 0.0, 1.0);

    if (Lw > 1000.)
    {
        rgb = maxRGB_eetf_linear_to_linear(rgb, Lw, 1000.);
        rgb *= 10000. / Lw;
    }
    else
    {
        rgb *= 10.;
    }

    float Yd = dot(rgb, vec3(0.2627, 0.678, 0.0593));

     
    Yd = max(6.10352e-5, Yd);

    rgb *= pow(Yd, -1. / 6.);
    return vec3(linear_to_hlg_channel(rgb.r), linear_to_hlg_channel(rgb.g), linear_to_hlg_channel(rgb.b));
}

float PS_I010_HLG_Y_709_2020(FragPos frag_in)
{
    vec3 rgb = obs_load_2d(image, ivec3(frag_in.pos.xy, 0)).rgb * sdr_white_nits_over_maximum;
    rgb = rec709_to_rec2020(rgb);
    rgb = linear_to_hlg(rgb, hdr_lw);
    float y = dot(color_vec0.xyz, rgb) + color_vec0.w;
    return y * (1023. / 65535.);
}

float _main_wrap(FragPos frag_in)
{
    return PS_I010_HLG_Y_709_2020(frag_in);
}

void main(void)
{
    FragPos frag_in;
    frag_in.pos = gl_FragCoord;

    _pixel_shader_attrib0 = _main_wrap(frag_in);
}

info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}




out gl_PerVertex {
    vec4 gl_Position;
};

struct FragPos {
    vec4 pos;
};

FragPos VSPos(uint id)
{
    float idHigh = float(id >> 1);
    float idLow = float(id & uint(1));

    float x = idHigh * 4.0 - 1.0;
    float y = idLow * 4.0 - 1.0;

    FragPos vert_out;
    vert_out.pos = vec4(x, y, 0.0, 1.0);
    return vert_out;
}

FragPos _main_wrap(uint id)
{
    return VSPos(id);
}

void main(void)
{
    uint id;
    FragPos outputval;

    id = uint(gl_VertexID);

    outputval = _main_wrap(id);

    gl_Position = outputval.pos;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform sampler2D image;
uniform vec4 color_vec0;


out float _pixel_shader_attrib0;

struct FragPos {
    vec4 pos;
};

float srgb_linear_to_nonlinear_channel(float u)
{
    return (u <= 0.0031308) ? (12.92 * u) : ((1.055 * pow(u, 1. / 2.4)) - 0.055);
}

vec3 srgb_linear_to_nonlinear(vec3 v)
{
    return vec3(srgb_linear_to_nonlinear_channel(v.r), srgb_linear_to_nonlinear_channel(v.g), srgb_linear_to_nonlinear_channel(v.b));
}

float PS_I010_SRGB_Y(FragPos frag_in)
{
    vec3 rgb = obs_load_2d(image, ivec3(frag_in.pos.xy, 0)).rgb;
    rgb = srgb_linear_to_nonlinear(rgb);
    float y = dot(color_vec0.xyz, rgb) + color_vec0.w;
    return y * (1023. / 65535.);
}

float _main_wrap(FragPos frag_in)
{
    return PS_I010_SRGB_Y(frag_in);
}

void main(void)
{
    FragPos frag_in;
    frag_in.pos = gl_FragCoord;

    _pixel_shader_attrib0 = _main_wrap(frag_in);
}

info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform float width_i;
uniform float height_i;


out vec4 _vertex_shader_attrib0;

out gl_PerVertex {
    vec4 gl_Position;
};

struct VertTexPosWideWide {
    vec4 uuvv;
    vec4 pos;
};

VertTexPosWideWide VSTexPos_TopLeft(uint id)
{
    float idHigh = float(id >> 1);
    float idLow = float(id & uint(1));

    float x = idHigh * 4.0 - 1.0;
    float y = idLow * 4.0 - 1.0;

    float u_right = idHigh * 2.0;
    float u_left = u_right - width_i;
    float v_bottom;
    float v_top;
    if (obs_glsl_compile) {
        v_bottom = idLow * 2.0;
        v_top = v_bottom + height_i;
    } else {
        v_bottom = 1.0 - idLow * 2.0;
        v_top = v_bottom - height_i;
    }

    VertTexPosWideWide vert_out;
    vert_out.uuvv = vec4(u_left, u_right, v_top, v_bottom);
    vert_out.pos = vec4(x, y, 0.0, 1.0);
    return vert_out;
}

VertTexPosWideWide _main_wrap(uint id)
{
    return VSTexPos_TopLeft(id);
}

void main(void)
{
    uint id;
    VertTexPosWideWide outputval;

    id = uint(gl_VertexID);

    outputval = _main_wrap(id);

    _vertex_shader_attrib0 = outputval.uuvv;
    gl_Position = outputval.pos;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform sampler2D image;
uniform float sdr_white_nits_over_maximum;
uniform vec4 color_vec1;

in vec4 _vertex_shader_attrib0;

out float _pixel_shader_attrib0;

struct FragTexWideWide {
    vec4 uuvv;
};

vec3 rec709_to_rec2020(vec3 v)
{
    float r = dot(v, vec3(0.62740389593469903, 0.32928303837788370, 0.043313065687417225));
    float g = dot(v, vec3(0.069097289358232075, 0.91954039507545871, 0.011362315566309178));
    float b = dot(v, vec3(0.016391438875150280, 0.088013307877225749, 0.89559525324762401));
    return vec3(r, g, b);
}

float linear_to_st2084_channel(float x)
{
    float c = pow(abs(x), 0.1593017578);
    return pow((0.8359375 + 18.8515625 * c) / (1. + 18.6875 * c), 78.84375);
}

vec3 linear_to_st2084(vec3 rgb)
{
    return vec3(linear_to_st2084_channel(rgb.r), linear_to_st2084_channel(rgb.g), linear_to_st2084_channel(rgb.b));
}

float PS_I010_PQ_U_709_2020_WideWide(FragTexWideWide frag_in)
{
    vec3 rgb_topleft = texture(image, frag_in.uuvv.xz).rgb;
    vec3 rgb_topright = texture(image, frag_in.uuvv.yz).rgb;
    vec3 rgb_bottomleft = texture(image, frag_in.uuvv.xw).rgb;
    vec3 rgb_bottomright = texture(image, frag_in.uuvv.yw).rgb;
    vec3 rgb = (rgb_topleft + rgb_topright + rgb_bottomleft + rgb_bottomright) * (0.25 * sdr_white_nits_over_maximum);
    rgb = rec709_to_rec2020(rgb);
    rgb = linear_to_st2084(rgb);
    float u = dot(color_vec1.xyz, rgb) + color_vec1.w;
    return u * (1023. / 65535.);
}

float _main_wrap(FragTexWideWide frag_in)
{
    return PS_I010_PQ_U_709_2020_WideWide(frag_in);
}

void main(void)
{
    FragTexWideWide frag_in;
    frag_in.uuvv = _vertex_shader_attrib0;

    _pixel_shader_attrib0 = _main_wrap(frag_in);
}

info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform float width_i;
uniform float height_i;


out vec4 _vertex_shader_attrib0;

out gl_PerVertex {
    vec4 gl_Position;
};

struct VertTexPosWideWide {
    vec4 uuvv;
    vec4 pos;
};

VertTexPosWideWide VSTexPos_TopLeft(uint id)
{
    float idHigh = float(id >> 1);
    float idLow = float(id & uint(1));

    float x = idHigh * 4.0 - 1.0;
    float y = idLow * 4.0 - 1.0;

    float u_right = idHigh * 2.0;
    float u_left = u_right - width_i;
    float v_bottom;
    float v_top;
    if (obs_glsl_compile) {
        v_bottom = idLow * 2.0;
        v_top = v_bottom + height_i;
    } else {
        v_bottom = 1.0 - idLow * 2.0;
        v_top = v_bottom - height_i;
    }

    VertTexPosWideWide vert_out;
    vert_out.uuvv = vec4(u_left, u_right, v_top, v_bottom);
    vert_out.pos = vec4(x, y, 0.0, 1.0);
    return vert_out;
}

VertTexPosWideWide _main_wrap(uint id)
{
    return VSTexPos_TopLeft(id);
}

void main(void)
{
    uint id;
    VertTexPosWideWide outputval;

    id = uint(gl_VertexID);

    outputval = _main_wrap(id);

    _vertex_shader_attrib0 = outputval.uuvv;
    gl_Position = outputval.pos;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform sampler2D image;
uniform float sdr_white_nits_over_maximum;
uniform float hdr_lw;
uniform vec4 color_vec1;

in vec4 _vertex_shader_attrib0;

out float _pixel_shader_attrib0;

struct FragTexWideWide {
    vec4 uuvv;
};

vec3 rec709_to_rec2020(vec3 v)
{
    float r = dot(v, vec3(0.62740389593469903, 0.32928303837788370, 0.043313065687417225));
    float g = dot(v, vec3(0.069097289358232075, 0.91954039507545871, 0.011362315566309178));
    float b = dot(v, vec3(0.016391438875150280, 0.088013307877225749, 0.89559525324762401));
    return vec3(r, g, b);
}

float linear_to_st2084_channel(float x)
{
    float c = pow(abs(x), 0.1593017578);
    return pow((0.8359375 + 18.8515625 * c) / (1. + 18.6875 * c), 78.84375);
}

float eetf_0_Lmax(float maxRGB1_pq, float Lw, float Lmax)
{
    float Lw_pq = linear_to_st2084_channel(Lw / 10000.);
    float E1 = clamp(maxRGB1_pq / Lw_pq, 0.0, 1.0);
    float maxLum = linear_to_st2084_channel(Lmax / 10000.) / Lw_pq;
    float KS = (1.5 * maxLum) - 0.5;
    float E2 = E1;
    if (E1 > KS)
    {
        float T = (E1 - KS) / (1. - KS);
        float Tsquared = T * T;
        float Tcubed = Tsquared * T;
        float P = (2. * Tcubed - 3. * Tsquared + 1.) * KS + (Tcubed - 2. * Tsquared + T) * (1. - KS) + (-2. * Tcubed + 3. * Tsquared) * maxLum;
        E2 = P;
    }
    float E3 = E2;
    float E4 = E3 * Lw_pq;
    return E4;
}

float st2084_to_linear_channel(float u)
{
    float c = pow(abs(u), 1. / 78.84375);
    return pow(abs(max(c - 0.8359375, 0.) / (18.8515625 - 18.6875 * c)), 1. / 0.1593017578);
}

vec3 maxRGB_eetf_internal(vec3 rgb_linear, float maxRGB1_linear, float maxRGB1_pq, float Lw, float Lmax)
{
    float maxRGB2_pq = eetf_0_Lmax(maxRGB1_pq, Lw, Lmax);
    float maxRGB2_linear = st2084_to_linear_channel(maxRGB2_pq);

     
    maxRGB1_linear = max(6.10352e-5, maxRGB1_linear);

    rgb_linear *= maxRGB2_linear / maxRGB1_linear;
    return rgb_linear;
}

vec3 maxRGB_eetf_linear_to_linear(vec3 rgb_linear, float Lw, float Lmax)
{
    float maxRGB1_linear = max(max(rgb_linear.r, rgb_linear.g), rgb_linear.b);
    float maxRGB1_pq = linear_to_st2084_channel(maxRGB1_linear);
    return maxRGB_eetf_internal(rgb_linear, maxRGB1_linear, maxRGB1_pq, Lw, Lmax);
}

float linear_to_hlg_channel(float u)
{
    float ln2_i = 1. / log(2.);
    float m = 0.17883277 / ln2_i;
    return (u <= (1. / 12.)) ? sqrt(3. * u) : ((log2((12. * u) - 0.28466892) * m) + 0.55991073);
}

vec3 linear_to_hlg(vec3 rgb, float Lw)
{
    rgb = clamp(rgb, 0.0, 1.0);

    if (Lw > 1000.)
    {
        rgb = maxRGB_eetf_linear_to_linear(rgb, Lw, 1000.);
        rgb *= 10000. / Lw;
    }
    else
    {
        rgb *= 10.;
    }

    float Yd = dot(rgb, vec3(0.2627, 0.678, 0.0593));

     
    Yd = max(6.10352e-5, Yd);

    rgb *= pow(Yd, -1. / 6.);
    return vec3(linear_to_hlg_channel(rgb.r), linear_to_hlg_channel(rgb.g), linear_to_hlg_channel(rgb.b));
}

float PS_I010_HLG_U_709_2020_WideWide(FragTexWideWide frag_in)
{
    vec3 rgb_topleft = texture(image, frag_in.uuvv.xz).rgb;
    vec3 rgb_topright = texture(image, frag_in.uuvv.yz).rgb;
    vec3 rgb_bottomleft = texture(image, frag_in.uuvv.xw).rgb;
    vec3 rgb_bottomright = texture(image, frag_in.uuvv.yw).rgb;
    vec3 rgb = (rgb_topleft + rgb_topright + rgb_bottomleft + rgb_bottomright) * (0.25 * sdr_white_nits_over_maximum);
    rgb = rec709_to_rec2020(rgb);
    rgb = linear_to_hlg(rgb, hdr_lw);
    float u = dot(color_vec1.xyz, rgb) + color_vec1.w;
    return u * (1023. / 65535.);
}

float _main_wrap(FragTexWideWide frag_in)
{
    return PS_I010_HLG_U_709_2020_WideWide(frag_in);
}

void main(void)
{
    FragTexWideWide frag_in;
    frag_in.uuvv = _vertex_shader_attrib0;

    _pixel_shader_attrib0 = _main_wrap(frag_in);
}

info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform float width_i;


out vec3 _vertex_shader_attrib0;

out gl_PerVertex {
    vec4 gl_Position;
};

struct VertTexPosWide {
    vec3 uuv;
    vec4 pos;
};

VertTexPosWide VSTexPos_Left(uint id)
{
    float idHigh = float(id >> 1);
    float idLow = float(id & uint(1));

    float x = idHigh * 4.0 - 1.0;
    float y = idLow * 4.0 - 1.0;

    float u_right = idHigh * 2.0;
    float u_left = u_right - width_i;
    float v = obs_glsl_compile ? (idLow * 2.0) : (1.0 - idLow * 2.0);

    VertTexPosWide vert_out;
    vert_out.uuv = vec3(u_left, u_right, v);
    vert_out.pos = vec4(x, y, 0.0, 1.0);
    return vert_out;
}

VertTexPosWide _main_wrap(uint id)
{
    return VSTexPos_Left(id);
}

void main(void)
{
    uint id;
    VertTexPosWide outputval;

    id = uint(gl_VertexID);

    outputval = _main_wrap(id);

    _vertex_shader_attrib0 = outputval.uuv;
    gl_Position = outputval.pos;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform sampler2D image;
uniform vec4 color_vec1;

in vec3 _vertex_shader_attrib0;

out float _pixel_shader_attrib0;

struct FragTexWide {
    vec3 uuv;
};

float srgb_linear_to_nonlinear_channel(float u)
{
    return (u <= 0.0031308) ? (12.92 * u) : ((1.055 * pow(u, 1. / 2.4)) - 0.055);
}

vec3 srgb_linear_to_nonlinear(vec3 v)
{
    return vec3(srgb_linear_to_nonlinear_channel(v.r), srgb_linear_to_nonlinear_channel(v.g), srgb_linear_to_nonlinear_channel(v.b));
}

float PS_I010_SRGB_U_Wide(FragTexWide frag_in)
{
    vec3 rgb_left = texture(image, frag_in.uuv.xz).rgb;
    vec3 rgb_right = texture(image, frag_in.uuv.yz).rgb;
    vec3 rgb = (rgb_left + rgb_right) * 0.5;
    rgb = srgb_linear_to_nonlinear(rgb);
    float u = dot(color_vec1.xyz, rgb) + color_vec1.w;
    return u * (1023. / 65535.);
}

float _main_wrap(FragTexWide frag_in)
{
    return PS_I010_SRGB_U_Wide(frag_in);
}

void main(void)
{
    FragTexWide frag_in;
    frag_in.uuv = _vertex_shader_attrib0;

    _pixel_shader_attrib0 = _main_wrap(frag_in);
}

info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform float width_i;
uniform float height_i;


out vec4 _vertex_shader_attrib0;

out gl_PerVertex {
    vec4 gl_Position;
};

struct VertTexPosWideWide {
    vec4 uuvv;
    vec4 pos;
};

VertTexPosWideWide VSTexPos_TopLeft(uint id)
{
    float idHigh = float(id >> 1);
    float idLow = float(id & uint(1));

    float x = idHigh * 4.0 - 1.0;
    float y = idLow * 4.0 - 1.0;

    float u_right = idHigh * 2.0;
    float u_left = u_right - width_i;
    float v_bottom;
    float v_top;
    if (obs_glsl_compile) {
        v_bottom = idLow * 2.0;
        v_top = v_bottom + height_i;
    } else {
        v_bottom = 1.0 - idLow * 2.0;
        v_top = v_bottom - height_i;
    }

    VertTexPosWideWide vert_out;
    vert_out.uuvv = vec4(u_left, u_right, v_top, v_bottom);
    vert_out.pos = vec4(x, y, 0.0, 1.0);
    return vert_out;
}

VertTexPosWideWide _main_wrap(uint id)
{
    return VSTexPos_TopLeft(id);
}

void main(void)
{
    uint id;
    VertTexPosWideWide outputval;

    id = uint(gl_VertexID);

    outputval = _main_wrap(id);

    _vertex_shader_attrib0 = outputval.uuvv;
    gl_Position = outputval.pos;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform sampler2D image;
uniform float sdr_white_nits_over_maximum;
uniform vec4 color_vec2;

in vec4 _vertex_shader_attrib0;

out float _pixel_shader_attrib0;

struct FragTexWideWide {
    vec4 uuvv;
};

vec3 rec709_to_rec2020(vec3 v)
{
    float r = dot(v, vec3(0.62740389593469903, 0.32928303837788370, 0.043313065687417225));
    float g = dot(v, vec3(0.069097289358232075, 0.91954039507545871, 0.011362315566309178));
    float b = dot(v, vec3(0.016391438875150280, 0.088013307877225749, 0.89559525324762401));
    return vec3(r, g, b);
}

float linear_to_st2084_channel(float x)
{
    float c = pow(abs(x), 0.1593017578);
    return pow((0.8359375 + 18.8515625 * c) / (1. + 18.6875 * c), 78.84375);
}

vec3 linear_to_st2084(vec3 rgb)
{
    return vec3(linear_to_st2084_channel(rgb.r), linear_to_st2084_channel(rgb.g), linear_to_st2084_channel(rgb.b));
}

float PS_I010_PQ_V_709_2020_WideWide(FragTexWideWide frag_in)
{
    vec3 rgb_topleft = texture(image, frag_in.uuvv.xz).rgb;
    vec3 rgb_topright = texture(image, frag_in.uuvv.yz).rgb;
    vec3 rgb_bottomleft = texture(image, frag_in.uuvv.xw).rgb;
    vec3 rgb_bottomright = texture(image, frag_in.uuvv.yw).rgb;
    vec3 rgb = (rgb_topleft + rgb_topright + rgb_bottomleft + rgb_bottomright) * (0.25 * sdr_white_nits_over_maximum);
    rgb = rec709_to_rec2020(rgb);
    rgb = linear_to_st2084(rgb);
    float v = dot(color_vec2.xyz, rgb) + color_vec2.w;
    return v * (1023. / 65535.);
}

float _main_wrap(FragTexWideWide frag_in)
{
    return PS_I010_PQ_V_709_2020_WideWide(frag_in);
}

void main(void)
{
    FragTexWideWide frag_in;
    frag_in.uuvv = _vertex_shader_attrib0;

    _pixel_shader_attrib0 = _main_wrap(frag_in);
}

info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform float width_i;
uniform float height_i;


out vec4 _vertex_shader_attrib0;

out gl_PerVertex {
    vec4 gl_Position;
};

struct VertTexPosWideWide {
    vec4 uuvv;
    vec4 pos;
};

VertTexPosWideWide VSTexPos_TopLeft(uint id)
{
    float idHigh = float(id >> 1);
    float idLow = float(id & uint(1));

    float x = idHigh * 4.0 - 1.0;
    float y = idLow * 4.0 - 1.0;

    float u_right = idHigh * 2.0;
    float u_left = u_right - width_i;
    float v_bottom;
    float v_top;
    if (obs_glsl_compile) {
        v_bottom = idLow * 2.0;
        v_top = v_bottom + height_i;
    } else {
        v_bottom = 1.0 - idLow * 2.0;
        v_top = v_bottom - height_i;
    }

    VertTexPosWideWide vert_out;
    vert_out.uuvv = vec4(u_left, u_right, v_top, v_bottom);
    vert_out.pos = vec4(x, y, 0.0, 1.0);
    return vert_out;
}

VertTexPosWideWide _main_wrap(uint id)
{
    return VSTexPos_TopLeft(id);
}

void main(void)
{
    uint id;
    VertTexPosWideWide outputval;

    id = uint(gl_VertexID);

    outputval = _main_wrap(id);

    _vertex_shader_attrib0 = outputval.uuvv;
    gl_Position = outputval.pos;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform sampler2D image;
uniform float sdr_white_nits_over_maximum;
uniform float hdr_lw;
uniform vec4 color_vec2;

in vec4 _vertex_shader_attrib0;

out float _pixel_shader_attrib0;

struct FragTexWideWide {
    vec4 uuvv;
};

vec3 rec709_to_rec2020(vec3 v)
{
    float r = dot(v, vec3(0.62740389593469903, 0.32928303837788370, 0.043313065687417225));
    float g = dot(v, vec3(0.069097289358232075, 0.91954039507545871, 0.011362315566309178));
    float b = dot(v, vec3(0.016391438875150280, 0.088013307877225749, 0.89559525324762401));
    return vec3(r, g, b);
}

float linear_to_st2084_channel(float x)
{
    float c = pow(abs(x), 0.1593017578);
    return pow((0.8359375 + 18.8515625 * c) / (1. + 18.6875 * c), 78.84375);
}

float eetf_0_Lmax(float maxRGB1_pq, float Lw, float Lmax)
{
    float Lw_pq = linear_to_st2084_channel(Lw / 10000.);
    float E1 = clamp(maxRGB1_pq / Lw_pq, 0.0, 1.0);
    float maxLum = linear_to_st2084_channel(Lmax / 10000.) / Lw_pq;
    float KS = (1.5 * maxLum) - 0.5;
    float E2 = E1;
    if (E1 > KS)
    {
        float T = (E1 - KS) / (1. - KS);
        float Tsquared = T * T;
        float Tcubed = Tsquared * T;
        float P = (2. * Tcubed - 3. * Tsquared + 1.) * KS + (Tcubed - 2. * Tsquared + T) * (1. - KS) + (-2. * Tcubed + 3. * Tsquared) * maxLum;
        E2 = P;
    }
    float E3 = E2;
    float E4 = E3 * Lw_pq;
    return E4;
}

float st2084_to_linear_channel(float u)
{
    float c = pow(abs(u), 1. / 78.84375);
    return pow(abs(max(c - 0.8359375, 0.) / (18.8515625 - 18.6875 * c)), 1. / 0.1593017578);
}

vec3 maxRGB_eetf_internal(vec3 rgb_linear, float maxRGB1_linear, float maxRGB1_pq, float Lw, float Lmax)
{
    float maxRGB2_pq = eetf_0_Lmax(maxRGB1_pq, Lw, Lmax);
    float maxRGB2_linear = st2084_to_linear_channel(maxRGB2_pq);

     
    maxRGB1_linear = max(6.10352e-5, maxRGB1_linear);

    rgb_linear *= maxRGB2_linear / maxRGB1_linear;
    return rgb_linear;
}

vec3 maxRGB_eetf_linear_to_linear(vec3 rgb_linear, float Lw, float Lmax)
{
    float maxRGB1_linear = max(max(rgb_linear.r, rgb_linear.g), rgb_linear.b);
    float maxRGB1_pq = linear_to_st2084_channel(maxRGB1_linear);
    return maxRGB_eetf_internal(rgb_linear, maxRGB1_linear, maxRGB1_pq, Lw, Lmax);
}

float linear_to_hlg_channel(float u)
{
    float ln2_i = 1. / log(2.);
    float m = 0.17883277 / ln2_i;
    return (u <= (1. / 12.)) ? sqrt(3. * u) : ((log2((12. * u) - 0.28466892) * m) + 0.55991073);
}

vec3 linear_to_hlg(vec3 rgb, float Lw)
{
    rgb = clamp(rgb, 0.0, 1.0);

    if (Lw > 1000.)
    {
        rgb = maxRGB_eetf_linear_to_linear(rgb, Lw, 1000.);
        rgb *= 10000. / Lw;
    }
    else
    {
        rgb *= 10.;
    }

    float Yd = dot(rgb, vec3(0.2627, 0.678, 0.0593));

     
    Yd = max(6.10352e-5, Yd);

    rgb *= pow(Yd, -1. / 6.);
    return vec3(linear_to_hlg_channel(rgb.r), linear_to_hlg_channel(rgb.g), linear_to_hlg_channel(rgb.b));
}

float PS_I010_HLG_V_709_2020_WideWide(FragTexWideWide frag_in)
{
    vec3 rgb_topleft = texture(image, frag_in.uuvv.xz).rgb;
    vec3 rgb_topright = texture(image, frag_in.uuvv.yz).rgb;
    vec3 rgb_bottomleft = texture(image, frag_in.uuvv.xw).rgb;
    vec3 rgb_bottomright = texture(image, frag_in.uuvv.yw).rgb;
    vec3 rgb = (rgb_topleft + rgb_topright + rgb_bottomleft + rgb_bottomright) * (0.25 * sdr_white_nits_over_maximum);
    rgb = rec709_to_rec2020(rgb);
    rgb = linear_to_hlg(rgb, hdr_lw);
    float v = dot(color_vec2.xyz, rgb) + color_vec2.w;
    return v * (1023. / 65535.);
}

float _main_wrap(FragTexWideWide frag_in)
{
    return PS_I010_HLG_V_709_2020_WideWide(frag_in);
}

void main(void)
{
    FragTexWideWide frag_in;
    frag_in.uuvv = _vertex_shader_attrib0;

    _pixel_shader_attrib0 = _main_wrap(frag_in);
}

info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform float width_i;


out vec3 _vertex_shader_attrib0;

out gl_PerVertex {
    vec4 gl_Position;
};

struct VertTexPosWide {
    vec3 uuv;
    vec4 pos;
};

VertTexPosWide VSTexPos_Left(uint id)
{
    float idHigh = float(id >> 1);
    float idLow = float(id & uint(1));

    float x = idHigh * 4.0 - 1.0;
    float y = idLow * 4.0 - 1.0;

    float u_right = idHigh * 2.0;
    float u_left = u_right - width_i;
    float v = obs_glsl_compile ? (idLow * 2.0) : (1.0 - idLow * 2.0);

    VertTexPosWide vert_out;
    vert_out.uuv = vec3(u_left, u_right, v);
    vert_out.pos = vec4(x, y, 0.0, 1.0);
    return vert_out;
}

VertTexPosWide _main_wrap(uint id)
{
    return VSTexPos_Left(id);
}

void main(void)
{
    uint id;
    VertTexPosWide outputval;

    id = uint(gl_VertexID);

    outputval = _main_wrap(id);

    _vertex_shader_attrib0 = outputval.uuv;
    gl_Position = outputval.pos;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform sampler2D image;
uniform vec4 color_vec2;

in vec3 _vertex_shader_attrib0;

out float _pixel_shader_attrib0;

struct FragTexWide {
    vec3 uuv;
};

float srgb_linear_to_nonlinear_channel(float u)
{
    return (u <= 0.0031308) ? (12.92 * u) : ((1.055 * pow(u, 1. / 2.4)) - 0.055);
}

vec3 srgb_linear_to_nonlinear(vec3 v)
{
    return vec3(srgb_linear_to_nonlinear_channel(v.r), srgb_linear_to_nonlinear_channel(v.g), srgb_linear_to_nonlinear_channel(v.b));
}

float PS_I010_SRGB_V_Wide(FragTexWide frag_in)
{
    vec3 rgb_left = texture(image, frag_in.uuv.xz).rgb;
    vec3 rgb_right = texture(image, frag_in.uuv.yz).rgb;
    vec3 rgb = (rgb_left + rgb_right) * 0.5;
    rgb = srgb_linear_to_nonlinear(rgb);
    float v = dot(color_vec2.xyz, rgb) + color_vec2.w;
    return v * (1023. / 65535.);
}

float _main_wrap(FragTexWide frag_in)
{
    return PS_I010_SRGB_V_Wide(frag_in);
}

void main(void)
{
    FragTexWide frag_in;
    frag_in.uuv = _vertex_shader_attrib0;

    _pixel_shader_attrib0 = _main_wrap(frag_in);
}

info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}




out gl_PerVertex {
    vec4 gl_Position;
};

struct FragPos {
    vec4 pos;
};

FragPos VSPos(uint id)
{
    float idHigh = float(id >> 1);
    float idLow = float(id & uint(1));

    float x = idHigh * 4.0 - 1.0;
    float y = idLow * 4.0 - 1.0;

    FragPos vert_out;
    vert_out.pos = vec4(x, y, 0.0, 1.0);
    return vert_out;
}

FragPos _main_wrap(uint id)
{
    return VSPos(id);
}

void main(void)
{
    uint id;
    FragPos outputval;

    id = uint(gl_VertexID);

    outputval = _main_wrap(id);

    gl_Position = outputval.pos;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform sampler2D image;
uniform float sdr_white_nits_over_maximum;
uniform vec4 color_vec0;


out float _pixel_shader_attrib0;

struct FragPos {
    vec4 pos;
};

vec3 rec709_to_rec2020(vec3 v)
{
    float r = dot(v, vec3(0.62740389593469903, 0.32928303837788370, 0.043313065687417225));
    float g = dot(v, vec3(0.069097289358232075, 0.91954039507545871, 0.011362315566309178));
    float b = dot(v, vec3(0.016391438875150280, 0.088013307877225749, 0.89559525324762401));
    return vec3(r, g, b);
}

float linear_to_st2084_channel(float x)
{
    float c = pow(abs(x), 0.1593017578);
    return pow((0.8359375 + 18.8515625 * c) / (1. + 18.6875 * c), 78.84375);
}

vec3 linear_to_st2084(vec3 rgb)
{
    return vec3(linear_to_st2084_channel(rgb.r), linear_to_st2084_channel(rgb.g), linear_to_st2084_channel(rgb.b));
}

float PS_P010_PQ_Y_709_2020(FragPos frag_in)
{
    vec3 rgb = obs_load_2d(image, ivec3(frag_in.pos.xy, 0)).rgb * sdr_white_nits_over_maximum;
    rgb = rec709_to_rec2020(rgb);
    rgb = linear_to_st2084(rgb);
    float y = dot(color_vec0.xyz, rgb) + color_vec0.w;
    y = floor(clamp(y, 0.0, 1.0) * 1023. + 0.5) * (64. / 65535.);
    return y;
}

float _main_wrap(FragPos frag_in)
{
    return PS_P010_PQ_Y_709_2020(frag_in);
}

void main(void)
{
    FragPos frag_in;
    frag_in.pos = gl_FragCoord;

    _pixel_shader_attrib0 = _main_wrap(frag_in);
}

info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}




out gl_PerVertex {
    vec4 gl_Position;
};

struct FragPos {
    vec4 pos;
};

FragPos VSPos(uint id)
{
    float idHigh = float(id >> 1);
    float idLow = float(id & uint(1));

    float x = idHigh * 4.0 - 1.0;
    float y = idLow * 4.0 - 1.0;

    FragPos vert_out;
    vert_out.pos = vec4(x, y, 0.0, 1.0);
    return vert_out;
}

FragPos _main_wrap(uint id)
{
    return VSPos(id);
}

void main(void)
{
    uint id;
    FragPos outputval;

    id = uint(gl_VertexID);

    outputval = _main_wrap(id);

    gl_Position = outputval.pos;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform sampler2D image;
uniform float sdr_white_nits_over_maximum;
uniform float hdr_lw;
uniform vec4 color_vec0;


out float _pixel_shader_attrib0;

struct FragPos {
    vec4 pos;
};

vec3 rec709_to_rec2020(vec3 v)
{
    float r = dot(v, vec3(0.62740389593469903, 0.32928303837788370, 0.043313065687417225));
    float g = dot(v, vec3(0.069097289358232075, 0.91954039507545871, 0.011362315566309178));
    float b = dot(v, vec3(0.016391438875150280, 0.088013307877225749, 0.89559525324762401));
    return vec3(r, g, b);
}

float linear_to_st2084_channel(float x)
{
    float c = pow(abs(x), 0.1593017578);
    return pow((0.8359375 + 18.8515625 * c) / (1. + 18.6875 * c), 78.84375);
}

float eetf_0_Lmax(float maxRGB1_pq, float Lw, float Lmax)
{
    float Lw_pq = linear_to_st2084_channel(Lw / 10000.);
    float E1 = clamp(maxRGB1_pq / Lw_pq, 0.0, 1.0);
    float maxLum = linear_to_st2084_channel(Lmax / 10000.) / Lw_pq;
    float KS = (1.5 * maxLum) - 0.5;
    float E2 = E1;
    if (E1 > KS)
    {
        float T = (E1 - KS) / (1. - KS);
        float Tsquared = T * T;
        float Tcubed = Tsquared * T;
        float P = (2. * Tcubed - 3. * Tsquared + 1.) * KS + (Tcubed - 2. * Tsquared + T) * (1. - KS) + (-2. * Tcubed + 3. * Tsquared) * maxLum;
        E2 = P;
    }
    float E3 = E2;
    float E4 = E3 * Lw_pq;
    return E4;
}

float st2084_to_linear_channel(float u)
{
    float c = pow(abs(u), 1. / 78.84375);
    return pow(abs(max(c - 0.8359375, 0.) / (18.8515625 - 18.6875 * c)), 1. / 0.1593017578);
}

vec3 maxRGB_eetf_internal(vec3 rgb_linear, float maxRGB1_linear, float maxRGB1_pq, float Lw, float Lmax)
{
    float maxRGB2_pq = eetf_0_Lmax(maxRGB1_pq, Lw, Lmax);
    float maxRGB2_linear = st2084_to_linear_channel(maxRGB2_pq);

     
    maxRGB1_linear = max(6.10352e-5, maxRGB1_linear);

    rgb_linear *= maxRGB2_linear / maxRGB1_linear;
    return rgb_linear;
}

vec3 maxRGB_eetf_linear_to_linear(vec3 rgb_linear, float Lw, float Lmax)
{
    float maxRGB1_linear = max(max(rgb_linear.r, rgb_linear.g), rgb_linear.b);
    float maxRGB1_pq = linear_to_st2084_channel(maxRGB1_linear);
    return maxRGB_eetf_internal(rgb_linear, maxRGB1_linear, maxRGB1_pq, Lw, Lmax);
}

float linear_to_hlg_channel(float u)
{
    float ln2_i = 1. / log(2.);
    float m = 0.17883277 / ln2_i;
    return (u <= (1. / 12.)) ? sqrt(3. * u) : ((log2((12. * u) - 0.28466892) * m) + 0.55991073);
}

vec3 linear_to_hlg(vec3 rgb, float Lw)
{
    rgb = clamp(rgb, 0.0, 1.0);

    if (Lw > 1000.)
    {
        rgb = maxRGB_eetf_linear_to_linear(rgb, Lw, 1000.);
        rgb *= 10000. / Lw;
    }
    else
    {
        rgb *= 10.;
    }

    float Yd = dot(rgb, vec3(0.2627, 0.678, 0.0593));

     
    Yd = max(6.10352e-5, Yd);

    rgb *= pow(Yd, -1. / 6.);
    return vec3(linear_to_hlg_channel(rgb.r), linear_to_hlg_channel(rgb.g), linear_to_hlg_channel(rgb.b));
}

float PS_P010_HLG_Y_709_2020(FragPos frag_in)
{
    vec3 rgb = obs_load_2d(image, ivec3(frag_in.pos.xy, 0)).rgb * sdr_white_nits_over_maximum;
    rgb = rec709_to_rec2020(rgb);
    rgb = linear_to_hlg(rgb, hdr_lw);
    float y = dot(color_vec0.xyz, rgb) + color_vec0.w;
    y = floor(clamp(y, 0.0, 1.0) * 1023. + 0.5) * (64. / 65535.);
    return y;
}

float _main_wrap(FragPos frag_in)
{
    return PS_P010_HLG_Y_709_2020(frag_in);
}

void main(void)
{
    FragPos frag_in;
    frag_in.pos = gl_FragCoord;

    _pixel_shader_attrib0 = _main_wrap(frag_in);
}

info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}




out gl_PerVertex {
    vec4 gl_Position;
};

struct FragPos {
    vec4 pos;
};

FragPos VSPos(uint id)
{
    float idHigh = float(id >> 1);
    float idLow = float(id & uint(1));

    float x = idHigh * 4.0 - 1.0;
    float y = idLow * 4.0 - 1.0;

    FragPos vert_out;
    vert_out.pos = vec4(x, y, 0.0, 1.0);
    return vert_out;
}

FragPos _main_wrap(uint id)
{
    return VSPos(id);
}

void main(void)
{
    uint id;
    FragPos outputval;

    id = uint(gl_VertexID);

    outputval = _main_wrap(id);

    gl_Position = outputval.pos;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform sampler2D image;
uniform vec4 color_vec0;


out float _pixel_shader_attrib0;

struct FragPos {
    vec4 pos;
};

float srgb_linear_to_nonlinear_channel(float u)
{
    return (u <= 0.0031308) ? (12.92 * u) : ((1.055 * pow(u, 1. / 2.4)) - 0.055);
}

vec3 srgb_linear_to_nonlinear(vec3 v)
{
    return vec3(srgb_linear_to_nonlinear_channel(v.r), srgb_linear_to_nonlinear_channel(v.g), srgb_linear_to_nonlinear_channel(v.b));
}

float PS_P010_SRGB_Y(FragPos frag_in)
{
    vec3 rgb = obs_load_2d(image, ivec3(frag_in.pos.xy, 0)).rgb;
    rgb = srgb_linear_to_nonlinear(rgb);
    float y = dot(color_vec0.xyz, rgb) + color_vec0.w;
    y = floor(clamp(y, 0.0, 1.0) * 1023. + 0.5) * (64. / 65535.);
    return y;
}

float _main_wrap(FragPos frag_in)
{
    return PS_P010_SRGB_Y(frag_in);
}

void main(void)
{
    FragPos frag_in;
    frag_in.pos = gl_FragCoord;

    _pixel_shader_attrib0 = _main_wrap(frag_in);
}

info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform float width_i;
uniform float height_i;


out vec4 _vertex_shader_attrib0;

out gl_PerVertex {
    vec4 gl_Position;
};

struct VertTexPosWideWide {
    vec4 uuvv;
    vec4 pos;
};

VertTexPosWideWide VSTexPos_TopLeft(uint id)
{
    float idHigh = float(id >> 1);
    float idLow = float(id & uint(1));

    float x = idHigh * 4.0 - 1.0;
    float y = idLow * 4.0 - 1.0;

    float u_right = idHigh * 2.0;
    float u_left = u_right - width_i;
    float v_bottom;
    float v_top;
    if (obs_glsl_compile) {
        v_bottom = idLow * 2.0;
        v_top = v_bottom + height_i;
    } else {
        v_bottom = 1.0 - idLow * 2.0;
        v_top = v_bottom - height_i;
    }

    VertTexPosWideWide vert_out;
    vert_out.uuvv = vec4(u_left, u_right, v_top, v_bottom);
    vert_out.pos = vec4(x, y, 0.0, 1.0);
    return vert_out;
}

VertTexPosWideWide _main_wrap(uint id)
{
    return VSTexPos_TopLeft(id);
}

void main(void)
{
    uint id;
    VertTexPosWideWide outputval;

    id = uint(gl_VertexID);

    outputval = _main_wrap(id);

    _vertex_shader_attrib0 = outputval.uuvv;
    gl_Position = outputval.pos;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform sampler2D image;
uniform float sdr_white_nits_over_maximum;
uniform vec4 color_vec1;
uniform vec4 color_vec2;

in vec4 _vertex_shader_attrib0;

out vec2 _pixel_shader_attrib0;

struct FragTexWideWide {
    vec4 uuvv;
};

vec3 rec709_to_rec2020(vec3 v)
{
    float r = dot(v, vec3(0.62740389593469903, 0.32928303837788370, 0.043313065687417225));
    float g = dot(v, vec3(0.069097289358232075, 0.91954039507545871, 0.011362315566309178));
    float b = dot(v, vec3(0.016391438875150280, 0.088013307877225749, 0.89559525324762401));
    return vec3(r, g, b);
}

float linear_to_st2084_channel(float x)
{
    float c = pow(abs(x), 0.1593017578);
    return pow((0.8359375 + 18.8515625 * c) / (1. + 18.6875 * c), 78.84375);
}

vec3 linear_to_st2084(vec3 rgb)
{
    return vec3(linear_to_st2084_channel(rgb.r), linear_to_st2084_channel(rgb.g), linear_to_st2084_channel(rgb.b));
}

vec2 PS_P010_PQ_UV_709_2020_WideWide(FragTexWideWide frag_in)
{
    vec3 rgb_topleft = texture(image, frag_in.uuvv.xz).rgb;
    vec3 rgb_topright = texture(image, frag_in.uuvv.yz).rgb;
    vec3 rgb_bottomleft = texture(image, frag_in.uuvv.xw).rgb;
    vec3 rgb_bottomright = texture(image, frag_in.uuvv.yw).rgb;
    vec3 rgb = (rgb_topleft + rgb_topright + rgb_bottomleft + rgb_bottomright) * (0.25 * sdr_white_nits_over_maximum);
    rgb = rec709_to_rec2020(rgb);
    rgb = linear_to_st2084(rgb);
    float u = dot(color_vec1.xyz, rgb) + color_vec1.w;
    float v = dot(color_vec2.xyz, rgb) + color_vec2.w;
    vec2 uv = vec2(u, v);
    uv = floor(clamp(uv, 0.0, 1.0) * 1023. + 0.5) * (64. / 65535.);
    return uv;
}

vec2 _main_wrap(FragTexWideWide frag_in)
{
    return PS_P010_PQ_UV_709_2020_WideWide(frag_in);
}

void main(void)
{
    FragTexWideWide frag_in;
    frag_in.uuvv = _vertex_shader_attrib0;

    _pixel_shader_attrib0 = _main_wrap(frag_in);
}

info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform float width_i;
uniform float height_i;


out vec4 _vertex_shader_attrib0;

out gl_PerVertex {
    vec4 gl_Position;
};

struct VertTexPosWideWide {
    vec4 uuvv;
    vec4 pos;
};

VertTexPosWideWide VSTexPos_TopLeft(uint id)
{
    float idHigh = float(id >> 1);
    float idLow = float(id & uint(1));

    float x = idHigh * 4.0 - 1.0;
    float y = idLow * 4.0 - 1.0;

    float u_right = idHigh * 2.0;
    float u_left = u_right - width_i;
    float v_bottom;
    float v_top;
    if (obs_glsl_compile) {
        v_bottom = idLow * 2.0;
        v_top = v_bottom + height_i;
    } else {
        v_bottom = 1.0 - idLow * 2.0;
        v_top = v_bottom - height_i;
    }

    VertTexPosWideWide vert_out;
    vert_out.uuvv = vec4(u_left, u_right, v_top, v_bottom);
    vert_out.pos = vec4(x, y, 0.0, 1.0);
    return vert_out;
}

VertTexPosWideWide _main_wrap(uint id)
{
    return VSTexPos_TopLeft(id);
}

void main(void)
{
    uint id;
    VertTexPosWideWide outputval;

    id = uint(gl_VertexID);

    outputval = _main_wrap(id);

    _vertex_shader_attrib0 = outputval.uuvv;
    gl_Position = outputval.pos;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform sampler2D image;
uniform float sdr_white_nits_over_maximum;
uniform float hdr_lw;
uniform vec4 color_vec1;
uniform vec4 color_vec2;

in vec4 _vertex_shader_attrib0;

out vec2 _pixel_shader_attrib0;

struct FragTexWideWide {
    vec4 uuvv;
};

vec3 rec709_to_rec2020(vec3 v)
{
    float r = dot(v, vec3(0.62740389593469903, 0.32928303837788370, 0.043313065687417225));
    float g = dot(v, vec3(0.069097289358232075, 0.91954039507545871, 0.011362315566309178));
    float b = dot(v, vec3(0.016391438875150280, 0.088013307877225749, 0.89559525324762401));
    return vec3(r, g, b);
}

float linear_to_st2084_channel(float x)
{
    float c = pow(abs(x), 0.1593017578);
    return pow((0.8359375 + 18.8515625 * c) / (1. + 18.6875 * c), 78.84375);
}

float eetf_0_Lmax(float maxRGB1_pq, float Lw, float Lmax)
{
    float Lw_pq = linear_to_st2084_channel(Lw / 10000.);
    float E1 = clamp(maxRGB1_pq / Lw_pq, 0.0, 1.0);
    float maxLum = linear_to_st2084_channel(Lmax / 10000.) / Lw_pq;
    float KS = (1.5 * maxLum) - 0.5;
    float E2 = E1;
    if (E1 > KS)
    {
        float T = (E1 - KS) / (1. - KS);
        float Tsquared = T * T;
        float Tcubed = Tsquared * T;
        float P = (2. * Tcubed - 3. * Tsquared + 1.) * KS + (Tcubed - 2. * Tsquared + T) * (1. - KS) + (-2. * Tcubed + 3. * Tsquared) * maxLum;
        E2 = P;
    }
    float E3 = E2;
    float E4 = E3 * Lw_pq;
    return E4;
}

float st2084_to_linear_channel(float u)
{
    float c = pow(abs(u), 1. / 78.84375);
    return pow(abs(max(c - 0.8359375, 0.) / (18.8515625 - 18.6875 * c)), 1. / 0.1593017578);
}

vec3 maxRGB_eetf_internal(vec3 rgb_linear, float maxRGB1_linear, float maxRGB1_pq, float Lw, float Lmax)
{
    float maxRGB2_pq = eetf_0_Lmax(maxRGB1_pq, Lw, Lmax);
    float maxRGB2_linear = st2084_to_linear_channel(maxRGB2_pq);

     
    maxRGB1_linear = max(6.10352e-5, maxRGB1_linear);

    rgb_linear *= maxRGB2_linear / maxRGB1_linear;
    return rgb_linear;
}

vec3 maxRGB_eetf_linear_to_linear(vec3 rgb_linear, float Lw, float Lmax)
{
    float maxRGB1_linear = max(max(rgb_linear.r, rgb_linear.g), rgb_linear.b);
    float maxRGB1_pq = linear_to_st2084_channel(maxRGB1_linear);
    return maxRGB_eetf_internal(rgb_linear, maxRGB1_linear, maxRGB1_pq, Lw, Lmax);
}

float linear_to_hlg_channel(float u)
{
    float ln2_i = 1. / log(2.);
    float m = 0.17883277 / ln2_i;
    return (u <= (1. / 12.)) ? sqrt(3. * u) : ((log2((12. * u) - 0.28466892) * m) + 0.55991073);
}

vec3 linear_to_hlg(vec3 rgb, float Lw)
{
    rgb = clamp(rgb, 0.0, 1.0);

    if (Lw > 1000.)
    {
        rgb = maxRGB_eetf_linear_to_linear(rgb, Lw, 1000.);
        rgb *= 10000. / Lw;
    }
    else
    {
        rgb *= 10.;
    }

    float Yd = dot(rgb, vec3(0.2627, 0.678, 0.0593));

     
    Yd = max(6.10352e-5, Yd);

    rgb *= pow(Yd, -1. / 6.);
    return vec3(linear_to_hlg_channel(rgb.r), linear_to_hlg_channel(rgb.g), linear_to_hlg_channel(rgb.b));
}

vec2 PS_P010_HLG_UV_709_2020_WideWide(FragTexWideWide frag_in)
{
    vec3 rgb_topleft = texture(image, frag_in.uuvv.xz).rgb;
    vec3 rgb_topright = texture(image, frag_in.uuvv.yz).rgb;
    vec3 rgb_bottomleft = texture(image, frag_in.uuvv.xw).rgb;
    vec3 rgb_bottomright = texture(image, frag_in.uuvv.yw).rgb;
    vec3 rgb = (rgb_topleft + rgb_topright + rgb_bottomleft + rgb_bottomright) * (0.25 * sdr_white_nits_over_maximum);
    rgb = rec709_to_rec2020(rgb);
    rgb = linear_to_hlg(rgb, hdr_lw);
    float u = dot(color_vec1.xyz, rgb) + color_vec1.w;
    float v = dot(color_vec2.xyz, rgb) + color_vec2.w;
    vec2 uv = vec2(u, v);
    uv = floor(clamp(uv, 0.0, 1.0) * 1023. + 0.5) * (64. / 65535.);
    return uv;
}

vec2 _main_wrap(FragTexWideWide frag_in)
{
    return PS_P010_HLG_UV_709_2020_WideWide(frag_in);
}

void main(void)
{
    FragTexWideWide frag_in;
    frag_in.uuvv = _vertex_shader_attrib0;

    _pixel_shader_attrib
info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform float width_i;


out vec3 _vertex_shader_attrib0;

out gl_PerVertex {
    vec4 gl_Position;
};

struct VertTexPosWide {
    vec3 uuv;
    vec4 pos;
};

VertTexPosWide VSTexPos_Left(uint id)
{
    float idHigh = float(id >> 1);
    float idLow = float(id & uint(1));

    float x = idHigh * 4.0 - 1.0;
    float y = idLow * 4.0 - 1.0;

    float u_right = idHigh * 2.0;
    float u_left = u_right - width_i;
    float v = obs_glsl_compile ? (idLow * 2.0) : (1.0 - idLow * 2.0);

    VertTexPosWide vert_out;
    vert_out.uuv = vec3(u_left, u_right, v);
    vert_out.pos = vec4(x, y, 0.0, 1.0);
    return vert_out;
}

VertTexPosWide _main_wrap(uint id)
{
    return VSTexPos_Left(id);
}

void main(void)
{
    uint id;
    VertTexPosWide outputval;

    id = uint(gl_VertexID);

    outputval = _main_wrap(id);

    _vertex_shader_attrib0 = outputval.uuv;
    gl_Position = outputval.pos;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform sampler2D image;
uniform vec4 color_vec1;
uniform vec4 color_vec2;

in vec3 _vertex_shader_attrib0;

out vec2 _pixel_shader_attrib0;

struct FragTexWide {
    vec3 uuv;
};

float srgb_linear_to_nonlinear_channel(float u)
{
    return (u <= 0.0031308) ? (12.92 * u) : ((1.055 * pow(u, 1. / 2.4)) - 0.055);
}

vec3 srgb_linear_to_nonlinear(vec3 v)
{
    return vec3(srgb_linear_to_nonlinear_channel(v.r), srgb_linear_to_nonlinear_channel(v.g), srgb_linear_to_nonlinear_channel(v.b));
}

vec2 PS_P010_SRGB_UV_Wide(FragTexWide frag_in)
{
    vec3 rgb_left = texture(image, frag_in.uuv.xz).rgb;
    vec3 rgb_right = texture(image, frag_in.uuv.yz).rgb;
    vec3 rgb = (rgb_left + rgb_right) * 0.5;
    rgb = srgb_linear_to_nonlinear(rgb);
    float u = dot(color_vec1.xyz, rgb) + color_vec1.w;
    float v = dot(color_vec2.xyz, rgb) + color_vec2.w;
    vec2 uv = vec2(u, v);
    uv = floor(clamp(uv, 0.0, 1.0) * 1023. + 0.5) * (64. / 65535.);
    return uv;
}

vec2 _main_wrap(FragTexWide frag_in)
{
    return PS_P010_SRGB_UV_Wide(frag_in);
}

void main(void)
{
    FragTexWide frag_in;
    frag_in.uuv = _vertex_shader_attrib0;

    _pixel_shader_attrib0 = _main_wrap(frag_in);
}

info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}




out gl_PerVertex {
    vec4 gl_Position;
};

struct FragPos {
    vec4 pos;
};

FragPos VSPos(uint id)
{
    float idHigh = float(id >> 1);
    float idLow = float(id & uint(1));

    float x = idHigh * 4.0 - 1.0;
    float y = idLow * 4.0 - 1.0;

    FragPos vert_out;
    vert_out.pos = vec4(x, y, 0.0, 1.0);
    return vert_out;
}

FragPos _main_wrap(uint id)
{
    return VSPos(id);
}

void main(void)
{
    uint id;
    FragPos outputval;

    id = uint(gl_VertexID);

    outputval = _main_wrap(id);

    gl_Position = outputval.pos;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform sampler2D image;
uniform float sdr_white_nits_over_maximum;
uniform vec4 color_vec0;


out float _pixel_shader_attrib0;

struct FragPos {
    vec4 pos;
};

vec3 rec709_to_rec2020(vec3 v)
{
    float r = dot(v, vec3(0.62740389593469903, 0.32928303837788370, 0.043313065687417225));
    float g = dot(v, vec3(0.069097289358232075, 0.91954039507545871, 0.011362315566309178));
    float b = dot(v, vec3(0.016391438875150280, 0.088013307877225749, 0.89559525324762401));
    return vec3(r, g, b);
}

float linear_to_st2084_channel(float x)
{
    float c = pow(abs(x), 0.1593017578);
    return pow((0.8359375 + 18.8515625 * c) / (1. + 18.6875 * c), 78.84375);
}

vec3 linear_to_st2084(vec3 rgb)
{
    return vec3(linear_to_st2084_channel(rgb.r), linear_to_st2084_channel(rgb.g), linear_to_st2084_channel(rgb.b));
}

float PS_P216_PQ_Y_709_2020(FragPos frag_in)
{
    vec3 rgb = obs_load_2d(image, ivec3(frag_in.pos.xy, 0)).rgb * sdr_white_nits_over_maximum;
    rgb = rec709_to_rec2020(rgb);
    rgb = linear_to_st2084(rgb);
    float y = dot(color_vec0.xyz, rgb) + color_vec0.w;
    return y;
}

float _main_wrap(FragPos frag_in)
{
    return PS_P216_PQ_Y_709_2020(frag_in);
}

void main(void)
{
    FragPos frag_in;
    frag_in.pos = gl_FragCoord;

    _pixel_shader_attrib0 = _main_wrap(frag_in);
}

info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}




out gl_PerVertex {
    vec4 gl_Position;
};

struct FragPos {
    vec4 pos;
};

FragPos VSPos(uint id)
{
    float idHigh = float(id >> 1);
    float idLow = float(id & uint(1));

    float x = idHigh * 4.0 - 1.0;
    float y = idLow * 4.0 - 1.0;

    FragPos vert_out;
    vert_out.pos = vec4(x, y, 0.0, 1.0);
    return vert_out;
}

FragPos _main_wrap(uint id)
{
    return VSPos(id);
}

void main(void)
{
    uint id;
    FragPos outputval;

    id = uint(gl_VertexID);

    outputval = _main_wrap(id);

    gl_Position = outputval.pos;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform sampler2D image;
uniform float sdr_white_nits_over_maximum;
uniform float hdr_lw;
uniform vec4 color_vec0;


out float _pixel_shader_attrib0;

struct FragPos {
    vec4 pos;
};

vec3 rec709_to_rec2020(vec3 v)
{
    float r = dot(v, vec3(0.62740389593469903, 0.32928303837788370, 0.043313065687417225));
    float g = dot(v, vec3(0.069097289358232075, 0.91954039507545871, 0.011362315566309178));
    float b = dot(v, vec3(0.016391438875150280, 0.088013307877225749, 0.89559525324762401));
    return vec3(r, g, b);
}

float linear_to_st2084_channel(float x)
{
    float c = pow(abs(x), 0.1593017578);
    return pow((0.8359375 + 18.8515625 * c) / (1. + 18.6875 * c), 78.84375);
}

float eetf_0_Lmax(float maxRGB1_pq, float Lw, float Lmax)
{
    float Lw_pq = linear_to_st2084_channel(Lw / 10000.);
    float E1 = clamp(maxRGB1_pq / Lw_pq, 0.0, 1.0);
    float maxLum = linear_to_st2084_channel(Lmax / 10000.) / Lw_pq;
    float KS = (1.5 * maxLum) - 0.5;
    float E2 = E1;
    if (E1 > KS)
    {
        float T = (E1 - KS) / (1. - KS);
        float Tsquared = T * T;
        float Tcubed = Tsquared * T;
        float P = (2. * Tcubed - 3. * Tsquared + 1.) * KS + (Tcubed - 2. * Tsquared + T) * (1. - KS) + (-2. * Tcubed + 3. * Tsquared) * maxLum;
        E2 = P;
    }
    float E3 = E2;
    float E4 = E3 * Lw_pq;
    return E4;
}

float st2084_to_linear_channel(float u)
{
    float c = pow(abs(u), 1. / 78.84375);
    return pow(abs(max(c - 0.8359375, 0.) / (18.8515625 - 18.6875 * c)), 1. / 0.1593017578);
}

vec3 maxRGB_eetf_internal(vec3 rgb_linear, float maxRGB1_linear, float maxRGB1_pq, float Lw, float Lmax)
{
    float maxRGB2_pq = eetf_0_Lmax(maxRGB1_pq, Lw, Lmax);
    float maxRGB2_linear = st2084_to_linear_channel(maxRGB2_pq);

     
    maxRGB1_linear = max(6.10352e-5, maxRGB1_linear);

    rgb_linear *= maxRGB2_linear / maxRGB1_linear;
    return rgb_linear;
}

vec3 maxRGB_eetf_linear_to_linear(vec3 rgb_linear, float Lw, float Lmax)
{
    float maxRGB1_linear = max(max(rgb_linear.r, rgb_linear.g), rgb_linear.b);
    float maxRGB1_pq = linear_to_st2084_channel(maxRGB1_linear);
    return maxRGB_eetf_internal(rgb_linear, maxRGB1_linear, maxRGB1_pq, Lw, Lmax);
}

float linear_to_hlg_channel(float u)
{
    float ln2_i = 1. / log(2.);
    float m = 0.17883277 / ln2_i;
    return (u <= (1. / 12.)) ? sqrt(3. * u) : ((log2((12. * u) - 0.28466892) * m) + 0.55991073);
}

vec3 linear_to_hlg(vec3 rgb, float Lw)
{
    rgb = clamp(rgb, 0.0, 1.0);

    if (Lw > 1000.)
    {
        rgb = maxRGB_eetf_linear_to_linear(rgb, Lw, 1000.);
        rgb *= 10000. / Lw;
    }
    else
    {
        rgb *= 10.;
    }

    float Yd = dot(rgb, vec3(0.2627, 0.678, 0.0593));

     
    Yd = max(6.10352e-5, Yd);

    rgb *= pow(Yd, -1. / 6.);
    return vec3(linear_to_hlg_channel(rgb.r), linear_to_hlg_channel(rgb.g), linear_to_hlg_channel(rgb.b));
}

float PS_P216_HLG_Y_709_2020(FragPos frag_in)
{
    vec3 rgb = obs_load_2d(image, ivec3(frag_in.pos.xy, 0)).rgb * sdr_white_nits_over_maximum;
    rgb = rec709_to_rec2020(rgb);
    rgb = linear_to_hlg(rgb, hdr_lw);
    float y = dot(color_vec0.xyz, rgb) + color_vec0.w;
    return y;
}

float _main_wrap(FragPos frag_in)
{
    return PS_P216_HLG_Y_709_2020(frag_in);
}

void main(void)
{
    FragPos frag_in;
    frag_in.pos = gl_FragCoord;

    _pixel_shader_attrib0 = _main_wrap(frag_in);
}

info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}




out gl_PerVertex {
    vec4 gl_Position;
};

struct FragPos {
    vec4 pos;
};

FragPos VSPos(uint id)
{
    float idHigh = float(id >> 1);
    float idLow = float(id & uint(1));

    float x = idHigh * 4.0 - 1.0;
    float y = idLow * 4.0 - 1.0;

    FragPos vert_out;
    vert_out.pos = vec4(x, y, 0.0, 1.0);
    return vert_out;
}

FragPos _main_wrap(uint id)
{
    return VSPos(id);
}

void main(void)
{
    uint id;
    FragPos outputval;

    id = uint(gl_VertexID);

    outputval = _main_wrap(id);

    gl_Position = outputval.pos;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform sampler2D image;
uniform vec4 color_vec0;


out float _pixel_shader_attrib0;

struct FragPos {
    vec4 pos;
};

float srgb_linear_to_nonlinear_channel(float u)
{
    return (u <= 0.0031308) ? (12.92 * u) : ((1.055 * pow(u, 1. / 2.4)) - 0.055);
}

vec3 srgb_linear_to_nonlinear(vec3 v)
{
    return vec3(srgb_linear_to_nonlinear_channel(v.r), srgb_linear_to_nonlinear_channel(v.g), srgb_linear_to_nonlinear_channel(v.b));
}

float PS_P216_SRGB_Y(FragPos frag_in)
{
    vec3 rgb = obs_load_2d(image, ivec3(frag_in.pos.xy, 0)).rgb;
    rgb = srgb_linear_to_nonlinear(rgb);
    float y = dot(color_vec0.xyz, rgb) + color_vec0.w;
    return y;
}

float _main_wrap(FragPos frag_in)
{
    return PS_P216_SRGB_Y(frag_in);
}

void main(void)
{
    FragPos frag_in;
    frag_in.pos = gl_FragCoord;

    _pixel_shader_attrib0 = _main_wrap(frag_in);
}

info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform float width_i;


out vec3 _vertex_shader_attrib0;

out gl_PerVertex {
    vec4 gl_Position;
};

struct VertTexPosWide {
    vec3 uuv;
    vec4 pos;
};

VertTexPosWide VSTexPos_Left(uint id)
{
    float idHigh = float(id >> 1);
    float idLow = float(id & uint(1));

    float x = idHigh * 4.0 - 1.0;
    float y = idLow * 4.0 - 1.0;

    float u_right = idHigh * 2.0;
    float u_left = u_right - width_i;
    float v = obs_glsl_compile ? (idLow * 2.0) : (1.0 - idLow * 2.0);

    VertTexPosWide vert_out;
    vert_out.uuv = vec3(u_left, u_right, v);
    vert_out.pos = vec4(x, y, 0.0, 1.0);
    return vert_out;
}

VertTexPosWide _main_wrap(uint id)
{
    return VSTexPos_Left(id);
}

void main(void)
{
    uint id;
    VertTexPosWide outputval;

    id = uint(gl_VertexID);

    outputval = _main_wrap(id);

    _vertex_shader_attrib0 = outputval.uuv;
    gl_Position = outputval.pos;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform sampler2D image;
uniform float sdr_white_nits_over_maximum;
uniform vec4 color_vec1;
uniform vec4 color_vec2;

in vec3 _vertex_shader_attrib0;

out vec2 _pixel_shader_attrib0;

struct FragTexWide {
    vec3 uuv;
};

vec3 rec709_to_rec2020(vec3 v)
{
    float r = dot(v, vec3(0.62740389593469903, 0.32928303837788370, 0.043313065687417225));
    float g = dot(v, vec3(0.069097289358232075, 0.91954039507545871, 0.011362315566309178));
    float b = dot(v, vec3(0.016391438875150280, 0.088013307877225749, 0.89559525324762401));
    return vec3(r, g, b);
}

float linear_to_st2084_channel(float x)
{
    float c = pow(abs(x), 0.1593017578);
    return pow((0.8359375 + 18.8515625 * c) / (1. + 18.6875 * c), 78.84375);
}

vec3 linear_to_st2084(vec3 rgb)
{
    return vec3(linear_to_st2084_channel(rgb.r), linear_to_st2084_channel(rgb.g), linear_to_st2084_channel(rgb.b));
}

vec2 PS_P216_PQ_UV_709_2020_Wide(FragTexWide frag_in)
{
    vec3 rgb_left = texture(image, frag_in.uuv.xz).rgb;
    vec3 rgb_right = texture(image, frag_in.uuv.yz).rgb;
    vec3 rgb = (rgb_left + rgb_right) * (0.5 * sdr_white_nits_over_maximum);
    rgb = rec709_to_rec2020(rgb);
    rgb = linear_to_st2084(rgb);
    float u = dot(color_vec1.xyz, rgb) + color_vec1.w;
    float v = dot(color_vec2.xyz, rgb) + color_vec2.w;
    vec2 uv = vec2(u, v);
    return uv;
}

vec2 _main_wrap(FragTexWide frag_in)
{
    return PS_P216_PQ_UV_709_2020_Wide(frag_in);
}

void main(void)
{
    FragTexWide frag_in;
    frag_in.uuv = _vertex_shader_attrib0;

    _pixel_shader_attrib0 = _main_wrap(frag_in);
}

info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform float width_i;


out vec3 _vertex_shader_attrib0;

out gl_PerVertex {
    vec4 gl_Position;
};

struct VertTexPosWide {
    vec3 uuv;
    vec4 pos;
};

VertTexPosWide VSTexPos_Left(uint id)
{
    float idHigh = float(id >> 1);
    float idLow = float(id & uint(1));

    float x = idHigh * 4.0 - 1.0;
    float y = idLow * 4.0 - 1.0;

    float u_right = idHigh * 2.0;
    float u_left = u_right - width_i;
    float v = obs_glsl_compile ? (idLow * 2.0) : (1.0 - idLow * 2.0);

    VertTexPosWide vert_out;
    vert_out.uuv = vec3(u_left, u_right, v);
    vert_out.pos = vec4(x, y, 0.0, 1.0);
    return vert_out;
}

VertTexPosWide _main_wrap(uint id)
{
    return VSTexPos_Left(id);
}

void main(void)
{
    uint id;
    VertTexPosWide outputval;

    id = uint(gl_VertexID);

    outputval = _main_wrap(id);

    _vertex_shader_attrib0 = outputval.uuv;
    gl_Position = outputval.pos;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform sampler2D image;
uniform float sdr_white_nits_over_maximum;
uniform float hdr_lw;
uniform vec4 color_vec1;
uniform vec4 color_vec2;

in vec3 _vertex_shader_attrib0;

out vec2 _pixel_shader_attrib0;

struct FragTexWide {
    vec3 uuv;
};

vec3 rec709_to_rec2020(vec3 v)
{
    float r = dot(v, vec3(0.62740389593469903, 0.32928303837788370, 0.043313065687417225));
    float g = dot(v, vec3(0.069097289358232075, 0.91954039507545871, 0.011362315566309178));
    float b = dot(v, vec3(0.016391438875150280, 0.088013307877225749, 0.89559525324762401));
    return vec3(r, g, b);
}

float linear_to_st2084_channel(float x)
{
    float c = pow(abs(x), 0.1593017578);
    return pow((0.8359375 + 18.8515625 * c) / (1. + 18.6875 * c), 78.84375);
}

float eetf_0_Lmax(float maxRGB1_pq, float Lw, float Lmax)
{
    float Lw_pq = linear_to_st2084_channel(Lw / 10000.);
    float E1 = clamp(maxRGB1_pq / Lw_pq, 0.0, 1.0);
    float maxLum = linear_to_st2084_channel(Lmax / 10000.) / Lw_pq;
    float KS = (1.5 * maxLum) - 0.5;
    float E2 = E1;
    if (E1 > KS)
    {
        float T = (E1 - KS) / (1. - KS);
        float Tsquared = T * T;
        float Tcubed = Tsquared * T;
        float P = (2. * Tcubed - 3. * Tsquared + 1.) * KS + (Tcubed - 2. * Tsquared + T) * (1. - KS) + (-2. * Tcubed + 3. * Tsquared) * maxLum;
        E2 = P;
    }
    float E3 = E2;
    float E4 = E3 * Lw_pq;
    return E4;
}

float st2084_to_linear_channel(float u)
{
    float c = pow(abs(u), 1. / 78.84375);
    return pow(abs(max(c - 0.8359375, 0.) / (18.8515625 - 18.6875 * c)), 1. / 0.1593017578);
}

vec3 maxRGB_eetf_internal(vec3 rgb_linear, float maxRGB1_linear, float maxRGB1_pq, float Lw, float Lmax)
{
    float maxRGB2_pq = eetf_0_Lmax(maxRGB1_pq, Lw, Lmax);
    float maxRGB2_linear = st2084_to_linear_channel(maxRGB2_pq);

     
    maxRGB1_linear = max(6.10352e-5, maxRGB1_linear);

    rgb_linear *= maxRGB2_linear / maxRGB1_linear;
    return rgb_linear;
}

vec3 maxRGB_eetf_linear_to_linear(vec3 rgb_linear, float Lw, float Lmax)
{
    float maxRGB1_linear = max(max(rgb_linear.r, rgb_linear.g), rgb_linear.b);
    float maxRGB1_pq = linear_to_st2084_channel(maxRGB1_linear);
    return maxRGB_eetf_internal(rgb_linear, maxRGB1_linear, maxRGB1_pq, Lw, Lmax);
}

float linear_to_hlg_channel(float u)
{
    float ln2_i = 1. / log(2.);
    float m = 0.17883277 / ln2_i;
    return (u <= (1. / 12.)) ? sqrt(3. * u) : ((log2((12. * u) - 0.28466892) * m) + 0.55991073);
}

vec3 linear_to_hlg(vec3 rgb, float Lw)
{
    rgb = clamp(rgb, 0.0, 1.0);

    if (Lw > 1000.)
    {
        rgb = maxRGB_eetf_linear_to_linear(rgb, Lw, 1000.);
        rgb *= 10000. / Lw;
    }
    else
    {
        rgb *= 10.;
    }

    float Yd = dot(rgb, vec3(0.2627, 0.678, 0.0593));

     
    Yd = max(6.10352e-5, Yd);

    rgb *= pow(Yd, -1. / 6.);
    return vec3(linear_to_hlg_channel(rgb.r), linear_to_hlg_channel(rgb.g), linear_to_hlg_channel(rgb.b));
}

vec2 PS_P216_HLG_UV_709_2020_Wide(FragTexWide frag_in)
{
    vec3 rgb_left = texture(image, frag_in.uuv.xz).rgb;
    vec3 rgb_right = texture(image, frag_in.uuv.yz).rgb;
    vec3 rgb = (rgb_left + rgb_right) * (0.5 * sdr_white_nits_over_maximum);
    rgb = rec709_to_rec2020(rgb);
    rgb = linear_to_hlg(rgb, hdr_lw);
    float u = dot(color_vec1.xyz, rgb) + color_vec1.w;
    float v = dot(color_vec2.xyz, rgb) + color_vec2.w;
    vec2 uv = vec2(u, v);
    return uv;
}

vec2 _main_wrap(FragTexWide frag_in)
{
    return PS_P216_HLG_UV_709_2020_Wide(frag_in);
}

void main(void)
{
    FragTexWide frag_in;
    frag_in.uuv = _vertex_shader_attrib0;

    _pixel_shader_attrib0 = _main_wrap(frag_in);
}

info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform float width_i;


out vec3 _vertex_shader_attrib0;

out gl_PerVertex {
    vec4 gl_Position;
};

struct VertTexPosWide {
    vec3 uuv;
    vec4 pos;
};

VertTexPosWide VSTexPos_Left(uint id)
{
    float idHigh = float(id >> 1);
    float idLow = float(id & uint(1));

    float x = idHigh * 4.0 - 1.0;
    float y = idLow * 4.0 - 1.0;

    float u_right = idHigh * 2.0;
    float u_left = u_right - width_i;
    float v = obs_glsl_compile ? (idLow * 2.0) : (1.0 - idLow * 2.0);

    VertTexPosWide vert_out;
    vert_out.uuv = vec3(u_left, u_right, v);
    vert_out.pos = vec4(x, y, 0.0, 1.0);
    return vert_out;
}

VertTexPosWide _main_wrap(uint id)
{
    return VSTexPos_Left(id);
}

void main(void)
{
    uint id;
    VertTexPosWide outputval;

    id = uint(gl_VertexID);

    outputval = _main_wrap(id);

    _vertex_shader_attrib0 = outputval.uuv;
    gl_Position = outputval.pos;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform sampler2D image;
uniform vec4 color_vec1;
uniform vec4 color_vec2;

in vec3 _vertex_shader_attrib0;

out vec2 _pixel_shader_attrib0;

struct FragTexWide {
    vec3 uuv;
};

float srgb_linear_to_nonlinear_channel(float u)
{
    return (u <= 0.0031308) ? (12.92 * u) : ((1.055 * pow(u, 1. / 2.4)) - 0.055);
}

vec3 srgb_linear_to_nonlinear(vec3 v)
{
    return vec3(srgb_linear_to_nonlinear_channel(v.r), srgb_linear_to_nonlinear_channel(v.g), srgb_linear_to_nonlinear_channel(v.b));
}

vec2 PS_P216_SRGB_UV_Wide(FragTexWide frag_in)
{
    vec3 rgb_left = texture(image, frag_in.uuv.xz).rgb;
    vec3 rgb_right = texture(image, frag_in.uuv.yz).rgb;
    vec3 rgb = (rgb_left + rgb_right) * 0.5;
    rgb = srgb_linear_to_nonlinear(rgb);
    float u = dot(color_vec1.xyz, rgb) + color_vec1.w;
    float v = dot(color_vec2.xyz, rgb) + color_vec2.w;
    vec2 uv = vec2(u, v);
    return uv;
}

vec2 _main_wrap(FragTexWide frag_in)
{
    return PS_P216_SRGB_UV_Wide(frag_in);
}

void main(void)
{
    FragTexWide frag_in;
    frag_in.uuv = _vertex_shader_attrib0;

    _pixel_shader_attrib0 = _main_wrap(frag_in);
}

info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}




out gl_PerVertex {
    vec4 gl_Position;
};

struct FragPos {
    vec4 pos;
};

FragPos VSPos(uint id)
{
    float idHigh = float(id >> 1);
    float idLow = float(id & uint(1));

    float x = idHigh * 4.0 - 1.0;
    float y = idLow * 4.0 - 1.0;

    FragPos vert_out;
    vert_out.pos = vec4(x, y, 0.0, 1.0);
    return vert_out;
}

FragPos _main_wrap(uint id)
{
    return VSPos(id);
}

void main(void)
{
    uint id;
    FragPos outputval;

    id = uint(gl_VertexID);

    outputval = _main_wrap(id);

    gl_Position = outputval.pos;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform sampler2D image;
uniform float sdr_white_nits_over_maximum;
uniform vec4 color_vec0;


out float _pixel_shader_attrib0;

struct FragPos {
    vec4 pos;
};

vec3 rec709_to_rec2020(vec3 v)
{
    float r = dot(v, vec3(0.62740389593469903, 0.32928303837788370, 0.043313065687417225));
    float g = dot(v, vec3(0.069097289358232075, 0.91954039507545871, 0.011362315566309178));
    float b = dot(v, vec3(0.016391438875150280, 0.088013307877225749, 0.89559525324762401));
    return vec3(r, g, b);
}

float linear_to_st2084_channel(float x)
{
    float c = pow(abs(x), 0.1593017578);
    return pow((0.8359375 + 18.8515625 * c) / (1. + 18.6875 * c), 78.84375);
}

vec3 linear_to_st2084(vec3 rgb)
{
    return vec3(linear_to_st2084_channel(rgb.r), linear_to_st2084_channel(rgb.g), linear_to_st2084_channel(rgb.b));
}

float PS_P416_PQ_Y_709_2020(FragPos frag_in)
{
    vec3 rgb = obs_load_2d(image, ivec3(frag_in.pos.xy, 0)).rgb * sdr_white_nits_over_maximum;
    rgb = rec709_to_rec2020(rgb);
    rgb = linear_to_st2084(rgb);
    float y = dot(color_vec0.xyz, rgb) + color_vec0.w;
    return y;
}

float _main_wrap(FragPos frag_in)
{
    return PS_P416_PQ_Y_709_2020(frag_in);
}

void main(void)
{
    FragPos frag_in;
    frag_in.pos = gl_FragCoord;

    _pixel_shader_attrib0 = _main_wrap(frag_in);
}

info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}




out gl_PerVertex {
    vec4 gl_Position;
};

struct FragPos {
    vec4 pos;
};

FragPos VSPos(uint id)
{
    float idHigh = float(id >> 1);
    float idLow = float(id & uint(1));

    float x = idHigh * 4.0 - 1.0;
    float y = idLow * 4.0 - 1.0;

    FragPos vert_out;
    vert_out.pos = vec4(x, y, 0.0, 1.0);
    return vert_out;
}

FragPos _main_wrap(uint id)
{
    return VSPos(id);
}

void main(void)
{
    uint id;
    FragPos outputval;

    id = uint(gl_VertexID);

    outputval = _main_wrap(id);

    gl_Position = outputval.pos;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform sampler2D image;
uniform float sdr_white_nits_over_maximum;
uniform float hdr_lw;
uniform vec4 color_vec0;


out float _pixel_shader_attrib0;

struct FragPos {
    vec4 pos;
};

vec3 rec709_to_rec2020(vec3 v)
{
    float r = dot(v, vec3(0.62740389593469903, 0.32928303837788370, 0.043313065687417225));
    float g = dot(v, vec3(0.069097289358232075, 0.91954039507545871, 0.011362315566309178));
    float b = dot(v, vec3(0.016391438875150280, 0.088013307877225749, 0.89559525324762401));
    return vec3(r, g, b);
}

float linear_to_st2084_channel(float x)
{
    float c = pow(abs(x), 0.1593017578);
    return pow((0.8359375 + 18.8515625 * c) / (1. + 18.6875 * c), 78.84375);
}

float eetf_0_Lmax(float maxRGB1_pq, float Lw, float Lmax)
{
    float Lw_pq = linear_to_st2084_channel(Lw / 10000.);
    float E1 = clamp(maxRGB1_pq / Lw_pq, 0.0, 1.0);
    float maxLum = linear_to_st2084_channel(Lmax / 10000.) / Lw_pq;
    float KS = (1.5 * maxLum) - 0.5;
    float E2 = E1;
    if (E1 > KS)
    {
        float T = (E1 - KS) / (1. - KS);
        float Tsquared = T * T;
        float Tcubed = Tsquared * T;
        float P = (2. * Tcubed - 3. * Tsquared + 1.) * KS + (Tcubed - 2. * Tsquared + T) * (1. - KS) + (-2. * Tcubed + 3. * Tsquared) * maxLum;
        E2 = P;
    }
    float E3 = E2;
    float E4 = E3 * Lw_pq;
    return E4;
}

float st2084_to_linear_channel(float u)
{
    float c = pow(abs(u), 1. / 78.84375);
    return pow(abs(max(c - 0.8359375, 0.) / (18.8515625 - 18.6875 * c)), 1. / 0.1593017578);
}

vec3 maxRGB_eetf_internal(vec3 rgb_linear, float maxRGB1_linear, float maxRGB1_pq, float Lw, float Lmax)
{
    float maxRGB2_pq = eetf_0_Lmax(maxRGB1_pq, Lw, Lmax);
    float maxRGB2_linear = st2084_to_linear_channel(maxRGB2_pq);

     
    maxRGB1_linear = max(6.10352e-5, maxRGB1_linear);

    rgb_linear *= maxRGB2_linear / maxRGB1_linear;
    return rgb_linear;
}

vec3 maxRGB_eetf_linear_to_linear(vec3 rgb_linear, float Lw, float Lmax)
{
    float maxRGB1_linear = max(max(rgb_linear.r, rgb_linear.g), rgb_linear.b);
    float maxRGB1_pq = linear_to_st2084_channel(maxRGB1_linear);
    return maxRGB_eetf_internal(rgb_linear, maxRGB1_linear, maxRGB1_pq, Lw, Lmax);
}

float linear_to_hlg_channel(float u)
{
    float ln2_i = 1. / log(2.);
    float m = 0.17883277 / ln2_i;
    return (u <= (1. / 12.)) ? sqrt(3. * u) : ((log2((12. * u) - 0.28466892) * m) + 0.55991073);
}

vec3 linear_to_hlg(vec3 rgb, float Lw)
{
    rgb = clamp(rgb, 0.0, 1.0);

    if (Lw > 1000.)
    {
        rgb = maxRGB_eetf_linear_to_linear(rgb, Lw, 1000.);
        rgb *= 10000. / Lw;
    }
    else
    {
        rgb *= 10.;
    }

    float Yd = dot(rgb, vec3(0.2627, 0.678, 0.0593));

     
    Yd = max(6.10352e-5, Yd);

    rgb *= pow(Yd, -1. / 6.);
    return vec3(linear_to_hlg_channel(rgb.r), linear_to_hlg_channel(rgb.g), linear_to_hlg_channel(rgb.b));
}

float PS_P416_HLG_Y_709_2020(FragPos frag_in)
{
    vec3 rgb = obs_load_2d(image, ivec3(frag_in.pos.xy, 0)).rgb * sdr_white_nits_over_maximum;
    rgb = rec709_to_rec2020(rgb);
    rgb = linear_to_hlg(rgb, hdr_lw);
    float y = dot(color_vec0.xyz, rgb) + color_vec0.w;
    return y;
}

float _main_wrap(FragPos frag_in)
{
    return PS_P416_HLG_Y_709_2020(frag_in);
}

void main(void)
{
    FragPos frag_in;
    frag_in.pos = gl_FragCoord;

    _pixel_shader_attrib0 = _main_wrap(frag_in);
}

info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}




out gl_PerVertex {
    vec4 gl_Position;
};

struct FragPos {
    vec4 pos;
};

FragPos VSPos(uint id)
{
    float idHigh = float(id >> 1);
    float idLow = float(id & uint(1));

    float x = idHigh * 4.0 - 1.0;
    float y = idLow * 4.0 - 1.0;

    FragPos vert_out;
    vert_out.pos = vec4(x, y, 0.0, 1.0);
    return vert_out;
}

FragPos _main_wrap(uint id)
{
    return VSPos(id);
}

void main(void)
{
    uint id;
    FragPos outputval;

    id = uint(gl_VertexID);

    outputval = _main_wrap(id);

    gl_Position = outputval.pos;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform sampler2D image;
uniform vec4 color_vec0;


out float _pixel_shader_attrib0;

struct FragPos {
    vec4 pos;
};

float srgb_linear_to_nonlinear_channel(float u)
{
    return (u <= 0.0031308) ? (12.92 * u) : ((1.055 * pow(u, 1. / 2.4)) - 0.055);
}

vec3 srgb_linear_to_nonlinear(vec3 v)
{
    return vec3(srgb_linear_to_nonlinear_channel(v.r), srgb_linear_to_nonlinear_channel(v.g), srgb_linear_to_nonlinear_channel(v.b));
}

float PS_P416_SRGB_Y(FragPos frag_in)
{
    vec3 rgb = obs_load_2d(image, ivec3(frag_in.pos.xy, 0)).rgb;
    rgb = srgb_linear_to_nonlinear(rgb);
    float y = dot(color_vec0.xyz, rgb) + color_vec0.w;
    return y;
}

float _main_wrap(FragPos frag_in)
{
    return PS_P416_SRGB_Y(frag_in);
}

void main(void)
{
    FragPos frag_in;
    frag_in.pos = gl_FragCoord;

    _pixel_shader_attrib0 = _main_wrap(frag_in);
}

info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}




out gl_PerVertex {
    vec4 gl_Position;
};

struct FragPos {
    vec4 pos;
};

FragPos VSPos(uint id)
{
    float idHigh = float(id >> 1);
    float idLow = float(id & uint(1));

    float x = idHigh * 4.0 - 1.0;
    float y = idLow * 4.0 - 1.0;

    FragPos vert_out;
    vert_out.pos = vec4(x, y, 0.0, 1.0);
    return vert_out;
}

FragPos _main_wrap(uint id)
{
    return VSPos(id);
}

void main(void)
{
    uint id;
    FragPos outputval;

    id = uint(gl_VertexID);

    outputval = _main_wrap(id);

    gl_Position = outputval.pos;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform sampler2D image;
uniform vec4 color_vec1;
uniform vec4 color_vec2;


out vec2 _pixel_shader_attrib0;

struct FragPos {
    vec4 pos;
};

vec3 rec709_to_rec2020(vec3 v)
{
    float r = dot(v, vec3(0.62740389593469903, 0.32928303837788370, 0.043313065687417225));
    float g = dot(v, vec3(0.069097289358232075, 0.91954039507545871, 0.011362315566309178));
    float b = dot(v, vec3(0.016391438875150280, 0.088013307877225749, 0.89559525324762401));
    return vec3(r, g, b);
}

float linear_to_st2084_channel(float x)
{
    float c = pow(abs(x), 0.1593017578);
    return pow((0.8359375 + 18.8515625 * c) / (1. + 18.6875 * c), 78.84375);
}

vec3 linear_to_st2084(vec3 rgb)
{
    return vec3(linear_to_st2084_channel(rgb.r), linear_to_st2084_channel(rgb.g), linear_to_st2084_channel(rgb.b));
}

vec2 PS_P416_PQ_UV_709_2020(FragPos frag_in)
{
    vec3 rgb = obs_load_2d(image, ivec3(frag_in.pos.xy, 0)).rgb;
    rgb = rec709_to_rec2020(rgb);
    rgb = linear_to_st2084(rgb);
    float u = dot(color_vec1.xyz, rgb) + color_vec1.w;
    float v = dot(color_vec2.xyz, rgb) + color_vec2.w;
    vec2 uv = vec2(u, v);
    return uv;
}

vec2 _main_wrap(FragPos frag_in)
{
    return PS_P416_PQ_UV_709_2020(frag_in);
}

void main(void)
{
    FragPos frag_in;
    frag_in.pos = gl_FragCoord;

    _pixel_shader_attrib0 = _main_wrap(frag_in);
}

info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}




out gl_PerVertex {
    vec4 gl_Position;
};

struct FragPos {
    vec4 pos;
};

FragPos VSPos(uint id)
{
    float idHigh = float(id >> 1);
    float idLow = float(id & uint(1));

    float x = idHigh * 4.0 - 1.0;
    float y = idLow * 4.0 - 1.0;

    FragPos vert_out;
    vert_out.pos = vec4(x, y, 0.0, 1.0);
    return vert_out;
}

FragPos _main_wrap(uint id)
{
    return VSPos(id);
}

void main(void)
{
    uint id;
    FragPos outputval;

    id = uint(gl_VertexID);

    outputval = _main_wrap(id);

    gl_Position = outputval.pos;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform sampler2D image;
uniform float hdr_lw;
uniform vec4 color_vec1;
uniform vec4 color_vec2;


out vec2 _pixel_shader_attrib0;

struct FragPos {
    vec4 pos;
};

vec3 rec709_to_rec2020(vec3 v)
{
    float r = dot(v, vec3(0.62740389593469903, 0.32928303837788370, 0.043313065687417225));
    float g = dot(v, vec3(0.069097289358232075, 0.91954039507545871, 0.011362315566309178));
    float b = dot(v, vec3(0.016391438875150280, 0.088013307877225749, 0.89559525324762401));
    return vec3(r, g, b);
}

float linear_to_st2084_channel(float x)
{
    float c = pow(abs(x), 0.1593017578);
    return pow((0.8359375 + 18.8515625 * c) / (1. + 18.6875 * c), 78.84375);
}

float eetf_0_Lmax(float maxRGB1_pq, float Lw, float Lmax)
{
    float Lw_pq = linear_to_st2084_channel(Lw / 10000.);
    float E1 = clamp(maxRGB1_pq / Lw_pq, 0.0, 1.0);
    float maxLum = linear_to_st2084_channel(Lmax / 10000.) / Lw_pq;
    float KS = (1.5 * maxLum) - 0.5;
    float E2 = E1;
    if (E1 > KS)
    {
        float T = (E1 - KS) / (1. - KS);
        float Tsquared = T * T;
        float Tcubed = Tsquared * T;
        float P = (2. * Tcubed - 3. * Tsquared + 1.) * KS + (Tcubed - 2. * Tsquared + T) * (1. - KS) + (-2. * Tcubed + 3. * Tsquared) * maxLum;
        E2 = P;
    }
    float E3 = E2;
    float E4 = E3 * Lw_pq;
    return E4;
}

float st2084_to_linear_channel(float u)
{
    float c = pow(abs(u), 1. / 78.84375);
    return pow(abs(max(c - 0.8359375, 0.) / (18.8515625 - 18.6875 * c)), 1. / 0.1593017578);
}

vec3 maxRGB_eetf_internal(vec3 rgb_linear, float maxRGB1_linear, float maxRGB1_pq, float Lw, float Lmax)
{
    float maxRGB2_pq = eetf_0_Lmax(maxRGB1_pq, Lw, Lmax);
    float maxRGB2_linear = st2084_to_linear_channel(maxRGB2_pq);

     
    maxRGB1_linear = max(6.10352e-5, maxRGB1_linear);

    rgb_linear *= maxRGB2_linear / maxRGB1_linear;
    return rgb_linear;
}

vec3 maxRGB_eetf_linear_to_linear(vec3 rgb_linear, float Lw, float Lmax)
{
    float maxRGB1_linear = max(max(rgb_linear.r, rgb_linear.g), rgb_linear.b);
    float maxRGB1_pq = linear_to_st2084_channel(maxRGB1_linear);
    return maxRGB_eetf_internal(rgb_linear, maxRGB1_linear, maxRGB1_pq, Lw, Lmax);
}

float linear_to_hlg_channel(float u)
{
    float ln2_i = 1. / log(2.);
    float m = 0.17883277 / ln2_i;
    return (u <= (1. / 12.)) ? sqrt(3. * u) : ((log2((12. * u) - 0.28466892) * m) + 0.55991073);
}

vec3 linear_to_hlg(vec3 rgb, float Lw)
{
    rgb = clamp(rgb, 0.0, 1.0);

    if (Lw > 1000.)
    {
        rgb = maxRGB_eetf_linear_to_linear(rgb, Lw, 1000.);
        rgb *= 10000. / Lw;
    }
    else
    {
        rgb *= 10.;
    }

    float Yd = dot(rgb, vec3(0.2627, 0.678, 0.0593));

     
    Yd = max(6.10352e-5, Yd);

    rgb *= pow(Yd, -1. / 6.);
    return vec3(linear_to_hlg_channel(rgb.r), linear_to_hlg_channel(rgb.g), linear_to_hlg_channel(rgb.b));
}

vec2 PS_P416_HLG_UV_709_2020(FragPos frag_in)
{
    vec3 rgb = obs_load_2d(image, ivec3(frag_in.pos.xy, 0)).rgb;
    rgb = rec709_to_rec2020(rgb);
    rgb = linear_to_hlg(rgb, hdr_lw);
    float u = dot(color_vec1.xyz, rgb) + color_vec1.w;
    float v = dot(color_vec2.xyz, rgb) + color_vec2.w;
    vec2 uv = vec2(u, v);
    return uv;
}

vec2 _main_wrap(FragPos frag_in)
{
    return PS_P416_HLG_UV_709_2020(frag_in);
}

void main(void)
{
    FragPos frag_in;
    frag_in.pos = gl_FragCoord;

    _pixel_shader_attrib0 = _main_wrap(frag_in);
}

info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}




out gl_PerVertex {
    vec4 gl_Position;
};

struct FragPos {
    vec4 pos;
};

FragPos VSPos(uint id)
{
    float idHigh = float(id >> 1);
    float idLow = float(id & uint(1));

    float x = idHigh * 4.0 - 1.0;
    float y = idLow * 4.0 - 1.0;

    FragPos vert_out;
    vert_out.pos = vec4(x, y, 0.0, 1.0);
    return vert_out;
}

FragPos _main_wrap(uint id)
{
    return VSPos(id);
}

void main(void)
{
    uint id;
    FragPos outputval;

    id = uint(gl_VertexID);

    outputval = _main_wrap(id);

    gl_Position = outputval.pos;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform sampler2D image;
uniform vec4 color_vec1;
uniform vec4 color_vec2;


out vec2 _pixel_shader_attrib0;

struct FragPos {
    vec4 pos;
};

float srgb_linear_to_nonlinear_channel(float u)
{
    return (u <= 0.0031308) ? (12.92 * u) : ((1.055 * pow(u, 1. / 2.4)) - 0.055);
}

vec3 srgb_linear_to_nonlinear(vec3 v)
{
    return vec3(srgb_linear_to_nonlinear_channel(v.r), srgb_linear_to_nonlinear_channel(v.g), srgb_linear_to_nonlinear_channel(v.b));
}

vec2 PS_P416_SRGB_UV(FragPos frag_in)
{
    vec3 rgb = obs_load_2d(image, ivec3(frag_in.pos.xy, 0)).rgb;
    rgb = srgb_linear_to_nonlinear(rgb);
    float u = dot(color_vec1.xyz, rgb) + color_vec1.w;
    float v = dot(color_vec2.xyz, rgb) + color_vec2.w;
    vec2 uv = vec2(u, v);
    return uv;
}

vec2 _main_wrap(FragPos frag_in)
{
    return PS_P416_SRGB_UV(frag_in);
}

void main(void)
{
    FragPos frag_in;
    frag_in.pos = gl_FragCoord;

    _pixel_shader_attrib0 = _main_wrap(frag_in);
}

info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform float width_d2;
uniform float height;
uniform float width_x2_i;


out vec4 _vertex_shader_attrib0;

out gl_PerVertex {
    vec4 gl_Position;
};

struct VertTexTexPos {
    vec4 uvuv;
    vec4 pos;
};

VertTexTexPos VSPacked422Left_Reverse(uint id)
{
    float idHigh = float(id >> 1);
    float idLow = float(id & uint(1));

    float x = idHigh * 4. - 1.;
    float y = idLow * 4. - 1.;

    float u = idHigh * 2.;
    float v = idLow * 2.;
    v = obs_glsl_compile ? v : (1. - v);

    VertTexTexPos vert_out;
    vert_out.uvuv = vec4(width_d2 * u, height * v, u + width_x2_i, v);
    vert_out.pos = vec4(x, y, 0., 1.);
    return vert_out;
}

VertTexTexPos _main_wrap(uint id)
{
    return VSPacked422Left_Reverse(id);
}

void main(void)
{
    uint id;
    VertTexTexPos outputval;

    id = uint(gl_VertexID);

    outputval = _main_wrap(id);

    _vertex_shader_attrib0 = outputval.uvuv;
    gl_Position = outputval.pos;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform sampler2D image;
uniform vec3 color_range_min;
uniform vec3 color_range_max;
uniform vec4 color_vec0;
uniform vec4 color_vec1;
uniform vec4 color_vec2;

in vec4 _vertex_shader_attrib0;

out vec3 _pixel_shader_attrib0;

struct FragTexTex {
    vec4 uvuv;
};

vec3 YUV_to_RGB(vec3 yuv)
{
    yuv = clamp(yuv, color_range_min, color_range_max);
    float r = dot(color_vec0.xyz, yuv) + color_vec0.w;
    float g = dot(color_vec1.xyz, yuv) + color_vec1.w;
    float b = dot(color_vec2.xyz, yuv) + color_vec2.w;
    return vec3(r, g, b);
}

vec3 PSUYVY_Reverse(FragTexTex frag_in)
{
    vec2 y01 = obs_load_2d(image, ivec3(frag_in.uvuv.xy, 0)).yw;
    vec2 cbcr = texture(image, frag_in.uvuv.zw, 0).zx;
    float leftover = fract(frag_in.uvuv.x);
    float y = (leftover < 0.5) ? y01.x : y01.y;
    vec3 yuv = vec3(y, cbcr);
    vec3 rgb = YUV_to_RGB(yuv);
    return rgb;
}

vec3 _main_wrap(FragTexTex frag_in)
{
    return PSUYVY_Reverse(frag_in);
}

void main(void)
{
    FragTexTex frag_in;
    frag_in.uvuv = _vertex_shader_attrib0;

    _pixel_shader_attrib0 = _main_wrap(frag_in);
}

info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform float width_d2;
uniform float height;
uniform float width_x2_i;


out vec4 _vertex_shader_attrib0;

out gl_PerVertex {
    vec4 gl_Position;
};

struct VertTexTexPos {
    vec4 uvuv;
    vec4 pos;
};

VertTexTexPos VSPacked422Left_Reverse(uint id)
{
    float idHigh = float(id >> 1);
    float idLow = float(id & uint(1));

    float x = idHigh * 4. - 1.;
    float y = idLow * 4. - 1.;

    float u = idHigh * 2.;
    float v = idLow * 2.;
    v = obs_glsl_compile ? v : (1. - v);

    VertTexTexPos vert_out;
    vert_out.uvuv = vec4(width_d2 * u, height * v, u + width_x2_i, v);
    vert_out.pos = vec4(x, y, 0., 1.);
    return vert_out;
}

VertTexTexPos _main_wrap(uint id)
{
    return VSPacked422Left_Reverse(id);
}

void main(void)
{
    uint id;
    VertTexTexPos outputval;

    id = uint(gl_VertexID);

    outputval = _main_wrap(id);

    _vertex_shader_attrib0 = outputval.uvuv;
    gl_Position = outputval.pos;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform sampler2D image;
uniform vec3 color_range_min;
uniform vec3 color_range_max;
uniform vec4 color_vec0;
uniform vec4 color_vec1;
uniform vec4 color_vec2;

in vec4 _vertex_shader_attrib0;

out vec3 _pixel_shader_attrib0;

struct FragTexTex {
    vec4 uvuv;
};

vec3 YUV_to_RGB(vec3 yuv)
{
    yuv = clamp(yuv, color_range_min, color_range_max);
    float r = dot(color_vec0.xyz, yuv) + color_vec0.w;
    float g = dot(color_vec1.xyz, yuv) + color_vec1.w;
    float b = dot(color_vec2.xyz, yuv) + color_vec2.w;
    return vec3(r, g, b);
}

vec3 PSYUY2_Reverse(FragTexTex frag_in)
{
    vec2 y01 = obs_load_2d(image, ivec3(frag_in.uvuv.xy, 0)).zx;
    vec2 cbcr = texture(image, frag_in.uvuv.zw, 0).yw;
    float leftover = fract(frag_in.uvuv.x);
    float y = (leftover < 0.5) ? y01.x : y01.y;
    vec3 yuv = vec3(y, cbcr);
    vec3 rgb = YUV_to_RGB(yuv);
    return rgb;
}

vec3 _main_wrap(FragTexTex frag_in)
{
    return PSYUY2_Reverse(frag_in);
}

void main(void)
{
    FragTexTex frag_in;
    frag_in.uvuv = _vertex_shader_attrib0;

    _pixel_shader_attrib0 = _main_wrap(frag_in);
}

info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform float width_d2;
uniform float height;
uniform float width_x2_i;


out vec4 _vertex_shader_attrib0;

out gl_PerVertex {
    vec4 gl_Position;
};

struct VertTexTexPos {
    vec4 uvuv;
    vec4 pos;
};

VertTexTexPos VSPacked422Left_Reverse(uint id)
{
    float idHigh = float(id >> 1);
    float idLow = float(id & uint(1));

    float x = idHigh * 4. - 1.;
    float y = idLow * 4. - 1.;

    float u = idHigh * 2.;
    float v = idLow * 2.;
    v = obs_glsl_compile ? v : (1. - v);

    VertTexTexPos vert_out;
    vert_out.uvuv = vec4(width_d2 * u, height * v, u + width_x2_i, v);
    vert_out.pos = vec4(x, y, 0., 1.);
    return vert_out;
}

VertTexTexPos _main_wrap(uint id)
{
    return VSPacked422Left_Reverse(id);
}

void main(void)
{
    uint id;
    VertTexTexPos outputval;

    id = uint(gl_VertexID);

    outputval = _main_wrap(id);

    _vertex_shader_attrib0 = outputval.uvuv;
    gl_Position = outputval.pos;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform sampler2D image;
uniform float hdr_lw;
uniform float hdr_lmax;
uniform float maximum_over_sdr_white_nits;
uniform vec3 color_range_min;
uniform vec3 color_range_max;
uniform vec4 color_vec0;
uniform vec4 color_vec1;
uniform vec4 color_vec2;

in vec4 _vertex_shader_attrib0;

out vec4 _pixel_shader_attrib0;

struct FragTexTex {
    vec4 uvuv;
};

vec3 YUV_to_RGB(vec3 yuv)
{
    yuv = clamp(yuv, color_range_min, color_range_max);
    float r = dot(color_vec0.xyz, yuv) + color_vec0.w;
    float g = dot(color_vec1.xyz, yuv) + color_vec1.w;
    float b = dot(color_vec2.xyz, yuv) + color_vec2.w;
    return vec3(r, g, b);
}

float st2084_to_linear_channel(float u)
{
    float c = pow(abs(u), 1. / 78.84375);
    return pow(abs(max(c - 0.8359375, 0.) / (18.8515625 - 18.6875 * c)), 1. / 0.1593017578);
}

vec3 st2084_to_linear(vec3 rgb)
{
    return vec3(st2084_to_linear_channel(rgb.r), st2084_to_linear_channel(rgb.g), st2084_to_linear_channel(rgb.b));
}

float linear_to_st2084_channel(float x)
{
    float c = pow(abs(x), 0.1593017578);
    return pow((0.8359375 + 18.8515625 * c) / (1. + 18.6875 * c), 78.84375);
}

float eetf_0_Lmax(float maxRGB1_pq, float Lw, float Lmax)
{
    float Lw_pq = linear_to_st2084_channel(Lw / 10000.);
    float E1 = clamp(maxRGB1_pq / Lw_pq, 0.0, 1.0);
    float maxLum = linear_to_st2084_channel(Lmax / 10000.) / Lw_pq;
    float KS = (1.5 * maxLum) - 0.5;
    float E2 = E1;
    if (E1 > KS)
    {
        float T = (E1 - KS) / (1. - KS);
        float Tsquared = T * T;
        float Tcubed = Tsquared * T;
        float P = (2. * Tcubed - 3. * Tsquared + 1.) * KS + (Tcubed - 2. * Tsquared + T) * (1. - KS) + (-2. * Tcubed + 3. * Tsquared) * maxLum;
        E2 = P;
    }
    float E3 = E2;
    float E4 = E3 * Lw_pq;
    return E4;
}

vec3 maxRGB_eetf_internal(vec3 rgb_linear, float maxRGB1_linear, float maxRGB1_pq, float Lw, float Lmax)
{
    float maxRGB2_pq = eetf_0_Lmax(maxRGB1_pq, Lw, Lmax);
    float maxRGB2_linear = st2084_to_linear_channel(maxRGB2_pq);

     
    maxRGB1_linear = max(6.10352e-5, maxRGB1_linear);

    rgb_linear *= maxRGB2_linear / maxRGB1_linear;
    return rgb_linear;
}

vec3 maxRGB_eetf_pq_to_linear(vec3 rgb_pq, float Lw, float Lmax)
{
    vec3 rgb_linear = st2084_to_linear(rgb_pq);
    float maxRGB1_linear = max(max(rgb_linear.r, rgb_linear.g), rgb_linear.b);
    float maxRGB1_pq = max(max(rgb_pq.r, rgb_pq.g), rgb_pq.b);
    return maxRGB_eetf_internal(rgb_linear, maxRGB1_linear, maxRGB1_pq, Lw, Lmax);
}

vec3 st2084_to_linear_eetf(vec3 rgb, float Lw, float Lmax)
{
    return (Lw > Lmax) ? maxRGB_eetf_pq_to_linear(rgb, Lw, Lmax) : st2084_to_linear(rgb);
}

vec3 rec2020_to_rec709(vec3 v)
{
    float r = dot(v, vec3(1.6604910021084345, -0.58764113878854951, -0.072849863319884883));
    float g = dot(v, vec3(-0.12455047452159074, 1.1328998971259603, -0.0083494226043694768));
    float b = dot(v, vec3(-0.018150763354905303, -0.10057889800800739, 1.1187296613629127));
    return vec3(r, g, b);
}

vec4 PSYUY2_PQ_Reverse(FragTexTex frag_in)
{
    vec2 y01 = obs_load_2d(image, ivec3(frag_in.uvuv.xy, 0)).zx;
    vec2 cbcr = texture(image, frag_in.uvuv.zw, 0).yw;
    float leftover = fract(frag_in.uvuv.x);
    float y = (leftover < 0.5) ? y01.x : y01.y;
    vec3 yuv = vec3(y, cbcr);
    vec3 pq = YUV_to_RGB(yuv);
    vec3 hdr2020 = st2084_to_linear_eetf(pq, hdr_lw, hdr_lmax) * maximum_over_sdr_white_nits;
    vec3 rgb = rec2020_to_rec709(hdr2020);
    return vec4(rgb, 1.);
}

vec4 _main_wrap(FragTexTex frag_in)
{
    return PSYUY2_PQ_Reverse(frag_in);
}

void main(void)
{
    FragTexTex frag_in;
    frag_in.uvuv = _vertex_shader_attrib0;

    _pixel_shader_attrib0 = _main_wrap(frag_in);
}

info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform float width_d2;
uniform float height;
uniform float width_x2_i;


out vec4 _vertex_shader_attrib0;

out gl_PerVertex {
    vec4 gl_Position;
};

struct VertTexTexPos {
    vec4 uvuv;
    vec4 pos;
};

VertTexTexPos VSPacked422Left_Reverse(uint id)
{
    float idHigh = float(id >> 1);
    float idLow = float(id & uint(1));

    float x = idHigh * 4. - 1.;
    float y = idLow * 4. - 1.;

    float u = idHigh * 2.;
    float v = idLow * 2.;
    v = obs_glsl_compile ? v : (1. - v);

    VertTexTexPos vert_out;
    vert_out.uvuv = vec4(width_d2 * u, height * v, u + width_x2_i, v);
    vert_out.pos = vec4(x, y, 0., 1.);
    return vert_out;
}

VertTexTexPos _main_wrap(uint id)
{
    return VSPacked422Left_Reverse(id);
}

void main(void)
{
    uint id;
    VertTexTexPos outputval;

    id = uint(gl_VertexID);

    outputval = _main_wrap(id);

    _vertex_shader_attrib0 = outputval.uvuv;
    gl_Position = outputval.pos;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform sampler2D image;
uniform float hlg_exponent;
uniform float maximum_over_sdr_white_nits;
uniform vec3 color_range_min;
uniform vec3 color_range_max;
uniform vec4 color_vec0;
uniform vec4 color_vec1;
uniform vec4 color_vec2;

in vec4 _vertex_shader_attrib0;

out vec4 _pixel_shader_attrib0;

struct FragTexTex {
    vec4 uvuv;
};

vec3 YUV_to_RGB(vec3 yuv)
{
    yuv = clamp(yuv, color_range_min, color_range_max);
    float r = dot(color_vec0.xyz, yuv) + color_vec0.w;
    float g = dot(color_vec1.xyz, yuv) + color_vec1.w;
    float b = dot(color_vec2.xyz, yuv) + color_vec2.w;
    return vec3(r, g, b);
}

float hlg_to_linear_channel(float u)
{
    float ln2_i = 1. / log(2.);
    float m = ln2_i / 0.17883277;
    float a = -ln2_i * 0.55991073 / 0.17883277;
    return (u <= 0.5) ? ((u * u) / 3.) : ((exp2(u * m + a) + 0.28466892) / 12.);
}

vec3 hlg_to_linear(vec3 v, float exponent)
{
    vec3 rgb = vec3(hlg_to_linear_channel(v.r), hlg_to_linear_channel(v.g), hlg_to_linear_channel(v.b));
    float Ys = dot(rgb, vec3(0.2627, 0.678, 0.0593));
    rgb *= pow(Ys, exponent);
    return rgb;
}

vec3 rec2020_to_rec709(vec3 v)
{
    float r = dot(v, vec3(1.6604910021084345, -0.58764113878854951, -0.072849863319884883));
    float g = dot(v, vec3(-0.12455047452159074, 1.1328998971259603, -0.0083494226043694768));
    float b = dot(v, vec3(-0.018150763354905303, -0.10057889800800739, 1.1187296613629127));
    return vec3(r, g, b);
}

vec4 PSYUY2_HLG_Reverse(FragTexTex frag_in)
{
    vec2 y01 = obs_load_2d(image, ivec3(frag_in.uvuv.xy, 0)).zx;
    vec2 cbcr = texture(image, frag_in.uvuv.zw, 0).yw;
    float leftover = fract(frag_in.uvuv.x);
    float y = (leftover < 0.5) ? y01.x : y01.y;
    vec3 yuv = vec3(y, cbcr);
    vec3 hlg = YUV_to_RGB(yuv);
    vec3 hdr2020 = hlg_to_linear(hlg, hlg_exponent) * maximum_over_sdr_white_nits;
    vec3 rgb = rec2020_to_rec709(hdr2020);
    return vec4(rgb, 1.);
}

vec4 _main_wrap(FragTexTex frag_in)
{
    return PSYUY2_HLG_Reverse(frag_in);
}

void main(void)
{
    FragTexTex frag_in;
    frag_in.uvuv = _vertex_shader_attrib0;

    _pixel_shader_attrib0 = _main_wrap(frag_in);
}

info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform float width_d2;
uniform float height;
uniform float width_x2_i;


out vec4 _vertex_shader_attrib0;

out gl_PerVertex {
    vec4 gl_Position;
};

struct VertTexTexPos {
    vec4 uvuv;
    vec4 pos;
};

VertTexTexPos VSPacked422Left_Reverse(uint id)
{
    float idHigh = float(id >> 1);
    float idLow = float(id & uint(1));

    float x = idHigh * 4. - 1.;
    float y = idLow * 4. - 1.;

    float u = idHigh * 2.;
    float v = idLow * 2.;
    v = obs_glsl_compile ? v : (1. - v);

    VertTexTexPos vert_out;
    vert_out.uvuv = vec4(width_d2 * u, height * v, u + width_x2_i, v);
    vert_out.pos = vec4(x, y, 0., 1.);
    return vert_out;
}

VertTexTexPos _main_wrap(uint id)
{
    return VSPacked422Left_Reverse(id);
}

void main(void)
{
    uint id;
    VertTexTexPos outputval;

    id = uint(gl_VertexID);

    outputval = _main_wrap(id);

    _vertex_shader_attrib0 = outputval.uvuv;
    gl_Position = outputval.pos;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform sampler2D image;
uniform vec3 color_range_min;
uniform vec3 color_range_max;
uniform vec4 color_vec0;
uniform vec4 color_vec1;
uniform vec4 color_vec2;

in vec4 _vertex_shader_attrib0;

out vec3 _pixel_shader_attrib0;

struct FragTexTex {
    vec4 uvuv;
};

vec3 YUV_to_RGB(vec3 yuv)
{
    yuv = clamp(yuv, color_range_min, color_range_max);
    float r = dot(color_vec0.xyz, yuv) + color_vec0.w;
    float g = dot(color_vec1.xyz, yuv) + color_vec1.w;
    float b = dot(color_vec2.xyz, yuv) + color_vec2.w;
    return vec3(r, g, b);
}

vec3 PSYVYU_Reverse(FragTexTex frag_in)
{
    vec2 y01 = obs_load_2d(image, ivec3(frag_in.uvuv.xy, 0)).zx;
    vec2 cbcr = texture(image, frag_in.uvuv.zw, 0).wy;
    float leftover = fract(frag_in.uvuv.x);
    float y = (leftover < 0.5) ? y01.x : y01.y;
    vec3 yuv = vec3(y, cbcr);
    vec3 rgb = YUV_to_RGB(yuv);
    return rgb;
}

vec3 _main_wrap(FragTexTex frag_in)
{
    return PSYVYU_Reverse(frag_in);
}

void main(void)
{
    FragTexTex frag_in;
    frag_in.uvuv = _vertex_shader_attrib0;

    _pixel_shader_attrib0 = _main_wrap(frag_in);
}

info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform float width_x2_i;


out vec2 _vertex_shader_attrib0;

out gl_PerVertex {
    vec4 gl_Position;
};

struct VertTexPos {
    vec2 uv;
    vec4 pos;
};

VertTexPos VS420Left_Reverse(uint id)
{
    float idHigh = float(id >> 1);
    float idLow = float(id & uint(1));

    float x = idHigh * 4. - 1.;
    float y = idLow * 4. - 1.;

    float u = idHigh * 2. + width_x2_i;
    float v = idLow * 2.;
    v = obs_glsl_compile ? v : (1. - v);

    VertTexPos vert_out;
    vert_out.uv = vec2(u, v);
    vert_out.pos = vec4(x, y, 0., 1.);
    return vert_out;
}

VertTexPos _main_wrap(uint id)
{
    return VS420Left_Reverse(id);
}

void main(void)
{
    uint id;
    VertTexPos outputval;

    id = uint(gl_VertexID);

    outputval = _main_wrap(id);

    _vertex_shader_attrib0 = outputval.uv;
    gl_Position = outputval.pos;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform sampler2D image;
uniform sampler2D image1;
uniform sampler2D image2;
uniform vec3 color_range_min;
uniform vec3 color_range_max;
uniform vec4 color_vec0;
uniform vec4 color_vec1;
uniform vec4 color_vec2;

in vec2 _vertex_shader_attrib0;

out vec3 _pixel_shader_attrib0;

struct VertTexPos {
    vec2 uv;
    vec4 pos;
};

vec3 YUV_to_RGB(vec3 yuv)
{
    yuv = clamp(yuv, color_range_min, color_range_max);
    float r = dot(color_vec0.xyz, yuv) + color_vec0.w;
    float g = dot(color_vec1.xyz, yuv) + color_vec1.w;
    float b = dot(color_vec2.xyz, yuv) + color_vec2.w;
    return vec3(r, g, b);
}

vec3 PSPlanar420_Reverse(VertTexPos frag_in)
{
    float y = obs_load_2d(image, ivec3(frag_in.pos.xy, 0)).x;
    float cb = texture(image1, frag_in.uv).x;
    float cr = texture(image2, frag_in.uv).x;
    vec3 yuv = vec3(y, cb, cr);
    vec3 rgb = YUV_to_RGB(yuv);
    return rgb;
}

vec3 _main_wrap(VertTexPos frag_in)
{
    return PSPlanar420_Reverse(frag_in);
}

void main(void)
{
    VertTexPos frag_in;
    frag_in.uv = _vertex_shader_attrib0;
    frag_in.pos = gl_FragCoord;

    _pixel_shader_attrib0 = _main_wrap(frag_in);
}

info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform float width_x2_i;
uniform float height_x2_i;


out vec2 _vertex_shader_attrib0;

out gl_PerVertex {
    vec4 gl_Position;
};

struct VertTexPos {
    vec2 uv;
    vec4 pos;
};

VertTexPos VS420TopLeft_Reverse(uint id)
{
    float idHigh = float(id >> 1);
    float idLow = float(id & uint(1));

    float x = idHigh * 4. - 1.;
    float y = idLow * 4. - 1.;

    float u = idHigh * 2. + width_x2_i;
    float v = idLow * 2. - height_x2_i;
    v = obs_glsl_compile ? v : (1. - v);

    VertTexPos vert_out;
    vert_out.uv = vec2(u, v);
    vert_out.pos = vec4(x, y, 0., 1.);
    return vert_out;
}

VertTexPos _main_wrap(uint id)
{
    return VS420TopLeft_Reverse(id);
}

void main(void)
{
    uint id;
    VertTexPos outputval;

    id = uint(gl_VertexID);

    outputval = _main_wrap(id);

    _vertex_shader_attrib0 = outputval.uv;
    gl_Position = outputval.pos;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform sampler2D image;
uniform sampler2D image1;
uniform sampler2D image2;
uniform float hdr_lw;
uniform float hdr_lmax;
uniform float maximum_over_sdr_white_nits;
uniform vec3 color_range_min;
uniform vec3 color_range_max;
uniform vec4 color_vec0;
uniform vec4 color_vec1;
uniform vec4 color_vec2;

in vec2 _vertex_shader_attrib0;

out vec4 _pixel_shader_attrib0;

struct VertTexPos {
    vec2 uv;
    vec4 pos;
};

vec3 YUV_to_RGB(vec3 yuv)
{
    yuv = clamp(yuv, color_range_min, color_range_max);
    float r = dot(color_vec0.xyz, yuv) + color_vec0.w;
    float g = dot(color_vec1.xyz, yuv) + color_vec1.w;
    float b = dot(color_vec2.xyz, yuv) + color_vec2.w;
    return vec3(r, g, b);
}

float st2084_to_linear_channel(float u)
{
    float c = pow(abs(u), 1. / 78.84375);
    return pow(abs(max(c - 0.8359375, 0.) / (18.8515625 - 18.6875 * c)), 1. / 0.1593017578);
}

vec3 st2084_to_linear(vec3 rgb)
{
    return vec3(st2084_to_linear_channel(rgb.r), st2084_to_linear_channel(rgb.g), st2084_to_linear_channel(rgb.b));
}

float linear_to_st2084_channel(float x)
{
    float c = pow(abs(x), 0.1593017578);
    return pow((0.8359375 + 18.8515625 * c) / (1. + 18.6875 * c), 78.84375);
}

float eetf_0_Lmax(float maxRGB1_pq, float Lw, float Lmax)
{
    float Lw_pq = linear_to_st2084_channel(Lw / 10000.);
    float E1 = clamp(maxRGB1_pq / Lw_pq, 0.0, 1.0);
    float maxLum = linear_to_st2084_channel(Lmax / 10000.) / Lw_pq;
    float KS = (1.5 * maxLum) - 0.5;
    float E2 = E1;
    if (E1 > KS)
    {
        float T = (E1 - KS) / (1. - KS);
        float Tsquared = T * T;
        float Tcubed = Tsquared * T;
        float P = (2. * Tcubed - 3. * Tsquared + 1.) * KS + (Tcubed - 2. * Tsquared + T) * (1. - KS) + (-2. * Tcubed + 3. * Tsquared) * maxLum;
        E2 = P;
    }
    float E3 = E2;
    float E4 = E3 * Lw_pq;
    return E4;
}

vec3 maxRGB_eetf_internal(vec3 rgb_linear, float maxRGB1_linear, float maxRGB1_pq, float Lw, float Lmax)
{
    float maxRGB2_pq = eetf_0_Lmax(maxRGB1_pq, Lw, Lmax);
    float maxRGB2_linear = st2084_to_linear_channel(maxRGB2_pq);

     
    maxRGB1_linear = max(6.10352e-5, maxRGB1_linear);

    rgb_linear *= maxRGB2_linear / maxRGB1_linear;
    return rgb_linear;
}

vec3 maxRGB_eetf_pq_to_linear(vec3 rgb_pq, float Lw, float Lmax)
{
    vec3 rgb_linear = st2084_to_linear(rgb_pq);
    float maxRGB1_linear = max(max(rgb_linear.r, rgb_linear.g), rgb_linear.b);
    float maxRGB1_pq = max(max(rgb_pq.r, rgb_pq.g), rgb_pq.b);
    return maxRGB_eetf_internal(rgb_linear, maxRGB1_linear, maxRGB1_pq, Lw, Lmax);
}

vec3 st2084_to_linear_eetf(vec3 rgb, float Lw, float Lmax)
{
    return (Lw > Lmax) ? maxRGB_eetf_pq_to_linear(rgb, Lw, Lmax) : st2084_to_linear(rgb);
}

vec3 rec2020_to_rec709(vec3 v)
{
    float r = dot(v, vec3(1.6604910021084345, -0.58764113878854951, -0.072849863319884883));
    float g = dot(v, vec3(-0.12455047452159074, 1.1328998971259603, -0.0083494226043694768));
    float b = dot(v, vec3(-0.018150763354905303, -0.10057889800800739, 1.1187296613629127));
    return vec3(r, g, b);
}

vec4 PSPlanar420_PQ_Reverse(VertTexPos frag_in)
{
    float y = obs_load_2d(image, ivec3(frag_in.pos.xy, 0)).x;
    float cb = texture(image1, frag_in.uv).x;
    float cr = texture(image2, frag_in.uv).x;
    vec3 yuv = vec3(y, cb, cr);
    vec3 pq = YUV_to_RGB(yuv);
    vec3 hdr2020 = st2084_to_linear_eetf(pq, hdr_lw, hdr_lmax) * maximum_over_sdr_white_nits;
    vec3 rgb = rec2020_to_rec709(hdr2020);
    return vec4(rgb, 1.);
}

vec4 _main_wrap(VertTexPos frag_in)
{
    return PSPlanar420_PQ_Reverse(frag_in);
}

void main(void)
{
    VertTexPos frag_in;
    frag_in.uv = _vertex_shader_attrib0;
    frag_in.pos = gl_FragCoord;

    _pixel_shader_attrib0 = _main_wrap(frag_in);
}

info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform float width_x2_i;
uniform float height_x2_i;


out vec2 _vertex_shader_attrib0;

out gl_PerVertex {
    vec4 gl_Position;
};

struct VertTexPos {
    vec2 uv;
    vec4 pos;
};

VertTexPos VS420TopLeft_Reverse(uint id)
{
    float idHigh = float(id >> 1);
    float idLow = float(id & uint(1));

    float x = idHigh * 4. - 1.;
    float y = idLow * 4. - 1.;

    float u = idHigh * 2. + width_x2_i;
    float v = idLow * 2. - height_x2_i;
    v = obs_glsl_compile ? v : (1. - v);

    VertTexPos vert_out;
    vert_out.uv = vec2(u, v);
    vert_out.pos = vec4(x, y, 0., 1.);
    return vert_out;
}

VertTexPos _main_wrap(uint id)
{
    return VS420TopLeft_Reverse(id);
}

void main(void)
{
    uint id;
    VertTexPos outputval;

    id = uint(gl_VertexID);

    outputval = _main_wrap(id);

    _vertex_shader_attrib0 = outputval.uv;
    gl_Position = outputval.pos;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform sampler2D image;
uniform sampler2D image1;
uniform sampler2D image2;
uniform float hlg_exponent;
uniform float maximum_over_sdr_white_nits;
uniform vec3 color_range_min;
uniform vec3 color_range_max;
uniform vec4 color_vec0;
uniform vec4 color_vec1;
uniform vec4 color_vec2;

in vec2 _vertex_shader_attrib0;

out vec4 _pixel_shader_attrib0;

struct VertTexPos {
    vec2 uv;
    vec4 pos;
};

vec3 YUV_to_RGB(vec3 yuv)
{
    yuv = clamp(yuv, color_range_min, color_range_max);
    float r = dot(color_vec0.xyz, yuv) + color_vec0.w;
    float g = dot(color_vec1.xyz, yuv) + color_vec1.w;
    float b = dot(color_vec2.xyz, yuv) + color_vec2.w;
    return vec3(r, g, b);
}

float hlg_to_linear_channel(float u)
{
    float ln2_i = 1. / log(2.);
    float m = ln2_i / 0.17883277;
    float a = -ln2_i * 0.55991073 / 0.17883277;
    return (u <= 0.5) ? ((u * u) / 3.) : ((exp2(u * m + a) + 0.28466892) / 12.);
}

vec3 hlg_to_linear(vec3 v, float exponent)
{
    vec3 rgb = vec3(hlg_to_linear_channel(v.r), hlg_to_linear_channel(v.g), hlg_to_linear_channel(v.b));
    float Ys = dot(rgb, vec3(0.2627, 0.678, 0.0593));
    rgb *= pow(Ys, exponent);
    return rgb;
}

vec3 rec2020_to_rec709(vec3 v)
{
    float r = dot(v, vec3(1.6604910021084345, -0.58764113878854951, -0.072849863319884883));
    float g = dot(v, vec3(-0.12455047452159074, 1.1328998971259603, -0.0083494226043694768));
    float b = dot(v, vec3(-0.018150763354905303, -0.10057889800800739, 1.1187296613629127));
    return vec3(r, g, b);
}

vec4 PSPlanar420_HLG_Reverse(VertTexPos frag_in)
{
    float y = obs_load_2d(image, ivec3(frag_in.pos.xy, 0)).x;
    float cb = texture(image1, frag_in.uv).x;
    float cr = texture(image2, frag_in.uv).x;
    vec3 yuv = vec3(y, cb, cr);
    vec3 hlg = YUV_to_RGB(yuv);
    vec3 hdr2020 = hlg_to_linear(hlg, hlg_exponent) * maximum_over_sdr_white_nits;
    vec3 rgb = rec2020_to_rec709(hdr2020);
    return vec4(rgb, 1.);
}

vec4 _main_wrap(VertTexPos frag_in)
{
    return PSPlanar420_HLG_Reverse(frag_in);
}

void main(void)
{
    VertTexPos frag_in;
    frag_in.uv = _vertex_shader_attrib0;
    frag_in.pos = gl_FragCoord;

    _pixel_shader_attrib0 = _main_wrap(frag_in);
}

info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform float width_x2_i;


out vec2 _vertex_shader_attrib0;

out gl_PerVertex {
    vec4 gl_Position;
};

struct VertTexPos {
    vec2 uv;
    vec4 pos;
};

VertTexPos VS420Left_Reverse(uint id)
{
    float idHigh = float(id >> 1);
    float idLow = float(id & uint(1));

    float x = idHigh * 4. - 1.;
    float y = idLow * 4. - 1.;

    float u = idHigh * 2. + width_x2_i;
    float v = idLow * 2.;
    v = obs_glsl_compile ? v : (1. - v);

    VertTexPos vert_out;
    vert_out.uv = vec2(u, v);
    vert_out.pos = vec4(x, y, 0., 1.);
    return vert_out;
}

VertTexPos _main_wrap(uint id)
{
    return VS420Left_Reverse(id);
}

void main(void)
{
    uint id;
    VertTexPos outputval;

    id = uint(gl_VertexID);

    outputval = _main_wrap(id);

    _vertex_shader_attrib0 = outputval.uv;
    gl_Position = outputval.pos;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform sampler2D image;
uniform sampler2D image3;
uniform sampler2D image1;
uniform sampler2D image2;
uniform vec3 color_range_min;
uniform vec3 color_range_max;
uniform vec4 color_vec0;
uniform vec4 color_vec1;
uniform vec4 color_vec2;

in vec2 _vertex_shader_attrib0;

out vec4 _pixel_shader_attrib0;

struct VertTexPos {
    vec2 uv;
    vec4 pos;
};

vec3 YUV_to_RGB(vec3 yuv)
{
    yuv = clamp(yuv, color_range_min, color_range_max);
    float r = dot(color_vec0.xyz, yuv) + color_vec0.w;
    float g = dot(color_vec1.xyz, yuv) + color_vec1.w;
    float b = dot(color_vec2.xyz, yuv) + color_vec2.w;
    return vec3(r, g, b);
}

vec4 PSPlanar420A_Reverse(VertTexPos frag_in)
{
    ivec3 xy0_luma = ivec3(frag_in.pos.xy, 0);
    float y = obs_load_2d(image, xy0_luma).x;
    float alpha = obs_load_2d(image3, xy0_luma).x;
    float cb = texture(image1, frag_in.uv).x;
    float cr = texture(image2, frag_in.uv).x;
    vec3 yuv = vec3(y, cb, cr);
    vec4 rgba = vec4(YUV_to_RGB(yuv), alpha);
    return rgba;
}

vec4 _main_wrap(VertTexPos frag_in)
{
    return PSPlanar420A_Reverse(frag_in);
}

void main(void)
{
    VertTexPos frag_in;
    frag_in.uv = _vertex_shader_attrib0;
    frag_in.pos = gl_FragCoord;

    _pixel_shader_attrib0 = _main_wrap(frag_in);
}

info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform float width_x2_i;


out vec2 _vertex_shader_attrib0;

out gl_PerVertex {
    vec4 gl_Position;
};

struct VertTexPos {
    vec2 uv;
    vec4 pos;
};

VertTexPos VS422Left_Reverse(uint id)
{
    float idHigh = float(id >> 1);
    float idLow = float(id & uint(1));

    float x = idHigh * 4.0 - 1.0;
    float y = idLow * 4.0 - 1.0;

    float u = idHigh * 2.0 + width_x2_i;
    float v = obs_glsl_compile ? (idLow * 2.0) : (1.0 - idLow * 2.0);

    VertTexPos vert_out;
    vert_out.uv = vec2(u, v);
    vert_out.pos = vec4(x, y, 0.0, 1.0);
    return vert_out;
}

VertTexPos _main_wrap(uint id)
{
    return VS422Left_Reverse(id);
}

void main(void)
{
    uint id;
    VertTexPos outputval;

    id = uint(gl_VertexID);

    outputval = _main_wrap(id);

    _vertex_shader_attrib0 = outputval.uv;
    gl_Position = outputval.pos;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform sampler2D image;
uniform sampler2D image1;
uniform sampler2D image2;
uniform vec3 color_range_min;
uniform vec3 color_range_max;
uniform vec4 color_vec0;
uniform vec4 color_vec1;
uniform vec4 color_vec2;

in vec2 _vertex_shader_attrib0;

out vec3 _pixel_shader_attrib0;

struct VertTexPos {
    vec2 uv;
    vec4 pos;
};

vec3 YUV_to_RGB(vec3 yuv)
{
    yuv = clamp(yuv, color_range_min, color_range_max);
    float r = dot(color_vec0.xyz, yuv) + color_vec0.w;
    float g = dot(color_vec1.xyz, yuv) + color_vec1.w;
    float b = dot(color_vec2.xyz, yuv) + color_vec2.w;
    return vec3(r, g, b);
}

vec3 PSPlanar422_Reverse(VertTexPos frag_in)
{
    float y = obs_load_2d(image, ivec3(frag_in.pos.xy, 0)).x;
    float cb = texture(image1, frag_in.uv).x;
    float cr = texture(image2, frag_in.uv).x;
    vec3 yuv = vec3(y, cb, cr);
    vec3 rgb = YUV_to_RGB(yuv);
    return rgb;
}

vec3 _main_wrap(VertTexPos frag_in)
{
    return PSPlanar422_Reverse(frag_in);
}

void main(void)
{
    VertTexPos frag_in;
    frag_in.uv = _vertex_shader_attrib0;
    frag_in.pos = gl_FragCoord;

    _pixel_shader_attrib0 = _main_wrap(frag_in);
}

info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform float width_x2_i;


out vec2 _vertex_shader_attrib0;

out gl_PerVertex {
    vec4 gl_Position;
};

struct VertTexPos {
    vec2 uv;
    vec4 pos;
};

VertTexPos VS422Left_Reverse(uint id)
{
    float idHigh = float(id >> 1);
    float idLow = float(id & uint(1));

    float x = idHigh * 4.0 - 1.0;
    float y = idLow * 4.0 - 1.0;

    float u = idHigh * 2.0 + width_x2_i;
    float v = obs_glsl_compile ? (idLow * 2.0) : (1.0 - idLow * 2.0);

    VertTexPos vert_out;
    vert_out.uv = vec2(u, v);
    vert_out.pos = vec4(x, y, 0.0, 1.0);
    return vert_out;
}

VertTexPos _main_wrap(uint id)
{
    return VS422Left_Reverse(id);
}

void main(void)
{
    uint id;
    VertTexPos outputval;

    id = uint(gl_VertexID);

    outputval = _main_wrap(id);

    _vertex_shader_attrib0 = outputval.uv;
    gl_Position = outputval.pos;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform sampler2D image;
uniform sampler2D image1;
uniform sampler2D image2;
uniform vec3 color_range_min;
uniform vec3 color_range_max;
uniform vec4 color_vec0;
uniform vec4 color_vec1;
uniform vec4 color_vec2;

in vec2 _vertex_shader_attrib0;

out vec4 _pixel_shader_attrib0;

struct VertTexPos {
    vec2 uv;
    vec4 pos;
};

vec3 YUV_to_RGB(vec3 yuv)
{
    yuv = clamp(yuv, color_range_min, color_range_max);
    float r = dot(color_vec0.xyz, yuv) + color_vec0.w;
    float g = dot(color_vec1.xyz, yuv) + color_vec1.w;
    float b = dot(color_vec2.xyz, yuv) + color_vec2.w;
    return vec3(r, g, b);
}

float srgb_nonlinear_to_linear_channel(float u)
{
    return (u <= 0.04045) ? (u / 12.92) : pow((u + 0.055) / 1.055, 2.4);
}

vec3 srgb_nonlinear_to_linear(vec3 v)
{
    return vec3(srgb_nonlinear_to_linear_channel(v.r), srgb_nonlinear_to_linear_channel(v.g), srgb_nonlinear_to_linear_channel(v.b));
}

vec4 PSPlanar422_10LE_Reverse(VertTexPos frag_in)
{
    float y = obs_load_2d(image, ivec3(frag_in.pos.xy, 0)).x;
    float cb = texture(image1, frag_in.uv).x;
    float cr = texture(image2, frag_in.uv).x;
    vec3 yuv = vec3(y, cb, cr);
    yuv *= 65535. / 1023.;
    vec3 rgb = YUV_to_RGB(yuv);
    rgb = srgb_nonlinear_to_linear(rgb);
    return vec4(rgb, 1.);
}

vec4 _main_wrap(VertTexPos frag_in)
{
    return PSPlanar422_10LE_Reverse(frag_in);
}

void main(void)
{
    VertTexPos frag_in;
    frag_in.uv = _vertex_shader_attrib0;
    frag_in.pos = gl_FragCoord;

    _pixel_shader_attrib0 = _main_wrap(frag_in);
}

info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform float width_x2_i;


out vec2 _vertex_shader_attrib0;

out gl_PerVertex {
    vec4 gl_Position;
};

struct VertTexPos {
    vec2 uv;
    vec4 pos;
};

VertTexPos VS422Left_Reverse(uint id)
{
    float idHigh = float(id >> 1);
    float idLow = float(id & uint(1));

    float x = idHigh * 4.0 - 1.0;
    float y = idLow * 4.0 - 1.0;

    float u = idHigh * 2.0 + width_x2_i;
    float v = obs_glsl_compile ? (idLow * 2.0) : (1.0 - idLow * 2.0);

    VertTexPos vert_out;
    vert_out.uv = vec2(u, v);
    vert_out.pos = vec4(x, y, 0.0, 1.0);
    return vert_out;
}

VertTexPos _main_wrap(uint id)
{
    return VS422Left_Reverse(id);
}

void main(void)
{
    uint id;
    VertTexPos outputval;

    id = uint(gl_VertexID);

    outputval = _main_wrap(id);

    _vertex_shader_attrib0 = outputval.uv;
    gl_Position = outputval.pos;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform sampler2D image;
uniform sampler2D image1;
uniform sampler2D image2;
uniform float hdr_lw;
uniform float hdr_lmax;
uniform float maximum_over_sdr_white_nits;
uniform vec3 color_range_min;
uniform vec3 color_range_max;
uniform vec4 color_vec0;
uniform vec4 color_vec1;
uniform vec4 color_vec2;

in vec2 _vertex_shader_attrib0;

out vec4 _pixel_shader_attrib0;

struct VertTexPos {
    vec2 uv;
    vec4 pos;
};

vec3 YUV_to_RGB(vec3 yuv)
{
    yuv = clamp(yuv, color_range_min, color_range_max);
    float r = dot(color_vec0.xyz, yuv) + color_vec0.w;
    float g = dot(color_vec1.xyz, yuv) + color_vec1.w;
    float b = dot(color_vec2.xyz, yuv) + color_vec2.w;
    return vec3(r, g, b);
}

float st2084_to_linear_channel(float u)
{
    float c = pow(abs(u), 1. / 78.84375);
    return pow(abs(max(c - 0.8359375, 0.) / (18.8515625 - 18.6875 * c)), 1. / 0.1593017578);
}

vec3 st2084_to_linear(vec3 rgb)
{
    return vec3(st2084_to_linear_channel(rgb.r), st2084_to_linear_channel(rgb.g), st2084_to_linear_channel(rgb.b));
}

float linear_to_st2084_channel(float x)
{
    float c = pow(abs(x), 0.1593017578);
    return pow((0.8359375 + 18.8515625 * c) / (1. + 18.6875 * c), 78.84375);
}

float eetf_0_Lmax(float maxRGB1_pq, float Lw, float Lmax)
{
    float Lw_pq = linear_to_st2084_channel(Lw / 10000.);
    float E1 = clamp(maxRGB1_pq / Lw_pq, 0.0, 1.0);
    float maxLum = linear_to_st2084_channel(Lmax / 10000.) / Lw_pq;
    float KS = (1.5 * maxLum) - 0.5;
    float E2 = E1;
    if (E1 > KS)
    {
        float T = (E1 - KS) / (1. - KS);
        float Tsquared = T * T;
        float Tcubed = Tsquared * T;
        float P = (2. * Tcubed - 3. * Tsquared + 1.) * KS + (Tcubed - 2. * Tsquared + T) * (1. - KS) + (-2. * Tcubed + 3. * Tsquared) * maxLum;
        E2 = P;
    }
    float E3 = E2;
    float E4 = E3 * Lw_pq;
    return E4;
}

vec3 maxRGB_eetf_internal(vec3 rgb_linear, float maxRGB1_linear, float maxRGB1_pq, float Lw, float Lmax)
{
    float maxRGB2_pq = eetf_0_Lmax(maxRGB1_pq, Lw, Lmax);
    float maxRGB2_linear = st2084_to_linear_channel(maxRGB2_pq);

     
    maxRGB1_linear = max(6.10352e-5, maxRGB1_linear);

    rgb_linear *= maxRGB2_linear / maxRGB1_linear;
    return rgb_linear;
}

vec3 maxRGB_eetf_pq_to_linear(vec3 rgb_pq, float Lw, float Lmax)
{
    vec3 rgb_linear = st2084_to_linear(rgb_pq);
    float maxRGB1_linear = max(max(rgb_linear.r, rgb_linear.g), rgb_linear.b);
    float maxRGB1_pq = max(max(rgb_pq.r, rgb_pq.g), rgb_pq.b);
    return maxRGB_eetf_internal(rgb_linear, maxRGB1_linear, maxRGB1_pq, Lw, Lmax);
}

vec3 st2084_to_linear_eetf(vec3 rgb, float Lw, float Lmax)
{
    return (Lw > Lmax) ? maxRGB_eetf_pq_to_linear(rgb, Lw, Lmax) : st2084_to_linear(rgb);
}

vec3 rec2020_to_rec709(vec3 v)
{
    float r = dot(v, vec3(1.6604910021084345, -0.58764113878854951, -0.072849863319884883));
    float g = dot(v, vec3(-0.12455047452159074, 1.1328998971259603, -0.0083494226043694768));
    float b = dot(v, vec3(-0.018150763354905303, -0.10057889800800739, 1.1187296613629127));
    return vec3(r, g, b);
}

vec4 PSPlanar422_10LE_PQ_Reverse(VertTexPos frag_in)
{
    float y = obs_load_2d(image, ivec3(frag_in.pos.xy, 0)).x;
    float cb = texture(image1, frag_in.uv).x;
    float cr = texture(image2, frag_in.uv).x;
    vec3 yuv = vec3(y, cb, cr);
    yuv *= 65535. / 1023.;
    vec3 pq = YUV_to_RGB(yuv);
    vec3 hdr2020 = st2084_to_linear_eetf(pq, hdr_lw, hdr_lmax) * maximum_over_sdr_white_nits;
    vec3 rgb = rec2020_to_rec709(hdr2020);
    return vec4(rgb, 1.);
}

vec4 _main_wrap(VertTexPos frag_in)
{
    return PSPlanar422_10LE_PQ_Reverse(frag_in);
}

void main(void)
{
    VertTexPos frag_in;
    frag_in.uv = _vertex_shader_attrib0;
    frag_in.pos = gl_FragCoord;

    _pixel_shader_attrib0 = _main_wrap(frag_in);
}

info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform float width_x2_i;


out vec2 _vertex_shader_attrib0;

out gl_PerVertex {
    vec4 gl_Position;
};

struct VertTexPos {
    vec2 uv;
    vec4 pos;
};

VertTexPos VS422Left_Reverse(uint id)
{
    float idHigh = float(id >> 1);
    float idLow = float(id & uint(1));

    float x = idHigh * 4.0 - 1.0;
    float y = idLow * 4.0 - 1.0;

    float u = idHigh * 2.0 + width_x2_i;
    float v = obs_glsl_compile ? (idLow * 2.0) : (1.0 - idLow * 2.0);

    VertTexPos vert_out;
    vert_out.uv = vec2(u, v);
    vert_out.pos = vec4(x, y, 0.0, 1.0);
    return vert_out;
}

VertTexPos _main_wrap(uint id)
{
    return VS422Left_Reverse(id);
}

void main(void)
{
    uint id;
    VertTexPos outputval;

    id = uint(gl_VertexID);

    outputval = _main_wrap(id);

    _vertex_shader_attrib0 = outputval.uv;
    gl_Position = outputval.pos;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform sampler2D image;
uniform sampler2D image1;
uniform sampler2D image2;
uniform float hlg_exponent;
uniform float maximum_over_sdr_white_nits;
uniform vec3 color_range_min;
uniform vec3 color_range_max;
uniform vec4 color_vec0;
uniform vec4 color_vec1;
uniform vec4 color_vec2;

in vec2 _vertex_shader_attrib0;

out vec4 _pixel_shader_attrib0;

struct VertTexPos {
    vec2 uv;
    vec4 pos;
};

vec3 YUV_to_RGB(vec3 yuv)
{
    yuv = clamp(yuv, color_range_min, color_range_max);
    float r = dot(color_vec0.xyz, yuv) + color_vec0.w;
    float g = dot(color_vec1.xyz, yuv) + color_vec1.w;
    float b = dot(color_vec2.xyz, yuv) + color_vec2.w;
    return vec3(r, g, b);
}

float hlg_to_linear_channel(float u)
{
    float ln2_i = 1. / log(2.);
    float m = ln2_i / 0.17883277;
    float a = -ln2_i * 0.55991073 / 0.17883277;
    return (u <= 0.5) ? ((u * u) / 3.) : ((exp2(u * m + a) + 0.28466892) / 12.);
}

vec3 hlg_to_linear(vec3 v, float exponent)
{
    vec3 rgb = vec3(hlg_to_linear_channel(v.r), hlg_to_linear_channel(v.g), hlg_to_linear_channel(v.b));
    float Ys = dot(rgb, vec3(0.2627, 0.678, 0.0593));
    rgb *= pow(Ys, exponent);
    return rgb;
}

vec3 rec2020_to_rec709(vec3 v)
{
    float r = dot(v, vec3(1.6604910021084345, -0.58764113878854951, -0.072849863319884883));
    float g = dot(v, vec3(-0.12455047452159074, 1.1328998971259603, -0.0083494226043694768));
    float b = dot(v, vec3(-0.018150763354905303, -0.10057889800800739, 1.1187296613629127));
    return vec3(r, g, b);
}

vec4 PSPlanar422_10LE_HLG_Reverse(VertTexPos frag_in)
{
    float y = obs_load_2d(image, ivec3(frag_in.pos.xy, 0)).x;
    float cb = texture(image1, frag_in.uv).x;
    float cr = texture(image2, frag_in.uv).x;
    vec3 yuv = vec3(y, cb, cr);
    yuv *= 65535. / 1023.;
    vec3 hlg = YUV_to_RGB(yuv);
    vec3 hdr2020 = hlg_to_linear(hlg, hlg_exponent) * maximum_over_sdr_white_nits;
    vec3 rgb = rec2020_to_rec709(hdr2020);
    return vec4(rgb, 1.);
}

vec4 _main_wrap(VertTexPos frag_in)
{
    return PSPlanar422_10LE_HLG_Reverse(frag_in);
}

void main(void)
{
    VertTexPos frag_in;
    frag_in.uv = _vertex_shader_attrib0;
    frag_in.pos = gl_FragCoord;

    _pixel_shader_attrib0 = _main_wrap(frag_in);
}

info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform float width_x2_i;


out vec2 _vertex_shader_attrib0;

out gl_PerVertex {
    vec4 gl_Position;
};

struct VertTexPos {
    vec2 uv;
    vec4 pos;
};

VertTexPos VS422Left_Reverse(uint id)
{
    float idHigh = float(id >> 1);
    float idLow = float(id & uint(1));

    float x = idHigh * 4.0 - 1.0;
    float y = idLow * 4.0 - 1.0;

    float u = idHigh * 2.0 + width_x2_i;
    float v = obs_glsl_compile ? (idLow * 2.0) : (1.0 - idLow * 2.0);

    VertTexPos vert_out;
    vert_out.uv = vec2(u, v);
    vert_out.pos = vec4(x, y, 0.0, 1.0);
    return vert_out;
}

VertTexPos _main_wrap(uint id)
{
    return VS422Left_Reverse(id);
}

void main(void)
{
    uint id;
    VertTexPos outputval;

    id = uint(gl_VertexID);

    outputval = _main_wrap(id);

    _vertex_shader_attrib0 = outputval.uv;
    gl_Position = outputval.pos;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform sampler2D image;
uniform sampler2D image3;
uniform sampler2D image1;
uniform sampler2D image2;
uniform vec3 color_range_min;
uniform vec3 color_range_max;
uniform vec4 color_vec0;
uniform vec4 color_vec1;
uniform vec4 color_vec2;

in vec2 _vertex_shader_attrib0;

out vec4 _pixel_shader_attrib0;

struct VertTexPos {
    vec2 uv;
    vec4 pos;
};

vec3 YUV_to_RGB(vec3 yuv)
{
    yuv = clamp(yuv, color_range_min, color_range_max);
    float r = dot(color_vec0.xyz, yuv) + color_vec0.w;
    float g = dot(color_vec1.xyz, yuv) + color_vec1.w;
    float b = dot(color_vec2.xyz, yuv) + color_vec2.w;
    return vec3(r, g, b);
}

vec4 PSPlanar422A_Reverse(VertTexPos frag_in)
{
    ivec3 xy0_luma = ivec3(frag_in.pos.xy, 0);
    float y = obs_load_2d(image, xy0_luma).x;
    float alpha = obs_load_2d(image3, xy0_luma).x;
    float cb = texture(image1, frag_in.uv).x;
    float cr = texture(image2, frag_in.uv).x;
    vec3 yuv = vec3(y, cb, cr);
    vec4 rgba = vec4(YUV_to_RGB(yuv), alpha);
    return rgba;
}

vec4 _main_wrap(VertTexPos frag_in)
{
    return PSPlanar422A_Reverse(frag_in);
}

void main(void)
{
    VertTexPos frag_in;
    frag_in.uv = _vertex_shader_attrib0;
    frag_in.pos = gl_FragCoord;

    _pixel_shader_attrib0 = _main_wrap(frag_in);
}

info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}




out gl_PerVertex {
    vec4 gl_Position;
};

struct FragPos {
    vec4 pos;
};

FragPos VSPos(uint id)
{
    float idHigh = float(id >> 1);
    float idLow = float(id & uint(1));

    float x = idHigh * 4.0 - 1.0;
    float y = idLow * 4.0 - 1.0;

    FragPos vert_out;
    vert_out.pos = vec4(x, y, 0.0, 1.0);
    return vert_out;
}

FragPos _main_wrap(uint id)
{
    return VSPos(id);
}

void main(void)
{
    uint id;
    FragPos outputval;

    id = uint(gl_VertexID);

    outputval = _main_wrap(id);

    gl_Position = outputval.pos;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform sampler2D image;
uniform sampler2D image1;
uniform sampler2D image2;
uniform vec3 color_range_min;
uniform vec3 color_range_max;
uniform vec4 color_vec0;
uniform vec4 color_vec1;
uniform vec4 color_vec2;


out vec3 _pixel_shader_attrib0;

struct FragPos {
    vec4 pos;
};

vec3 YUV_to_RGB(vec3 yuv)
{
    yuv = clamp(yuv, color_range_min, color_range_max);
    float r = dot(color_vec0.xyz, yuv) + color_vec0.w;
    float g = dot(color_vec1.xyz, yuv) + color_vec1.w;
    float b = dot(color_vec2.xyz, yuv) + color_vec2.w;
    return vec3(r, g, b);
}

vec3 PSPlanar444_Reverse(FragPos frag_in)
{
    ivec3 xy0 = ivec3(frag_in.pos.xy, 0);
    float y = obs_load_2d(image, xy0).x;
    float cb = obs_load_2d(image1, xy0).x;
    float cr = obs_load_2d(image2, xy0).x;
    vec3 yuv = vec3(y, cb, cr);
    vec3 rgb = YUV_to_RGB(yuv);
    return rgb;
}

vec3 _main_wrap(FragPos frag_in)
{
    return PSPlanar444_Reverse(frag_in);
}

void main(void)
{
    FragPos frag_in;
    frag_in.pos = gl_FragCoord;

    _pixel_shader_attrib0 = _main_wrap(frag_in);
}

info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}




out gl_PerVertex {
    vec4 gl_Position;
};

struct FragPos {
    vec4 pos;
};

FragPos VSPos(uint id)
{
    float idHigh = float(id >> 1);
    float idLow = float(id & uint(1));

    float x = idHigh * 4.0 - 1.0;
    float y = idLow * 4.0 - 1.0;

    FragPos vert_out;
    vert_out.pos = vec4(x, y, 0.0, 1.0);
    return vert_out;
}

FragPos _main_wrap(uint id)
{
    return VSPos(id);
}

void main(void)
{
    uint id;
    FragPos outputval;

    id = uint(gl_VertexID);

    outputval = _main_wrap(id);

    gl_Position = outputval.pos;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform sampler2D image;
uniform sampler2D image1;
uniform sampler2D image2;
uniform vec3 color_range_min;
uniform vec3 color_range_max;
uniform vec4 color_vec0;
uniform vec4 color_vec1;
uniform vec4 color_vec2;


out vec4 _pixel_shader_attrib0;

struct FragPos {
    vec4 pos;
};

vec3 YUV_to_RGB(vec3 yuv)
{
    yuv = clamp(yuv, color_range_min, color_range_max);
    float r = dot(color_vec0.xyz, yuv) + color_vec0.w;
    float g = dot(color_vec1.xyz, yuv) + color_vec1.w;
    float b = dot(color_vec2.xyz, yuv) + color_vec2.w;
    return vec3(r, g, b);
}

float srgb_nonlinear_to_linear_channel(float u)
{
    return (u <= 0.04045) ? (u / 12.92) : pow((u + 0.055) / 1.055, 2.4);
}

vec3 srgb_nonlinear_to_linear(vec3 v)
{
    return vec3(srgb_nonlinear_to_linear_channel(v.r), srgb_nonlinear_to_linear_channel(v.g), srgb_nonlinear_to_linear_channel(v.b));
}

vec4 PSPlanar444_12LE_Reverse(FragPos frag_in)
{
    ivec3 xy0 = ivec3(frag_in.pos.xy, 0);
    float y = obs_load_2d(image, xy0).x;
    float cb = obs_load_2d(image1, xy0).x;
    float cr = obs_load_2d(image2, xy0).x;
    vec3 yuv = vec3(y, cb, cr);
    yuv *= 65535. / 4095.;
    vec3 rgb = YUV_to_RGB(yuv);
    rgb = srgb_nonlinear_to_linear(rgb);
    return vec4(rgb, 1.);
}

vec4 _main_wrap(FragPos frag_in)
{
    return PSPlanar444_12LE_Reverse(frag_in);
}

void main(void)
{
    FragPos frag_in;
    frag_in.pos = gl_FragCoord;

    _pixel_shader_attrib0 = _main_wrap(frag_in);
}

info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}




out gl_PerVertex {
    vec4 gl_Position;
};

struct FragPos {
    vec4 pos;
};

FragPos VSPos(uint id)
{
    float idHigh = float(id >> 1);
    float idLow = float(id & uint(1));

    float x = idHigh * 4.0 - 1.0;
    float y = idLow * 4.0 - 1.0;

    FragPos vert_out;
    vert_out.pos = vec4(x, y, 0.0, 1.0);
    return vert_out;
}

FragPos _main_wrap(uint id)
{
    return VSPos(id);
}

void main(void)
{
    uint id;
    FragPos outputval;

    id = uint(gl_VertexID);

    outputval = _main_wrap(id);

    gl_Position = outputval.pos;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform sampler2D image;
uniform sampler2D image1;
uniform sampler2D image2;
uniform float hdr_lw;
uniform float hdr_lmax;
uniform float maximum_over_sdr_white_nits;
uniform vec3 color_range_min;
uniform vec3 color_range_max;
uniform vec4 color_vec0;
uniform vec4 color_vec1;
uniform vec4 color_vec2;


out vec4 _pixel_shader_attrib0;

struct FragPos {
    vec4 pos;
};

vec3 YUV_to_RGB(vec3 yuv)
{
    yuv = clamp(yuv, color_range_min, color_range_max);
    float r = dot(color_vec0.xyz, yuv) + color_vec0.w;
    float g = dot(color_vec1.xyz, yuv) + color_vec1.w;
    float b = dot(color_vec2.xyz, yuv) + color_vec2.w;
    return vec3(r, g, b);
}

float st2084_to_linear_channel(float u)
{
    float c = pow(abs(u), 1. / 78.84375);
    return pow(abs(max(c - 0.8359375, 0.) / (18.8515625 - 18.6875 * c)), 1. / 0.1593017578);
}

vec3 st2084_to_linear(vec3 rgb)
{
    return vec3(st2084_to_linear_channel(rgb.r), st2084_to_linear_channel(rgb.g), st2084_to_linear_channel(rgb.b));
}

float linear_to_st2084_channel(float x)
{
    float c = pow(abs(x), 0.1593017578);
    return pow((0.8359375 + 18.8515625 * c) / (1. + 18.6875 * c), 78.84375);
}

float eetf_0_Lmax(float maxRGB1_pq, float Lw, float Lmax)
{
    float Lw_pq = linear_to_st2084_channel(Lw / 10000.);
    float E1 = clamp(maxRGB1_pq / Lw_pq, 0.0, 1.0);
    float maxLum = linear_to_st2084_channel(Lmax / 10000.) / Lw_pq;
    float KS = (1.5 * maxLum) - 0.5;
    float E2 = E1;
    if (E1 > KS)
    {
        float T = (E1 - KS) / (1. - KS);
        float Tsquared = T * T;
        float Tcubed = Tsquared * T;
        float P = (2. * Tcubed - 3. * Tsquared + 1.) * KS + (Tcubed - 2. * Tsquared + T) * (1. - KS) + (-2. * Tcubed + 3. * Tsquared) * maxLum;
        E2 = P;
    }
    float E3 = E2;
    float E4 = E3 * Lw_pq;
    return E4;
}

vec3 maxRGB_eetf_internal(vec3 rgb_linear, float maxRGB1_linear, float maxRGB1_pq, float Lw, float Lmax)
{
    float maxRGB2_pq = eetf_0_Lmax(maxRGB1_pq, Lw, Lmax);
    float maxRGB2_linear = st2084_to_linear_channel(maxRGB2_pq);

     
    maxRGB1_linear = max(6.10352e-5, maxRGB1_linear);

    rgb_linear *= maxRGB2_linear / maxRGB1_linear;
    return rgb_linear;
}

vec3 maxRGB_eetf_pq_to_linear(vec3 rgb_pq, float Lw, float Lmax)
{
    vec3 rgb_linear = st2084_to_linear(rgb_pq);
    float maxRGB1_linear = max(max(rgb_linear.r, rgb_linear.g), rgb_linear.b);
    float maxRGB1_pq = max(max(rgb_pq.r, rgb_pq.g), rgb_pq.b);
    return maxRGB_eetf_internal(rgb_linear, maxRGB1_linear, maxRGB1_pq, Lw, Lmax);
}

vec3 st2084_to_linear_eetf(vec3 rgb, float Lw, float Lmax)
{
    return (Lw > Lmax) ? maxRGB_eetf_pq_to_linear(rgb, Lw, Lmax) : st2084_to_linear(rgb);
}

vec3 rec2020_to_rec709(vec3 v)
{
    float r = dot(v, vec3(1.6604910021084345, -0.58764113878854951, -0.072849863319884883));
    float g = dot(v, vec3(-0.12455047452159074, 1.1328998971259603, -0.0083494226043694768));
    float b = dot(v, vec3(-0.018150763354905303, -0.10057889800800739, 1.1187296613629127));
    return vec3(r, g, b);
}

vec4 PSPlanar444_12LE_PQ_Reverse(FragPos frag_in)
{
    ivec3 xy0 = ivec3(frag_in.pos.xy, 0);
    float y = obs_load_2d(image, xy0).x;
    float cb = obs_load_2d(image1, xy0).x;
    float cr = obs_load_2d(image2, xy0).x;
    vec3 yuv = vec3(y, cb, cr);
    yuv *= 65535. / 4095;
    vec3 pq = YUV_to_RGB(yuv);
    vec3 hdr2020 = st2084_to_linear_eetf(pq, hdr_lw, hdr_lmax) * maximum_over_sdr_white_nits;
    vec3 rgb = rec2020_to_rec709(hdr2020);
    return vec4(rgb, 1.);
}

vec4 _main_wrap(FragPos frag_in)
{
    return PSPlanar444_12LE_PQ_Reverse(frag_in);
}

void main(void)
{
    FragPos frag_in;
    frag_in.pos = gl_FragCoord;

    _pixel_shader_attrib0 = _main_wrap(frag_in);
}

info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}




out gl_PerVertex {
    vec4 gl_Position;
};

struct FragPos {
    vec4 pos;
};

FragPos VSPos(uint id)
{
    float idHigh = float(id >> 1);
    float idLow = float(id & uint(1));

    float x = idHigh * 4.0 - 1.0;
    float y = idLow * 4.0 - 1.0;

    FragPos vert_out;
    vert_out.pos = vec4(x, y, 0.0, 1.0);
    return vert_out;
}

FragPos _main_wrap(uint id)
{
    return VSPos(id);
}

void main(void)
{
    uint id;
    FragPos outputval;

    id = uint(gl_VertexID);

    outputval = _main_wrap(id);

    gl_Position = outputval.pos;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform sampler2D image;
uniform sampler2D image1;
uniform sampler2D image2;
uniform float hlg_exponent;
uniform float maximum_over_sdr_white_nits;
uniform vec3 color_range_min;
uniform vec3 color_range_max;
uniform vec4 color_vec0;
uniform vec4 color_vec1;
uniform vec4 color_vec2;


out vec4 _pixel_shader_attrib0;

struct FragPos {
    vec4 pos;
};

vec3 YUV_to_RGB(vec3 yuv)
{
    yuv = clamp(yuv, color_range_min, color_range_max);
    float r = dot(color_vec0.xyz, yuv) + color_vec0.w;
    float g = dot(color_vec1.xyz, yuv) + color_vec1.w;
    float b = dot(color_vec2.xyz, yuv) + color_vec2.w;
    return vec3(r, g, b);
}

float hlg_to_linear_channel(float u)
{
    float ln2_i = 1. / log(2.);
    float m = ln2_i / 0.17883277;
    float a = -ln2_i * 0.55991073 / 0.17883277;
    return (u <= 0.5) ? ((u * u) / 3.) : ((exp2(u * m + a) + 0.28466892) / 12.);
}

vec3 hlg_to_linear(vec3 v, float exponent)
{
    vec3 rgb = vec3(hlg_to_linear_channel(v.r), hlg_to_linear_channel(v.g), hlg_to_linear_channel(v.b));
    float Ys = dot(rgb, vec3(0.2627, 0.678, 0.0593));
    rgb *= pow(Ys, exponent);
    return rgb;
}

vec3 rec2020_to_rec709(vec3 v)
{
    float r = dot(v, vec3(1.6604910021084345, -0.58764113878854951, -0.072849863319884883));
    float g = dot(v, vec3(-0.12455047452159074, 1.1328998971259603, -0.0083494226043694768));
    float b = dot(v, vec3(-0.018150763354905303, -0.10057889800800739, 1.1187296613629127));
    return vec3(r, g, b);
}

vec4 PSPlanar444_12LE_HLG_Reverse(FragPos frag_in)
{
    ivec3 xy0 = ivec3(frag_in.pos.xy, 0);
    float y = obs_load_2d(image, xy0).x;
    float cb = obs_load_2d(image1, xy0).x;
    float cr = obs_load_2d(image2, xy0).x;
    vec3 yuv = vec3(y, cb, cr);
    yuv *= 65535. / 4095;
    vec3 hlg = YUV_to_RGB(yuv);
    vec3 hdr2020 = hlg_to_linear(hlg, hlg_exponent) * maximum_over_sdr_white_nits;
    vec3 rgb = rec2020_to_rec709(hdr2020);
    return vec4(rgb, 1.);
}

vec4 _main_wrap(FragPos frag_in)
{
    return PSPlanar444_12LE_HLG_Reverse(frag_in);
}

void main(void)
{
    FragPos frag_in;
    frag_in.pos = gl_FragCoord;

    _pixel_shader_attrib0 = _main_wrap(frag_in);
}

info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}




out gl_PerVertex {
    vec4 gl_Position;
};

struct FragPos {
    vec4 pos;
};

FragPos VSPos(uint id)
{
    float idHigh = float(id >> 1);
    float idLow = float(id & uint(1));

    float x = idHigh * 4.0 - 1.0;
    float y = idLow * 4.0 - 1.0;

    FragPos vert_out;
    vert_out.pos = vec4(x, y, 0.0, 1.0);
    return vert_out;
}

FragPos _main_wrap(uint id)
{
    return VSPos(id);
}

void main(void)
{
    uint id;
    FragPos outputval;

    id = uint(gl_VertexID);

    outputval = _main_wrap(id);

    gl_Position = outputval.pos;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform sampler2D image;
uniform sampler2D image1;
uniform sampler2D image2;
uniform sampler2D image3;
uniform vec3 color_range_min;
uniform vec3 color_range_max;
uniform vec4 color_vec0;
uniform vec4 color_vec1;
uniform vec4 color_vec2;


out vec4 _pixel_shader_attrib0;

struct FragPos {
    vec4 pos;
};

vec3 YUV_to_RGB(vec3 yuv)
{
    yuv = clamp(yuv, color_range_min, color_range_max);
    float r = dot(color_vec0.xyz, yuv) + color_vec0.w;
    float g = dot(color_vec1.xyz, yuv) + color_vec1.w;
    float b = dot(color_vec2.xyz, yuv) + color_vec2.w;
    return vec3(r, g, b);
}

vec4 PSPlanar444A_Reverse(FragPos frag_in)
{
    ivec3 xy0 = ivec3(frag_in.pos.xy, 0);
    float y = obs_load_2d(image, xy0).x;
    float cb = obs_load_2d(image1, xy0).x;
    float cr = obs_load_2d(image2, xy0).x;
    float alpha = obs_load_2d(image3, xy0).x;
    vec3 yuv = vec3(y, cb, cr);
    vec4 rgba = vec4(YUV_to_RGB(yuv), alpha);
    return rgba;
}

vec4 _main_wrap(FragPos frag_in)
{
    return PSPlanar444A_Reverse(frag_in);
}

void main(void)
{
    FragPos frag_in;
    frag_in.pos = gl_FragCoord;

    _pixel_shader_attrib0 = _main_wrap(frag_in);
}

info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}




out gl_PerVertex {
    vec4 gl_Position;
};

struct FragPos {
    vec4 pos;
};

FragPos VSPos(uint id)
{
    float idHigh = float(id >> 1);
    float idLow = float(id & uint(1));

    float x = idHigh * 4.0 - 1.0;
    float y = idLow * 4.0 - 1.0;

    FragPos vert_out;
    vert_out.pos = vec4(x, y, 0.0, 1.0);
    return vert_out;
}

FragPos _main_wrap(uint id)
{
    return VSPos(id);
}

void main(void)
{
    uint id;
    FragPos outputval;

    id = uint(gl_VertexID);

    outputval = _main_wrap(id);

    gl_Position = outputval.pos;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform sampler2D image;
uniform sampler2D image1;
uniform sampler2D image2;
uniform sampler2D image3;
uniform vec3 color_range_min;
uniform vec3 color_range_max;
uniform vec4 color_vec0;
uniform vec4 color_vec1;
uniform vec4 color_vec2;


out vec4 _pixel_shader_attrib0;

struct FragPos {
    vec4 pos;
};

vec3 YUV_to_RGB(vec3 yuv)
{
    yuv = clamp(yuv, color_range_min, color_range_max);
    float r = dot(color_vec0.xyz, yuv) + color_vec0.w;
    float g = dot(color_vec1.xyz, yuv) + color_vec1.w;
    float b = dot(color_vec2.xyz, yuv) + color_vec2.w;
    return vec3(r, g, b);
}

float srgb_nonlinear_to_linear_channel(float u)
{
    return (u <= 0.04045) ? (u / 12.92) : pow((u + 0.055) / 1.055, 2.4);
}

vec3 srgb_nonlinear_to_linear(vec3 v)
{
    return vec3(srgb_nonlinear_to_linear_channel(v.r), srgb_nonlinear_to_linear_channel(v.g), srgb_nonlinear_to_linear_channel(v.b));
}

vec4 PSPlanar444A_12LE_Reverse(FragPos frag_in)
{
    ivec3 xy0 = ivec3(frag_in.pos.xy, 0);
    float y = obs_load_2d(image, xy0).x;
    float cb = obs_load_2d(image1, xy0).x;
    float cr = obs_load_2d(image2, xy0).x;
    float alpha = obs_load_2d(image3, xy0).x * 16.;
    vec3 yuv = vec3(y, cb, cr);
    yuv *= 65535. / 4095.;
    vec3 rgb = YUV_to_RGB(yuv);
    rgb = srgb_nonlinear_to_linear(rgb);
    return vec4(rgb, alpha);
}

vec4 _main_wrap(FragPos frag_in)
{
    return PSPlanar444A_12LE_Reverse(frag_in);
}

void main(void)
{
    FragPos frag_in;
    frag_in.pos = gl_FragCoord;

    _pixel_shader_attrib0 = _main_wrap(frag_in);
}

info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}




out gl_PerVertex {
    vec4 gl_Position;
};

struct FragPos {
    vec4 pos;
};

FragPos VSPos(uint id)
{
    float idHigh = float(id >> 1);
    float idLow = float(id & uint(1));

    float x = idHigh * 4.0 - 1.0;
    float y = idLow * 4.0 - 1.0;

    FragPos vert_out;
    vert_out.pos = vec4(x, y, 0.0, 1.0);
    return vert_out;
}

FragPos _main_wrap(uint id)
{
    return VSPos(id);
}

void main(void)
{
    uint id;
    FragPos outputval;

    id = uint(gl_VertexID);

    outputval = _main_wrap(id);

    gl_Position = outputval.pos;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform sampler2D image;
uniform vec3 color_range_min;
uniform vec3 color_range_max;
uniform vec4 color_vec0;
uniform vec4 color_vec1;
uniform vec4 color_vec2;


out vec4 _pixel_shader_attrib0;

struct FragPos {
    vec4 pos;
};

vec3 YUV_to_RGB(vec3 yuv)
{
    yuv = clamp(yuv, color_range_min, color_range_max);
    float r = dot(color_vec0.xyz, yuv) + color_vec0.w;
    float g = dot(color_vec1.xyz, yuv) + color_vec1.w;
    float b = dot(color_vec2.xyz, yuv) + color_vec2.w;
    return vec3(r, g, b);
}

vec4 PSAYUV_Reverse(FragPos frag_in)
{
    vec4 yuva = obs_load_2d(image, ivec3(frag_in.pos.xy, 0));
    vec4 rgba = vec4(YUV_to_RGB(yuva.xyz), yuva.a);
    return rgba;
}

vec4 _main_wrap(FragPos frag_in)
{
    return PSAYUV_Reverse(frag_in);
}

void main(void)
{
    FragPos frag_in;
    frag_in.pos = gl_FragCoord;

    _pixel_shader_attrib0 = _main_wrap(frag_in);
}

info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform float width_x2_i;


out vec2 _vertex_shader_attrib0;

out gl_PerVertex {
    vec4 gl_Position;
};

struct VertTexPos {
    vec2 uv;
    vec4 pos;
};

VertTexPos VS420Left_Reverse(uint id)
{
    float idHigh = float(id >> 1);
    float idLow = float(id & uint(1));

    float x = idHigh * 4. - 1.;
    float y = idLow * 4. - 1.;

    float u = idHigh * 2. + width_x2_i;
    float v = idLow * 2.;
    v = obs_glsl_compile ? v : (1. - v);

    VertTexPos vert_out;
    vert_out.uv = vec2(u, v);
    vert_out.pos = vec4(x, y, 0., 1.);
    return vert_out;
}

VertTexPos _main_wrap(uint id)
{
    return VS420Left_Reverse(id);
}

void main(void)
{
    uint id;
    VertTexPos outputval;

    id = uint(gl_VertexID);

    outputval = _main_wrap(id);

    _vertex_shader_attrib0 = outputval.uv;
    gl_Position = outputval.pos;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform sampler2D image;
uniform sampler2D image1;
uniform vec3 color_range_min;
uniform vec3 color_range_max;
uniform vec4 color_vec0;
uniform vec4 color_vec1;
uniform vec4 color_vec2;

in vec2 _vertex_shader_attrib0;

out vec3 _pixel_shader_attrib0;

struct VertTexPos {
    vec2 uv;
    vec4 pos;
};

vec3 YUV_to_RGB(vec3 yuv)
{
    yuv = clamp(yuv, color_range_min, color_range_max);
    float r = dot(color_vec0.xyz, yuv) + color_vec0.w;
    float g = dot(color_vec1.xyz, yuv) + color_vec1.w;
    float b = dot(color_vec2.xyz, yuv) + color_vec2.w;
    return vec3(r, g, b);
}

vec3 PSNV12_Reverse(VertTexPos frag_in)
{
    float y = obs_load_2d(image, ivec3(frag_in.pos.xy, 0)).x;
    vec2 cbcr = texture(image1, frag_in.uv).xy;
    vec3 yuv = vec3(y, cbcr);
    vec3 rgb = YUV_to_RGB(yuv);
    return rgb;
}

vec3 _main_wrap(VertTexPos frag_in)
{
    return PSNV12_Reverse(frag_in);
}

void main(void)
{
    VertTexPos frag_in;
    frag_in.uv = _vertex_shader_attrib0;
    frag_in.pos = gl_FragCoord;

    _pixel_shader_attrib0 = _main_wrap(frag_in);
}

info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform float width_x2_i;
uniform float height_x2_i;


out vec2 _vertex_shader_attrib0;

out gl_PerVertex {
    vec4 gl_Position;
};

struct VertTexPos {
    vec2 uv;
    vec4 pos;
};

VertTexPos VS420TopLeft_Reverse(uint id)
{
    float idHigh = float(id >> 1);
    float idLow = float(id & uint(1));

    float x = idHigh * 4. - 1.;
    float y = idLow * 4. - 1.;

    float u = idHigh * 2. + width_x2_i;
    float v = idLow * 2. - height_x2_i;
    v = obs_glsl_compile ? v : (1. - v);

    VertTexPos vert_out;
    vert_out.uv = vec2(u, v);
    vert_out.pos = vec4(x, y, 0., 1.);
    return vert_out;
}

VertTexPos _main_wrap(uint id)
{
    return VS420TopLeft_Reverse(id);
}

void main(void)
{
    uint id;
    VertTexPos outputval;

    id = uint(gl_VertexID);

    outputval = _main_wrap(id);

    _vertex_shader_attrib0 = outputval.uv;
    gl_Position = outputval.pos;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform sampler2D image;
uniform sampler2D image1;
uniform float hdr_lw;
uniform float hdr_lmax;
uniform float maximum_over_sdr_white_nits;
uniform vec3 color_range_min;
uniform vec3 color_range_max;
uniform vec4 color_vec0;
uniform vec4 color_vec1;
uniform vec4 color_vec2;

in vec2 _vertex_shader_attrib0;

out vec4 _pixel_shader_attrib0;

struct VertTexPos {
    vec2 uv;
    vec4 pos;
};

vec3 YUV_to_RGB(vec3 yuv)
{
    yuv = clamp(yuv, color_range_min, color_range_max);
    float r = dot(color_vec0.xyz, yuv) + color_vec0.w;
    float g = dot(color_vec1.xyz, yuv) + color_vec1.w;
    float b = dot(color_vec2.xyz, yuv) + color_vec2.w;
    return vec3(r, g, b);
}

float st2084_to_linear_channel(float u)
{
    float c = pow(abs(u), 1. / 78.84375);
    return pow(abs(max(c - 0.8359375, 0.) / (18.8515625 - 18.6875 * c)), 1. / 0.1593017578);
}

vec3 st2084_to_linear(vec3 rgb)
{
    return vec3(st2084_to_linear_channel(rgb.r), st2084_to_linear_channel(rgb.g), st2084_to_linear_channel(rgb.b));
}

float linear_to_st2084_channel(float x)
{
    float c = pow(abs(x), 0.1593017578);
    return pow((0.8359375 + 18.8515625 * c) / (1. + 18.6875 * c), 78.84375);
}

float eetf_0_Lmax(float maxRGB1_pq, float Lw, float Lmax)
{
    float Lw_pq = linear_to_st2084_channel(Lw / 10000.);
    float E1 = clamp(maxRGB1_pq / Lw_pq, 0.0, 1.0);
    float maxLum = linear_to_st2084_channel(Lmax / 10000.) / Lw_pq;
    float KS = (1.5 * maxLum) - 0.5;
    float E2 = E1;
    if (E1 > KS)
    {
        float T = (E1 - KS) / (1. - KS);
        float Tsquared = T * T;
        float Tcubed = Tsquared * T;
        float P = (2. * Tcubed - 3. * Tsquared + 1.) * KS + (Tcubed - 2. * Tsquared + T) * (1. - KS) + (-2. * Tcubed + 3. * Tsquared) * maxLum;
        E2 = P;
    }
    float E3 = E2;
    float E4 = E3 * Lw_pq;
    return E4;
}

vec3 maxRGB_eetf_internal(vec3 rgb_linear, float maxRGB1_linear, float maxRGB1_pq, float Lw, float Lmax)
{
    float maxRGB2_pq = eetf_0_Lmax(maxRGB1_pq, Lw, Lmax);
    float maxRGB2_linear = st2084_to_linear_channel(maxRGB2_pq);

     
    maxRGB1_linear = max(6.10352e-5, maxRGB1_linear);

    rgb_linear *= maxRGB2_linear / maxRGB1_linear;
    return rgb_linear;
}

vec3 maxRGB_eetf_pq_to_linear(vec3 rgb_pq, float Lw, float Lmax)
{
    vec3 rgb_linear = st2084_to_linear(rgb_pq);
    float maxRGB1_linear = max(max(rgb_linear.r, rgb_linear.g), rgb_linear.b);
    float maxRGB1_pq = max(max(rgb_pq.r, rgb_pq.g), rgb_pq.b);
    return maxRGB_eetf_internal(rgb_linear, maxRGB1_linear, maxRGB1_pq, Lw, Lmax);
}

vec3 st2084_to_linear_eetf(vec3 rgb, float Lw, float Lmax)
{
    return (Lw > Lmax) ? maxRGB_eetf_pq_to_linear(rgb, Lw, Lmax) : st2084_to_linear(rgb);
}

vec3 rec2020_to_rec709(vec3 v)
{
    float r = dot(v, vec3(1.6604910021084345, -0.58764113878854951, -0.072849863319884883));
    float g = dot(v, vec3(-0.12455047452159074, 1.1328998971259603, -0.0083494226043694768));
    float b = dot(v, vec3(-0.018150763354905303, -0.10057889800800739, 1.1187296613629127));
    return vec3(r, g, b);
}

vec4 PSNV12_PQ_Reverse(VertTexPos frag_in)
{
    float y = obs_load_2d(image, ivec3(frag_in.pos.xy, 0)).x;
    vec2 cbcr = texture(image1, frag_in.uv).xy;
    vec3 yuv = vec3(y, cbcr);
    vec3 pq = YUV_to_RGB(yuv);
    vec3 hdr2020 = st2084_to_linear_eetf(pq, hdr_lw, hdr_lmax) * maximum_over_sdr_white_nits;
    vec3 rgb = rec2020_to_rec709(hdr2020);
    return vec4(rgb, 1.);
}

vec4 _main_wrap(VertTexPos frag_in)
{
    return PSNV12_PQ_Reverse(frag_in);
}

void main(void)
{
    VertTexPos frag_in;
    frag_in.uv = _vertex_shader_attrib0;
    frag_in.pos = gl_FragCoord;

    _pixel_shader_attrib0 = _main_wrap(frag_in);
}

info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform float width_x2_i;
uniform float height_x2_i;


out vec2 _vertex_shader_attrib0;

out gl_PerVertex {
    vec4 gl_Position;
};

struct VertTexPos {
    vec2 uv;
    vec4 pos;
};

VertTexPos VS420TopLeft_Reverse(uint id)
{
    float idHigh = float(id >> 1);
    float idLow = float(id & uint(1));

    float x = idHigh * 4. - 1.;
    float y = idLow * 4. - 1.;

    float u = idHigh * 2. + width_x2_i;
    float v = idLow * 2. - height_x2_i;
    v = obs_glsl_compile ? v : (1. - v);

    VertTexPos vert_out;
    vert_out.uv = vec2(u, v);
    vert_out.pos = vec4(x, y, 0., 1.);
    return vert_out;
}

VertTexPos _main_wrap(uint id)
{
    return VS420TopLeft_Reverse(id);
}

void main(void)
{
    uint id;
    VertTexPos outputval;

    id = uint(gl_VertexID);

    outputval = _main_wrap(id);

    _vertex_shader_attrib0 = outputval.uv;
    gl_Position = outputval.pos;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform sampler2D image;
uniform sampler2D image1;
uniform float hlg_exponent;
uniform float maximum_over_sdr_white_nits;
uniform vec3 color_range_min;
uniform vec3 color_range_max;
uniform vec4 color_vec0;
uniform vec4 color_vec1;
uniform vec4 color_vec2;

in vec2 _vertex_shader_attrib0;

out vec4 _pixel_shader_attrib0;

struct VertTexPos {
    vec2 uv;
    vec4 pos;
};

vec3 YUV_to_RGB(vec3 yuv)
{
    yuv = clamp(yuv, color_range_min, color_range_max);
    float r = dot(color_vec0.xyz, yuv) + color_vec0.w;
    float g = dot(color_vec1.xyz, yuv) + color_vec1.w;
    float b = dot(color_vec2.xyz, yuv) + color_vec2.w;
    return vec3(r, g, b);
}

float hlg_to_linear_channel(float u)
{
    float ln2_i = 1. / log(2.);
    float m = ln2_i / 0.17883277;
    float a = -ln2_i * 0.55991073 / 0.17883277;
    return (u <= 0.5) ? ((u * u) / 3.) : ((exp2(u * m + a) + 0.28466892) / 12.);
}

vec3 hlg_to_linear(vec3 v, float exponent)
{
    vec3 rgb = vec3(hlg_to_linear_channel(v.r), hlg_to_linear_channel(v.g), hlg_to_linear_channel(v.b));
    float Ys = dot(rgb, vec3(0.2627, 0.678, 0.0593));
    rgb *= pow(Ys, exponent);
    return rgb;
}

vec3 rec2020_to_rec709(vec3 v)
{
    float r = dot(v, vec3(1.6604910021084345, -0.58764113878854951, -0.072849863319884883));
    float g = dot(v, vec3(-0.12455047452159074, 1.1328998971259603, -0.0083494226043694768));
    float b = dot(v, vec3(-0.018150763354905303, -0.10057889800800739, 1.1187296613629127));
    return vec3(r, g, b);
}

vec4 PSNV12_HLG_Reverse(VertTexPos frag_in)
{
    float y = obs_load_2d(image, ivec3(frag_in.pos.xy, 0)).x;
    vec2 cbcr = texture(image1, frag_in.uv).xy;
    vec3 yuv = vec3(y, cbcr);
    vec3 hlg = YUV_to_RGB(yuv);
    vec3 hdr2020 = hlg_to_linear(hlg, hlg_exponent) * maximum_over_sdr_white_nits;
    vec3 rgb = rec2020_to_rec709(hdr2020);
    return vec4(rgb, 1.);
}

vec4 _main_wrap(VertTexPos frag_in)
{
    return PSNV12_HLG_Reverse(frag_in);
}

void main(void)
{
    VertTexPos frag_in;
    frag_in.uv = _vertex_shader_attrib0;
    frag_in.pos = gl_FragCoord;

    _pixel_shader_attrib0 = _main_wrap(frag_in);
}

info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform float width_x2_i;


out vec2 _vertex_shader_attrib0;

out gl_PerVertex {
    vec4 gl_Position;
};

struct VertTexPos {
    vec2 uv;
    vec4 pos;
};

VertTexPos VS420Left_Reverse(uint id)
{
    float idHigh = float(id >> 1);
    float idLow = float(id & uint(1));

    float x = idHigh * 4. - 1.;
    float y = idLow * 4. - 1.;

    float u = idHigh * 2. + width_x2_i;
    float v = idLow * 2.;
    v = obs_glsl_compile ? v : (1. - v);

    VertTexPos vert_out;
    vert_out.uv = vec2(u, v);
    vert_out.pos = vec4(x, y, 0., 1.);
    return vert_out;
}

VertTexPos _main_wrap(uint id)
{
    return VS420Left_Reverse(id);
}

void main(void)
{
    uint id;
    VertTexPos outputval;

    id = uint(gl_VertexID);

    outputval = _main_wrap(id);

    _vertex_shader_attrib0 = outputval.uv;
    gl_Position = outputval.pos;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform sampler2D image;
uniform sampler2D image1;
uniform sampler2D image2;
uniform vec3 color_range_min;
uniform vec3 color_range_max;
uniform vec4 color_vec0;
uniform vec4 color_vec1;
uniform vec4 color_vec2;

in vec2 _vertex_shader_attrib0;

out vec4 _pixel_shader_attrib0;

struct VertTexPos {
    vec2 uv;
    vec4 pos;
};

vec3 YUV_to_RGB(vec3 yuv)
{
    yuv = clamp(yuv, color_range_min, color_range_max);
    float r = dot(color_vec0.xyz, yuv) + color_vec0.w;
    float g = dot(color_vec1.xyz, yuv) + color_vec1.w;
    float b = dot(color_vec2.xyz, yuv) + color_vec2.w;
    return vec3(r, g, b);
}

float srgb_nonlinear_to_linear_channel(float u)
{
    return (u <= 0.04045) ? (u / 12.92) : pow((u + 0.055) / 1.055, 2.4);
}

vec3 srgb_nonlinear_to_linear(vec3 v)
{
    return vec3(srgb_nonlinear_to_linear_channel(v.r), srgb_nonlinear_to_linear_channel(v.g), srgb_nonlinear_to_linear_channel(v.b));
}

vec4 PSI010_SRGB_Reverse(VertTexPos frag_in)
{
    float ratio = 65535. / 1023.;
    float y = obs_load_2d(image, ivec3(frag_in.pos.xy, 0)).x * ratio;
    float cb = texture(image1, frag_in.uv).x * ratio;
    float cr = texture(image2, frag_in.uv).x * ratio;
    vec3 yuv = vec3(y, cb, cr);
    vec3 rgb = YUV_to_RGB(yuv);
    rgb = srgb_nonlinear_to_linear(rgb);
    return vec4(rgb, 1.);
}

vec4 _main_wrap(VertTexPos frag_in)
{
    return PSI010_SRGB_Reverse(frag_in);
}

void main(void)
{
    VertTexPos frag_in;
    frag_in.uv = _vertex_shader_attrib0;
    frag_in.pos = gl_FragCoord;

    _pixel_shader_attrib0 = _main_wrap(frag_in);
}

info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform float width_x2_i;
uniform float height_x2_i;


out vec2 _vertex_shader_attrib0;

out gl_PerVertex {
    vec4 gl_Position;
};

struct VertTexPos {
    vec2 uv;
    vec4 pos;
};

VertTexPos VS420TopLeft_Reverse(uint id)
{
    float idHigh = float(id >> 1);
    float idLow = float(id & uint(1));

    float x = idHigh * 4. - 1.;
    float y = idLow * 4. - 1.;

    float u = idHigh * 2. + width_x2_i;
    float v = idLow * 2. - height_x2_i;
    v = obs_glsl_compile ? v : (1. - v);

    VertTexPos vert_out;
    vert_out.uv = vec2(u, v);
    vert_out.pos = vec4(x, y, 0., 1.);
    return vert_out;
}

VertTexPos _main_wrap(uint id)
{
    return VS420TopLeft_Reverse(id);
}

void main(void)
{
    uint id;
    VertTexPos outputval;

    id = uint(gl_VertexID);

    outputval = _main_wrap(id);

    _vertex_shader_attrib0 = outputval.uv;
    gl_Position = outputval.pos;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform sampler2D image;
uniform sampler2D image1;
uniform sampler2D image2;
uniform float hdr_lw;
uniform float hdr_lmax;
uniform float maximum_over_sdr_white_nits;
uniform vec3 color_range_min;
uniform vec3 color_range_max;
uniform vec4 color_vec0;
uniform vec4 color_vec1;
uniform vec4 color_vec2;

in vec2 _vertex_shader_attrib0;

out vec4 _pixel_shader_attrib0;

struct VertTexPos {
    vec2 uv;
    vec4 pos;
};

vec3 YUV_to_RGB(vec3 yuv)
{
    yuv = clamp(yuv, color_range_min, color_range_max);
    float r = dot(color_vec0.xyz, yuv) + color_vec0.w;
    float g = dot(color_vec1.xyz, yuv) + color_vec1.w;
    float b = dot(color_vec2.xyz, yuv) + color_vec2.w;
    return vec3(r, g, b);
}

float st2084_to_linear_channel(float u)
{
    float c = pow(abs(u), 1. / 78.84375);
    return pow(abs(max(c - 0.8359375, 0.) / (18.8515625 - 18.6875 * c)), 1. / 0.1593017578);
}

vec3 st2084_to_linear(vec3 rgb)
{
    return vec3(st2084_to_linear_channel(rgb.r), st2084_to_linear_channel(rgb.g), st2084_to_linear_channel(rgb.b));
}

float linear_to_st2084_channel(float x)
{
    float c = pow(abs(x), 0.1593017578);
    return pow((0.8359375 + 18.8515625 * c) / (1. + 18.6875 * c), 78.84375);
}

float eetf_0_Lmax(float maxRGB1_pq, float Lw, float Lmax)
{
    float Lw_pq = linear_to_st2084_channel(Lw / 10000.);
    float E1 = clamp(maxRGB1_pq / Lw_pq, 0.0, 1.0);
    float maxLum = linear_to_st2084_channel(Lmax / 10000.) / Lw_pq;
    float KS = (1.5 * maxLum) - 0.5;
    float E2 = E1;
    if (E1 > KS)
    {
        float T = (E1 - KS) / (1. - KS);
        float Tsquared = T * T;
        float Tcubed = Tsquared * T;
        float P = (2. * Tcubed - 3. * Tsquared + 1.) * KS + (Tcubed - 2. * Tsquared + T) * (1. - KS) + (-2. * Tcubed + 3. * Tsquared) * maxLum;
        E2 = P;
    }
    float E3 = E2;
    float E4 = E3 * Lw_pq;
    return E4;
}

vec3 maxRGB_eetf_internal(vec3 rgb_linear, float maxRGB1_linear, float maxRGB1_pq, float Lw, float Lmax)
{
    float maxRGB2_pq = eetf_0_Lmax(maxRGB1_pq, Lw, Lmax);
    float maxRGB2_linear = st2084_to_linear_channel(maxRGB2_pq);

     
    maxRGB1_linear = max(6.10352e-5, maxRGB1_linear);

    rgb_linear *= maxRGB2_linear / maxRGB1_linear;
    return rgb_linear;
}

vec3 maxRGB_eetf_pq_to_linear(vec3 rgb_pq, float Lw, float Lmax)
{
    vec3 rgb_linear = st2084_to_linear(rgb_pq);
    float maxRGB1_linear = max(max(rgb_linear.r, rgb_linear.g), rgb_linear.b);
    float maxRGB1_pq = max(max(rgb_pq.r, rgb_pq.g), rgb_pq.b);
    return maxRGB_eetf_internal(rgb_linear, maxRGB1_linear, maxRGB1_pq, Lw, Lmax);
}

vec3 st2084_to_linear_eetf(vec3 rgb, float Lw, float Lmax)
{
    return (Lw > Lmax) ? maxRGB_eetf_pq_to_linear(rgb, Lw, Lmax) : st2084_to_linear(rgb);
}

vec3 rec2020_to_rec709(vec3 v)
{
    float r = dot(v, vec3(1.6604910021084345, -0.58764113878854951, -0.072849863319884883));
    float g = dot(v, vec3(-0.12455047452159074, 1.1328998971259603, -0.0083494226043694768));
    float b = dot(v, vec3(-0.018150763354905303, -0.10057889800800739, 1.1187296613629127));
    return vec3(r, g, b);
}

vec4 PSI010_PQ_2020_709_Reverse(VertTexPos frag_in)
{
    float ratio = 65535. / 1023.;
    float y = obs_load_2d(image, ivec3(frag_in.pos.xy, 0)).x * ratio;
    float cb = texture(image1, frag_in.uv).x * ratio;
    float cr = texture(image2, frag_in.uv).x * ratio;
    vec3 yuv = vec3(y, cb, cr);
    vec3 pq = YUV_to_RGB(yuv);
    vec3 hdr2020 = st2084_to_linear_eetf(pq, hdr_lw, hdr_lmax) * maximum_over_sdr_white_nits;
    vec3 rgb = rec2020_to_rec709(hdr2020);
    return vec4(rgb, 1.);
}

vec4 _main_wrap(VertTexPos frag_in)
{
    return PSI010_PQ_2020_709_Reverse(frag_in);
}

void main(void)
{
    VertTexPos frag_in;
    frag_in.uv = _vertex_shader_attrib0;
    frag_in.pos = gl_FragCoord;

    _pixel_shader_attrib0 = _main_wrap(frag_in);
}

info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform float width_x2_i;
uniform float height_x2_i;


out vec2 _vertex_shader_attrib0;

out gl_PerVertex {
    vec4 gl_Position;
};

struct VertTexPos {
    vec2 uv;
    vec4 pos;
};

VertTexPos VS420TopLeft_Reverse(uint id)
{
    float idHigh = float(id >> 1);
    float idLow = float(id & uint(1));

    float x = idHigh * 4. - 1.;
    float y = idLow * 4. - 1.;

    float u = idHigh * 2. + width_x2_i;
    float v = idLow * 2. - height_x2_i;
    v = obs_glsl_compile ? v : (1. - v);

    VertTexPos vert_out;
    vert_out.uv = vec2(u, v);
    vert_out.pos = vec4(x, y, 0., 1.);
    return vert_out;
}

VertTexPos _main_wrap(uint id)
{
    return VS420TopLeft_Reverse(id);
}

void main(void)
{
    uint id;
    VertTexPos outputval;

    id = uint(gl_VertexID);

    outputval = _main_wrap(id);

    _vertex_shader_attrib0 = outputval.uv;
    gl_Position = outputval.pos;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform sampler2D image;
uniform sampler2D image1;
uniform sampler2D image2;
uniform float hlg_exponent;
uniform float maximum_over_sdr_white_nits;
uniform vec3 color_range_min;
uniform vec3 color_range_max;
uniform vec4 color_vec0;
uniform vec4 color_vec1;
uniform vec4 color_vec2;

in vec2 _vertex_shader_attrib0;

out vec4 _pixel_shader_attrib0;

struct VertTexPos {
    vec2 uv;
    vec4 pos;
};

vec3 YUV_to_RGB(vec3 yuv)
{
    yuv = clamp(yuv, color_range_min, color_range_max);
    float r = dot(color_vec0.xyz, yuv) + color_vec0.w;
    float g = dot(color_vec1.xyz, yuv) + color_vec1.w;
    float b = dot(color_vec2.xyz, yuv) + color_vec2.w;
    return vec3(r, g, b);
}

float hlg_to_linear_channel(float u)
{
    float ln2_i = 1. / log(2.);
    float m = ln2_i / 0.17883277;
    float a = -ln2_i * 0.55991073 / 0.17883277;
    return (u <= 0.5) ? ((u * u) / 3.) : ((exp2(u * m + a) + 0.28466892) / 12.);
}

vec3 hlg_to_linear(vec3 v, float exponent)
{
    vec3 rgb = vec3(hlg_to_linear_channel(v.r), hlg_to_linear_channel(v.g), hlg_to_linear_channel(v.b));
    float Ys = dot(rgb, vec3(0.2627, 0.678, 0.0593));
    rgb *= pow(Ys, exponent);
    return rgb;
}

vec3 rec2020_to_rec709(vec3 v)
{
    float r = dot(v, vec3(1.6604910021084345, -0.58764113878854951, -0.072849863319884883));
    float g = dot(v, vec3(-0.12455047452159074, 1.1328998971259603, -0.0083494226043694768));
    float b = dot(v, vec3(-0.018150763354905303, -0.10057889800800739, 1.1187296613629127));
    return vec3(r, g, b);
}

vec4 PSI010_HLG_2020_709_Reverse(VertTexPos frag_in)
{
    float ratio = 65535. / 1023.;
    float y = obs_load_2d(image, ivec3(frag_in.pos.xy, 0)).x * ratio;
    float cb = texture(image1, frag_in.uv).x * ratio;
    float cr = texture(image2, frag_in.uv).x * ratio;
    vec3 yuv = vec3(y, cb, cr);
    vec3 hlg = YUV_to_RGB(yuv);
    vec3 hdr2020 = hlg_to_linear(hlg, hlg_exponent) * maximum_over_sdr_white_nits;
    vec3 rgb = rec2020_to_rec709(hdr2020);
    return vec4(rgb, 1.);
}

vec4 _main_wrap(VertTexPos frag_in)
{
    return PSI010_HLG_2020_709_Reverse(frag_in);
}

void main(void)
{
    VertTexPos frag_in;
    frag_in.uv = _vertex_shader_attrib0;
    frag_in.pos = gl_FragCoord;

    _pixel_shader_attrib0 = _main_wrap(frag_in);
}

info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform float width_x2_i;


out vec2 _vertex_shader_attrib0;

out gl_PerVertex {
    vec4 gl_Position;
};

struct VertTexPos {
    vec2 uv;
    vec4 pos;
};

VertTexPos VS420Left_Reverse(uint id)
{
    float idHigh = float(id >> 1);
    float idLow = float(id & uint(1));

    float x = idHigh * 4. - 1.;
    float y = idLow * 4. - 1.;

    float u = idHigh * 2. + width_x2_i;
    float v = idLow * 2.;
    v = obs_glsl_compile ? v : (1. - v);

    VertTexPos vert_out;
    vert_out.uv = vec2(u, v);
    vert_out.pos = vec4(x, y, 0., 1.);
    return vert_out;
}

VertTexPos _main_wrap(uint id)
{
    return VS420Left_Reverse(id);
}

void main(void)
{
    uint id;
    VertTexPos outputval;

    id = uint(gl_VertexID);

    outputval = _main_wrap(id);

    _vertex_shader_attrib0 = outputval.uv;
    gl_Position = outputval.pos;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform sampler2D image;
uniform sampler2D image1;
uniform vec3 color_range_min;
uniform vec3 color_range_max;
uniform vec4 color_vec0;
uniform vec4 color_vec1;
uniform vec4 color_vec2;

in vec2 _vertex_shader_attrib0;

out vec4 _pixel_shader_attrib0;

struct VertTexPos {
    vec2 uv;
    vec4 pos;
};

vec3 YUV_to_RGB(vec3 yuv)
{
    yuv = clamp(yuv, color_range_min, color_range_max);
    float r = dot(color_vec0.xyz, yuv) + color_vec0.w;
    float g = dot(color_vec1.xyz, yuv) + color_vec1.w;
    float b = dot(color_vec2.xyz, yuv) + color_vec2.w;
    return vec3(r, g, b);
}

float srgb_nonlinear_to_linear_channel(float u)
{
    return (u <= 0.04045) ? (u / 12.92) : pow((u + 0.055) / 1.055, 2.4);
}

vec3 srgb_nonlinear_to_linear(vec3 v)
{
    return vec3(srgb_nonlinear_to_linear_channel(v.r), srgb_nonlinear_to_linear_channel(v.g), srgb_nonlinear_to_linear_channel(v.b));
}

vec4 PSP010_SRGB_Reverse(VertTexPos frag_in)
{
    float y = obs_load_2d(image, ivec3(frag_in.pos.xy, 0)).x;
    vec2 cbcr = texture(image1, frag_in.uv).xy;
    vec3 yuv_65535 = floor(vec3(y, cbcr) * 65535. + 0.5);
    vec3 yuv_1023 = floor(yuv_65535 * 0.015625);
    vec3 yuv = yuv_1023 / 1023.;
    vec3 rgb = YUV_to_RGB(yuv);
    rgb = srgb_nonlinear_to_linear(rgb);
    return vec4(rgb, 1.);
}

vec4 _main_wrap(VertTexPos frag_in)
{
    return PSP010_SRGB_Reverse(frag_in);
}

void main(void)
{
    VertTexPos frag_in;
    frag_in.uv = _vertex_shader_attrib0;
    frag_in.pos = gl_FragCoord;

    _pixel_shader_attrib0 = _main_wrap(frag_in);
}

info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform float width_x2_i;
uniform float height_x2_i;


out vec2 _vertex_shader_attrib0;

out gl_PerVertex {
    vec4 gl_Position;
};

struct VertTexPos {
    vec2 uv;
    vec4 pos;
};

VertTexPos VS420TopLeft_Reverse(uint id)
{
    float idHigh = float(id >> 1);
    float idLow = float(id & uint(1));

    float x = idHigh * 4. - 1.;
    float y = idLow * 4. - 1.;

    float u = idHigh * 2. + width_x2_i;
    float v = idLow * 2. - height_x2_i;
    v = obs_glsl_compile ? v : (1. - v);

    VertTexPos vert_out;
    vert_out.uv = vec2(u, v);
    vert_out.pos = vec4(x, y, 0., 1.);
    return vert_out;
}

VertTexPos _main_wrap(uint id)
{
    return VS420TopLeft_Reverse(id);
}

void main(void)
{
    uint id;
    VertTexPos outputval;

    id = uint(gl_VertexID);

    outputval = _main_wrap(id);

    _vertex_shader_attrib0 = outputval.uv;
    gl_Position = outputval.pos;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform sampler2D image;
uniform sampler2D image1;
uniform float hdr_lw;
uniform float hdr_lmax;
uniform float maximum_over_sdr_white_nits;
uniform vec3 color_range_min;
uniform vec3 color_range_max;
uniform vec4 color_vec0;
uniform vec4 color_vec1;
uniform vec4 color_vec2;

in vec2 _vertex_shader_attrib0;

out vec4 _pixel_shader_attrib0;

struct VertTexPos {
    vec2 uv;
    vec4 pos;
};

vec3 YUV_to_RGB(vec3 yuv)
{
    yuv = clamp(yuv, color_range_min, color_range_max);
    float r = dot(color_vec0.xyz, yuv) + color_vec0.w;
    float g = dot(color_vec1.xyz, yuv) + color_vec1.w;
    float b = dot(color_vec2.xyz, yuv) + color_vec2.w;
    return vec3(r, g, b);
}

float st2084_to_linear_channel(float u)
{
    float c = pow(abs(u), 1. / 78.84375);
    return pow(abs(max(c - 0.8359375, 0.) / (18.8515625 - 18.6875 * c)), 1. / 0.1593017578);
}

vec3 st2084_to_linear(vec3 rgb)
{
    return vec3(st2084_to_linear_channel(rgb.r), st2084_to_linear_channel(rgb.g), st2084_to_linear_channel(rgb.b));
}

float linear_to_st2084_channel(float x)
{
    float c = pow(abs(x), 0.1593017578);
    return pow((0.8359375 + 18.8515625 * c) / (1. + 18.6875 * c), 78.84375);
}

float eetf_0_Lmax(float maxRGB1_pq, float Lw, float Lmax)
{
    float Lw_pq = linear_to_st2084_channel(Lw / 10000.);
    float E1 = clamp(maxRGB1_pq / Lw_pq, 0.0, 1.0);
    float maxLum = linear_to_st2084_channel(Lmax / 10000.) / Lw_pq;
    float KS = (1.5 * maxLum) - 0.5;
    float E2 = E1;
    if (E1 > KS)
    {
        float T = (E1 - KS) / (1. - KS);
        float Tsquared = T * T;
        float Tcubed = Tsquared * T;
        float P = (2. * Tcubed - 3. * Tsquared + 1.) * KS + (Tcubed - 2. * Tsquared + T) * (1. - KS) + (-2. * Tcubed + 3. * Tsquared) * maxLum;
        E2 = P;
    }
    float E3 = E2;
    float E4 = E3 * Lw_pq;
    return E4;
}

vec3 maxRGB_eetf_internal(vec3 rgb_linear, float maxRGB1_linear, float maxRGB1_pq, float Lw, float Lmax)
{
    float maxRGB2_pq = eetf_0_Lmax(maxRGB1_pq, Lw, Lmax);
    float maxRGB2_linear = st2084_to_linear_channel(maxRGB2_pq);

     
    maxRGB1_linear = max(6.10352e-5, maxRGB1_linear);

    rgb_linear *= maxRGB2_linear / maxRGB1_linear;
    return rgb_linear;
}

vec3 maxRGB_eetf_pq_to_linear(vec3 rgb_pq, float Lw, float Lmax)
{
    vec3 rgb_linear = st2084_to_linear(rgb_pq);
    float maxRGB1_linear = max(max(rgb_linear.r, rgb_linear.g), rgb_linear.b);
    float maxRGB1_pq = max(max(rgb_pq.r, rgb_pq.g), rgb_pq.b);
    return maxRGB_eetf_internal(rgb_linear, maxRGB1_linear, maxRGB1_pq, Lw, Lmax);
}

vec3 st2084_to_linear_eetf(vec3 rgb, float Lw, float Lmax)
{
    return (Lw > Lmax) ? maxRGB_eetf_pq_to_linear(rgb, Lw, Lmax) : st2084_to_linear(rgb);
}

vec3 rec2020_to_rec709(vec3 v)
{
    float r = dot(v, vec3(1.6604910021084345, -0.58764113878854951, -0.072849863319884883));
    float g = dot(v, vec3(-0.12455047452159074, 1.1328998971259603, -0.0083494226043694768));
    float b = dot(v, vec3(-0.018150763354905303, -0.10057889800800739, 1.1187296613629127));
    return vec3(r, g, b);
}

vec4 PSP010_PQ_2020_709_Reverse(VertTexPos frag_in)
{
    float y = obs_load_2d(image, ivec3(frag_in.pos.xy, 0)).x;
    vec2 cbcr = texture(image1, frag_in.uv).xy;
    vec3 yuv_65535 = floor(vec3(y, cbcr) * 65535. + 0.5);
    vec3 yuv_1023 = floor(yuv_65535 * 0.015625);
    vec3 yuv = yuv_1023 / 1023.;
    vec3 pq = YUV_to_RGB(yuv);
    vec3 hdr2020 = st2084_to_linear_eetf(pq, hdr_lw, hdr_lmax) * maximum_over_sdr_white_nits;
    vec3 rgb = rec2020_to_rec709(hdr2020);
    return vec4(rgb, 1.);
}

vec4 _main_wrap(VertTexPos frag_in)
{
    return PSP010_PQ_2020_709_Reverse(frag_in);
}

void main(void)
{
    VertTexPos frag_in;
    frag_in.uv = _vertex_shader_attrib0;
    frag_in.pos = gl_FragCoord;

    _pixel_shader_attrib0 = _main_wrap(frag_in);
}

info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform float width_x2_i;
uniform float height_x2_i;


out vec2 _vertex_shader_attrib0;

out gl_PerVertex {
    vec4 gl_Position;
};

struct VertTexPos {
    vec2 uv;
    vec4 pos;
};

VertTexPos VS420TopLeft_Reverse(uint id)
{
    float idHigh = float(id >> 1);
    float idLow = float(id & uint(1));

    float x = idHigh * 4. - 1.;
    float y = idLow * 4. - 1.;

    float u = idHigh * 2. + width_x2_i;
    float v = idLow * 2. - height_x2_i;
    v = obs_glsl_compile ? v : (1. - v);

    VertTexPos vert_out;
    vert_out.uv = vec2(u, v);
    vert_out.pos = vec4(x, y, 0., 1.);
    return vert_out;
}

VertTexPos _main_wrap(uint id)
{
    return VS420TopLeft_Reverse(id);
}

void main(void)
{
    uint id;
    VertTexPos outputval;

    id = uint(gl_VertexID);

    outputval = _main_wrap(id);

    _vertex_shader_attrib0 = outputval.uv;
    gl_Position = outputval.pos;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform sampler2D image;
uniform sampler2D image1;
uniform float hlg_exponent;
uniform float maximum_over_sdr_white_nits;
uniform vec3 color_range_min;
uniform vec3 color_range_max;
uniform vec4 color_vec0;
uniform vec4 color_vec1;
uniform vec4 color_vec2;

in vec2 _vertex_shader_attrib0;

out vec4 _pixel_shader_attrib0;

struct VertTexPos {
    vec2 uv;
    vec4 pos;
};

vec3 YUV_to_RGB(vec3 yuv)
{
    yuv = clamp(yuv, color_range_min, color_range_max);
    float r = dot(color_vec0.xyz, yuv) + color_vec0.w;
    float g = dot(color_vec1.xyz, yuv) + color_vec1.w;
    float b = dot(color_vec2.xyz, yuv) + color_vec2.w;
    return vec3(r, g, b);
}

float hlg_to_linear_channel(float u)
{
    float ln2_i = 1. / log(2.);
    float m = ln2_i / 0.17883277;
    float a = -ln2_i * 0.55991073 / 0.17883277;
    return (u <= 0.5) ? ((u * u) / 3.) : ((exp2(u * m + a) + 0.28466892) / 12.);
}

vec3 hlg_to_linear(vec3 v, float exponent)
{
    vec3 rgb = vec3(hlg_to_linear_channel(v.r), hlg_to_linear_channel(v.g), hlg_to_linear_channel(v.b));
    float Ys = dot(rgb, vec3(0.2627, 0.678, 0.0593));
    rgb *= pow(Ys, exponent);
    return rgb;
}

vec3 rec2020_to_rec709(vec3 v)
{
    float r = dot(v, vec3(1.6604910021084345, -0.58764113878854951, -0.072849863319884883));
    float g = dot(v, vec3(-0.12455047452159074, 1.1328998971259603, -0.0083494226043694768));
    float b = dot(v, vec3(-0.018150763354905303, -0.10057889800800739, 1.1187296613629127));
    return vec3(r, g, b);
}

vec4 PSP010_HLG_2020_709_Reverse(VertTexPos frag_in)
{
    float y = obs_load_2d(image, ivec3(frag_in.pos.xy, 0)).x;
    vec2 cbcr = texture(image1, frag_in.uv).xy;
    vec3 yuv_65535 = floor(vec3(y, cbcr) * 65535. + 0.5);
    vec3 yuv_1023 = floor(yuv_65535 * 0.015625);
    vec3 yuv = yuv_1023 / 1023.;
    vec3 hlg = YUV_to_RGB(yuv);
    vec3 hdr2020 = hlg_to_linear(hlg, hlg_exponent) * maximum_over_sdr_white_nits;
    vec3 rgb = rec2020_to_rec709(hdr2020);
    return vec4(rgb, 1.);
}

vec4 _main_wrap(VertTexPos frag_in)
{
    return PSP010_HLG_2020_709_Reverse(frag_in);
}

void main(void)
{
    VertTexPos frag_in;
    frag_in.uv = _vertex_shader_attrib0;
    frag_in.pos = gl_FragCoord;

    _pixel_shader_attrib0 = _main_wrap(frag_in);
}

info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}




out gl_PerVertex {
    vec4 gl_Position;
};

struct FragPos {
    vec4 pos;
};

FragPos VSPos(uint id)
{
    float idHigh = float(id >> 1);
    float idLow = float(id & uint(1));

    float x = idHigh * 4.0 - 1.0;
    float y = idLow * 4.0 - 1.0;

    FragPos vert_out;
    vert_out.pos = vec4(x, y, 0.0, 1.0);
    return vert_out;
}

FragPos _main_wrap(uint id)
{
    return VSPos(id);
}

void main(void)
{
    uint id;
    FragPos outputval;

    id = uint(gl_VertexID);

    outputval = _main_wrap(id);

    gl_Position = outputval.pos;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform sampler2D image;
uniform float width;
uniform vec3 color_range_min;
uniform vec3 color_range_max;
uniform vec4 color_vec0;
uniform vec4 color_vec1;
uniform vec4 color_vec2;


out vec4 _pixel_shader_attrib0;

struct FragPos {
    vec4 pos;
};

vec3 YUV_to_RGB(vec3 yuv)
{
    yuv = clamp(yuv, color_range_min, color_range_max);
    float r = dot(color_vec0.xyz, yuv) + color_vec0.w;
    float g = dot(color_vec1.xyz, yuv) + color_vec1.w;
    float b = dot(color_vec2.xyz, yuv) + color_vec2.w;
    return vec3(r, g, b);
}

vec3 compute_v210_reverse(vec2 pos)
{
    uint x = uint(pos.x);
    uint packed_x = x % 6u;
    uint base_x = x / 6u * 4u;
    float y, cb, cr;
    if (packed_x == 0u)
    {
        vec3 word0_rgb = obs_load_2d(image, ivec3(base_x, pos.y, 0)).rgb;
        y = word0_rgb.y;
        cb = word0_rgb.x;
        cr = word0_rgb.z;
    }
    else if (packed_x == 1u)
    {
        vec2 word0_rb = obs_load_2d(image, ivec3(base_x, pos.y, 0)).rb;
        vec2 word1_rg = obs_load_2d(image, ivec3(base_x + 1u, pos.y, 0)).rg;
        y = word1_rg.x;
        cb = (word0_rb.x + word1_rg.y) * 0.5;
        cr = (word0_rb.y + obs_load_2d(image, ivec3(base_x + 2u, pos.y, 0)).r) * 0.5;
    }
    else if (packed_x == 2u)
    {
        vec2 word1_gb = obs_load_2d(image, ivec3(base_x + 1u, pos.y, 0)).gb;
        y = word1_gb.y;
        cb = word1_gb.x;
        cr = obs_load_2d(image, ivec3(base_x + 2u, pos.y, 0)).r;
    }
    else if (packed_x == 3u)
    {
        vec2 word2_rb = obs_load_2d(image, ivec3(base_x + 2u, pos.y, 0)).rb;
        y = obs_load_2d(image, ivec3(base_x + 2u, pos.y, 0)).g;
        cb = (obs_load_2d(image, ivec3(base_x + 1u, pos.y, 0)).g + word2_rb.y) * 0.5;
        cr = (word2_rb.x + obs_load_2d(image, ivec3(base_x + 3u, pos.y, 0)).g) * 0.5;
    }
    else if (packed_x == 4u)
    {
        vec2 word3_rg = obs_load_2d(image, ivec3(base_x + 3u, pos.y, 0)).rg;
        y = word3_rg.x;
        cb = obs_load_2d(image, ivec3(base_x + 2u, pos.y, 0)).b;
        cr = word3_rg.y;
    }
    else
    {
        vec2 word3_gb = obs_load_2d(image, ivec3(base_x + 3u, pos.y, 0)).gb;
        y = word3_gb.y;
        cb = obs_load_2d(image, ivec3(base_x + 2u, pos.y, 0)).b;
        cr = word3_gb.x;
        uint base_x_4 = base_x + 4u;
        if ((pos.x + 1.) < width)
        {
            vec2 word4_gb = obs_load_2d(image, ivec3(base_x + 4u, pos.y, 0)).rb;
            cb = (cb + word4_gb.x) * 0.5;
            cr = (cr + word4_gb.y) * 0.5;
        }
    }
    vec3 yuv_65535 = floor(vec3(y, cb, cr) * 65535. + 0.5);
    vec3 yuv_1023 = floor(yuv_65535 * 0.015625);
    vec3 yuv = yuv_1023 / 1023.;
    vec3 rgb = YUV_to_RGB(yuv);
    return rgb;
}

float srgb_nonlinear_to_linear_channel(float u)
{
    return (u <= 0.04045) ? (u / 12.92) : pow((u + 0.055) / 1.055, 2.4);
}

vec3 srgb_nonlinear_to_linear(vec3 v)
{
    return vec3(srgb_nonlinear_to_linear_channel(v.r), srgb_nonlinear_to_linear_channel(v.g), srgb_nonlinear_to_linear_channel(v.b));
}

vec4 PSV210_SRGB_Reverse(FragPos frag_in)
{
    vec3 rgb = compute_v210_reverse(frag_in.pos.xy);
    rgb = srgb_nonlinear_to_linear(rgb);
    return vec4(rgb, 1.);
}

vec4 _main_wrap(FragPos frag_in)
{
    return PSV210_SRGB_Reverse(frag_in);
}

void main(void)
{
    FragPos frag_in;
    frag_in.pos = gl_FragCoord;

    _pixel_shader_attrib0 = _main_wrap(frag_in);
}

info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}




out gl_PerVertex {
    vec4 gl_Position;
};

struct FragPos {
    vec4 pos;
};

FragPos VSPos(uint id)
{
    float idHigh = float(id >> 1);
    float idLow = float(id & uint(1));

    float x = idHigh * 4.0 - 1.0;
    float y = idLow * 4.0 - 1.0;

    FragPos vert_out;
    vert_out.pos = vec4(x, y, 0.0, 1.0);
    return vert_out;
}

FragPos _main_wrap(uint id)
{
    return VSPos(id);
}

void main(void)
{
    uint id;
    FragPos outputval;

    id = uint(gl_VertexID);

    outputval = _main_wrap(id);

    gl_Position = outputval.pos;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform float hdr_lw;
uniform float hdr_lmax;
uniform float maximum_over_sdr_white_nits;
uniform sampler2D image;
uniform float width;
uniform vec3 color_range_min;
uniform vec3 color_range_max;
uniform vec4 color_vec0;
uniform vec4 color_vec1;
uniform vec4 color_vec2;


out vec4 _pixel_shader_attrib0;

struct FragPos {
    vec4 pos;
};

vec3 YUV_to_RGB(vec3 yuv)
{
    yuv = clamp(yuv, color_range_min, color_range_max);
    float r = dot(color_vec0.xyz, yuv) + color_vec0.w;
    float g = dot(color_vec1.xyz, yuv) + color_vec1.w;
    float b = dot(color_vec2.xyz, yuv) + color_vec2.w;
    return vec3(r, g, b);
}

vec3 compute_v210_reverse(vec2 pos)
{
    uint x = uint(pos.x);
    uint packed_x = x % 6u;
    uint base_x = x / 6u * 4u;
    float y, cb, cr;
    if (packed_x == 0u)
    {
        vec3 word0_rgb = obs_load_2d(image, ivec3(base_x, pos.y, 0)).rgb;
        y = word0_rgb.y;
        cb = word0_rgb.x;
        cr = word0_rgb.z;
    }
    else if (packed_x == 1u)
    {
        vec2 word0_rb = obs_load_2d(image, ivec3(base_x, pos.y, 0)).rb;
        vec2 word1_rg = obs_load_2d(image, ivec3(base_x + 1u, pos.y, 0)).rg;
        y = word1_rg.x;
        cb = (word0_rb.x + word1_rg.y) * 0.5;
        cr = (word0_rb.y + obs_load_2d(image, ivec3(base_x + 2u, pos.y, 0)).r) * 0.5;
    }
    else if (packed_x == 2u)
    {
        vec2 word1_gb = obs_load_2d(image, ivec3(base_x + 1u, pos.y, 0)).gb;
        y = word1_gb.y;
        cb = word1_gb.x;
        cr = obs_load_2d(image, ivec3(base_x + 2u, pos.y, 0)).r;
    }
    else if (packed_x == 3u)
    {
        vec2 word2_rb = obs_load_2d(image, ivec3(base_x + 2u, pos.y, 0)).rb;
        y = obs_load_2d(image, ivec3(base_x + 2u, pos.y, 0)).g;
        cb = (obs_load_2d(image, ivec3(base_x + 1u, pos.y, 0)).g + word2_rb.y) * 0.5;
        cr = (word2_rb.x + obs_load_2d(image, ivec3(base_x + 3u, pos.y, 0)).g) * 0.5;
    }
    else if (packed_x == 4u)
    {
        vec2 word3_rg = obs_load_2d(image, ivec3(base_x + 3u, pos.y, 0)).rg;
        y = word3_rg.x;
        cb = obs_load_2d(image, ivec3(base_x + 2u, pos.y, 0)).b;
        cr = word3_rg.y;
    }
    else
    {
        vec2 word3_gb = obs_load_2d(image, ivec3(base_x + 3u, pos.y, 0)).gb;
        y = word3_gb.y;
        cb = obs_load_2d(image, ivec3(base_x + 2u, pos.y, 0)).b;
        cr = word3_gb.x;
        uint base_x_4 = base_x + 4u;
        if ((pos.x + 1.) < width)
        {
            vec2 word4_gb = obs_load_2d(image, ivec3(base_x + 4u, pos.y, 0)).rb;
            cb = (cb + word4_gb.x) * 0.5;
            cr = (cr + word4_gb.y) * 0.5;
        }
    }
    vec3 yuv_65535 = floor(vec3(y, cb, cr) * 65535. + 0.5);
    vec3 yuv_1023 = floor(yuv_65535 * 0.015625);
    vec3 yuv = yuv_1023 / 1023.;
    vec3 rgb = YUV_to_RGB(yuv);
    return rgb;
}

float st2084_to_linear_channel(float u)
{
    float c = pow(abs(u), 1. / 78.84375);
    return pow(abs(max(c - 0.8359375, 0.) / (18.8515625 - 18.6875 * c)), 1. / 0.1593017578);
}

vec3 st2084_to_linear(vec3 rgb)
{
    return vec3(st2084_to_linear_channel(rgb.r), st2084_to_linear_channel(rgb.g), st2084_to_linear_channel(rgb.b));
}

float linear_to_st2084_channel(float x)
{
    float c = pow(abs(x), 0.1593017578);
    return pow((0.8359375 + 18.8515625 * c) / (1. + 18.6875 * c), 78.84375);
}

float eetf_0_Lmax(float maxRGB1_pq, float Lw, float Lmax)
{
    float Lw_pq = linear_to_st2084_channel(Lw / 10000.);
    float E1 = clamp(maxRGB1_pq / Lw_pq, 0.0, 1.0);
    float maxLum = linear_to_st2084_channel(Lmax / 10000.) / Lw_pq;
    float KS = (1.5 * maxLum) - 0.5;
    float E2 = E1;
    if (E1 > KS)
    {
        float T = (E1 - KS) / (1. - KS);
        float Tsquared = T * T;
        float Tcubed = Tsquared * T;
        float P = (2. * Tcubed - 3. * Tsquared + 1.) * KS + (Tcubed - 2. * Tsquared + T) * (1. - KS) + (-2. * Tcubed + 3. * Tsquared) * maxLum;
        E2 = P;
    }
    float E3 = E2;
    float E4 = E3 * Lw_pq;
    return E4;
}

vec3 maxRGB_eetf_internal(vec3 rgb_linear, float maxRGB1_linear, float maxRGB1_pq, float Lw, float Lma
info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}




out gl_PerVertex {
    vec4 gl_Position;
};

struct FragPos {
    vec4 pos;
};

FragPos VSPos(uint id)
{
    float idHigh = float(id >> 1);
    float idLow = float(id & uint(1));

    float x = idHigh * 4.0 - 1.0;
    float y = idLow * 4.0 - 1.0;

    FragPos vert_out;
    vert_out.pos = vec4(x, y, 0.0, 1.0);
    return vert_out;
}

FragPos _main_wrap(uint id)
{
    return VSPos(id);
}

void main(void)
{
    uint id;
    FragPos outputval;

    id = uint(gl_VertexID);

    outputval = _main_wrap(id);

    gl_Position = outputval.pos;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform float hlg_exponent;
uniform float maximum_over_sdr_white_nits;
uniform sampler2D image;
uniform float width;
uniform vec3 color_range_min;
uniform vec3 color_range_max;
uniform vec4 color_vec0;
uniform vec4 color_vec1;
uniform vec4 color_vec2;


out vec4 _pixel_shader_attrib0;

struct FragPos {
    vec4 pos;
};

vec3 YUV_to_RGB(vec3 yuv)
{
    yuv = clamp(yuv, color_range_min, color_range_max);
    float r = dot(color_vec0.xyz, yuv) + color_vec0.w;
    float g = dot(color_vec1.xyz, yuv) + color_vec1.w;
    float b = dot(color_vec2.xyz, yuv) + color_vec2.w;
    return vec3(r, g, b);
}

vec3 compute_v210_reverse(vec2 pos)
{
    uint x = uint(pos.x);
    uint packed_x = x % 6u;
    uint base_x = x / 6u * 4u;
    float y, cb, cr;
    if (packed_x == 0u)
    {
        vec3 word0_rgb = obs_load_2d(image, ivec3(base_x, pos.y, 0)).rgb;
        y = word0_rgb.y;
        cb = word0_rgb.x;
        cr = word0_rgb.z;
    }
    else if (packed_x == 1u)
    {
        vec2 word0_rb = obs_load_2d(image, ivec3(base_x, pos.y, 0)).rb;
        vec2 word1_rg = obs_load_2d(image, ivec3(base_x + 1u, pos.y, 0)).rg;
        y = word1_rg.x;
        cb = (word0_rb.x + word1_rg.y) * 0.5;
        cr = (word0_rb.y + obs_load_2d(image, ivec3(base_x + 2u, pos.y, 0)).r) * 0.5;
    }
    else if (packed_x == 2u)
    {
        vec2 word1_gb = obs_load_2d(image, ivec3(base_x + 1u, pos.y, 0)).gb;
        y = word1_gb.y;
        cb = word1_gb.x;
        cr = obs_load_2d(image, ivec3(base_x + 2u, pos.y, 0)).r;
    }
    else if (packed_x == 3u)
    {
        vec2 word2_rb = obs_load_2d(image, ivec3(base_x + 2u, pos.y, 0)).rb;
        y = obs_load_2d(image, ivec3(base_x + 2u, pos.y, 0)).g;
        cb = (obs_load_2d(image, ivec3(base_x + 1u, pos.y, 0)).g + word2_rb.y) * 0.5;
        cr = (word2_rb.x + obs_load_2d(image, ivec3(base_x + 3u, pos.y, 0)).g) * 0.5;
    }
    else if (packed_x == 4u)
    {
        vec2 word3_rg = obs_load_2d(image, ivec3(base_x + 3u, pos.y, 0)).rg;
        y = word3_rg.x;
        cb = obs_load_2d(image, ivec3(base_x + 2u, pos.y, 0)).b;
        cr = word3_rg.y;
    }
    else
    {
        vec2 word3_gb = obs_load_2d(image, ivec3(base_x + 3u, pos.y, 0)).gb;
        y = word3_gb.y;
        cb = obs_load_2d(image, ivec3(base_x + 2u, pos.y, 0)).b;
        cr = word3_gb.x;
        uint base_x_4 = base_x + 4u;
        if ((pos.x + 1.) < width)
        {
            vec2 word4_gb = obs_load_2d(image, ivec3(base_x + 4u, pos.y, 0)).rb;
            cb = (cb + word4_gb.x) * 0.5;
            cr = (cr + word4_gb.y) * 0.5;
        }
    }
    vec3 yuv_65535 = floor(vec3(y, cb, cr) * 65535. + 0.5);
    vec3 yuv_1023 = floor(yuv_65535 * 0.015625);
    vec3 yuv = yuv_1023 / 1023.;
    vec3 rgb = YUV_to_RGB(yuv);
    return rgb;
}

float hlg_to_linear_channel(float u)
{
    float ln2_i = 1. / log(2.);
    float m = ln2_i / 0.17883277;
    float a = -ln2_i * 0.55991073 / 0.17883277;
    return (u <= 0.5) ? ((u * u) / 3.) : ((exp2(u * m + a) + 0.28466892) / 12.);
}

vec3 hlg_to_linear(vec3 v, float exponent)
{
    vec3 rgb = vec3(hlg_to_linear_channel(v.r), hlg_to_linear_channel(v.g), hlg_to_linear_channel(v.b));
    float Ys = dot(rgb, vec3(0.2627, 0.678, 0.0593));
    rgb *= pow(Ys, exponent);
    return rgb;
}

vec3 rec2020_to_rec709(vec3 v)
{
    float r = dot(v, vec3(1.6604910021084345, -0.58764113878854951, -0.072849863319884883));
    float g = dot(v, vec3(-0.12455047452159074, 1.1328998971259603, -0.0083494226043694768));
    float b = dot(v, vec3(-0.018150763354905303, -0.10057889800800739, 1.1187296613629127));
    return vec3(r, g, b);
}

vec4 PSV210_HLG_2020_709_Reverse(FragPos frag_in)
{
    vec3 hlg = compute_v210_reverse(frag_in.pos.xy);
    vec3 hdr2020 = hlg_to_linear(hlg, hlg_exponent) * maximum_over_sdr_white_nits;
    vec3 rgb = rec2020_to_rec709(hdr2020);
    return vec4(rgb, 1.);
}

vec4 _main_wrap(FragPos frag_in)
{
    return PSV210_HLG_2020_709_Reverse(frag_in);
}

void main(void)
{
    FragPos frag_in;
    frag_in.pos = gl_FragCoord;

    _
info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}




out gl_PerVertex {
    vec4 gl_Position;
};

struct FragPos {
    vec4 pos;
};

FragPos VSPos(uint id)
{
    float idHigh = float(id >> 1);
    float idLow = float(id & uint(1));

    float x = idHigh * 4.0 - 1.0;
    float y = idLow * 4.0 - 1.0;

    FragPos vert_out;
    vert_out.pos = vec4(x, y, 0.0, 1.0);
    return vert_out;
}

FragPos _main_wrap(uint id)
{
    return VSPos(id);
}

void main(void)
{
    uint id;
    FragPos outputval;

    id = uint(gl_VertexID);

    outputval = _main_wrap(id);

    gl_Position = outputval.pos;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform sampler2D image;


out vec3 _pixel_shader_attrib0;

struct FragPos {
    vec4 pos;
};

vec3 PSY800_Limited(FragPos frag_in)
{
    float limited = obs_load_2d(image, ivec3(frag_in.pos.xy, 0)).x;
    float full = (255.0 / 219.0) * limited - (16.0 / 219.0);
    return vec3(full, full, full);
}

vec3 _main_wrap(FragPos frag_in)
{
    return PSY800_Limited(frag_in);
}

void main(void)
{
    FragPos frag_in;
    frag_in.pos = gl_FragCoord;

    _pixel_shader_attrib0 = _main_wrap(frag_in);
}

info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}




out gl_PerVertex {
    vec4 gl_Position;
};

struct FragPos {
    vec4 pos;
};

FragPos VSPos(uint id)
{
    float idHigh = float(id >> 1);
    float idLow = float(id & uint(1));

    float x = idHigh * 4.0 - 1.0;
    float y = idLow * 4.0 - 1.0;

    FragPos vert_out;
    vert_out.pos = vec4(x, y, 0.0, 1.0);
    return vert_out;
}

FragPos _main_wrap(uint id)
{
    return VSPos(id);
}

void main(void)
{
    uint id;
    FragPos outputval;

    id = uint(gl_VertexID);

    outputval = _main_wrap(id);

    gl_Position = outputval.pos;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform sampler2D image;


out vec3 _pixel_shader_attrib0;

struct FragPos {
    vec4 pos;
};

vec3 PSY800_Full(FragPos frag_in)
{
    vec3 full = obs_load_2d(image, ivec3(frag_in.pos.xy, 0)).xxx;
    return full;
}

vec3 _main_wrap(FragPos frag_in)
{
    return PSY800_Full(frag_in);
}

void main(void)
{
    FragPos frag_in;
    frag_in.pos = gl_FragCoord;

    _pixel_shader_attrib0 = _main_wrap(frag_in);
}

info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}




out gl_PerVertex {
    vec4 gl_Position;
};

struct FragPos {
    vec4 pos;
};

FragPos VSPos(uint id)
{
    float idHigh = float(id >> 1);
    float idLow = float(id & uint(1));

    float x = idHigh * 4.0 - 1.0;
    float y = idLow * 4.0 - 1.0;

    FragPos vert_out;
    vert_out.pos = vec4(x, y, 0.0, 1.0);
    return vert_out;
}

FragPos _main_wrap(uint id)
{
    return VSPos(id);
}

void main(void)
{
    uint id;
    FragPos outputval;

    id = uint(gl_VertexID);

    outputval = _main_wrap(id);

    gl_Position = outputval.pos;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform sampler2D image;


out vec4 _pixel_shader_attrib0;

struct FragPos {
    vec4 pos;
};

vec4 PSRGB_Limited(FragPos frag_in)
{
    vec4 rgba = obs_load_2d(image, ivec3(frag_in.pos.xy, 0));
    rgba.rgb = (255.0 / 219.0) * rgba.rgb - (16.0 / 219.0);
    return rgba;
}

vec4 _main_wrap(FragPos frag_in)
{
    return PSRGB_Limited(frag_in);
}

void main(void)
{
    FragPos frag_in;
    frag_in.pos = gl_FragCoord;

    _pixel_shader_attrib0 = _main_wrap(frag_in);
}

info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}




out gl_PerVertex {
    vec4 gl_Position;
};

struct FragPos {
    vec4 pos;
};

FragPos VSPos(uint id)
{
    float idHigh = float(id >> 1);
    float idLow = float(id & uint(1));

    float x = idHigh * 4.0 - 1.0;
    float y = idLow * 4.0 - 1.0;

    FragPos vert_out;
    vert_out.pos = vec4(x, y, 0.0, 1.0);
    return vert_out;
}

FragPos _main_wrap(uint id)
{
    return VSPos(id);
}

void main(void)
{
    uint id;
    FragPos outputval;

    id = uint(gl_VertexID);

    outputval = _main_wrap(id);

    gl_Position = outputval.pos;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform sampler2D image;


out vec3 _pixel_shader_attrib0;

struct FragPos {
    vec4 pos;
};

vec3 PSBGR3_Limited(FragPos frag_in)
{
    float x = frag_in.pos.x * 3.0;
    float y = frag_in.pos.y;
    float b = obs_load_2d(image, ivec3(x - 1.0, y, 0)).x;
    float g = obs_load_2d(image, ivec3(x, y, 0)).x;
    float r = obs_load_2d(image, ivec3(x + 1.0, y, 0)).x;
    vec3 rgb = vec3(r, g, b);
    rgb = (255.0 / 219.0) * rgb - (16.0 / 219.0);
    return rgb;
}

vec3 _main_wrap(FragPos frag_in)
{
    return PSBGR3_Limited(frag_in);
}

void main(void)
{
    FragPos frag_in;
    frag_in.pos = gl_FragCoord;

    _pixel_shader_attrib0 = _main_wrap(frag_in);
}

info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}




out gl_PerVertex {
    vec4 gl_Position;
};

struct FragPos {
    vec4 pos;
};

FragPos VSPos(uint id)
{
    float idHigh = float(id >> 1);
    float idLow = float(id & uint(1));

    float x = idHigh * 4.0 - 1.0;
    float y = idLow * 4.0 - 1.0;

    FragPos vert_out;
    vert_out.pos = vec4(x, y, 0.0, 1.0);
    return vert_out;
}

FragPos _main_wrap(uint id)
{
    return VSPos(id);
}

void main(void)
{
    uint id;
    FragPos outputval;

    id = uint(gl_VertexID);

    outputval = _main_wrap(id);

    gl_Position = outputval.pos;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform sampler2D image;


out vec3 _pixel_shader_attrib0;

struct FragPos {
    vec4 pos;
};

vec3 PSBGR3_Full(FragPos frag_in)
{
    float x = frag_in.pos.x * 3.0;
    float y = frag_in.pos.y;
    float b = obs_load_2d(image, ivec3(x - 1.0, y, 0)).x;
    float g = obs_load_2d(image, ivec3(x, y, 0)).x;
    float r = obs_load_2d(image, ivec3(x + 1.0, y, 0)).x;
    vec3 rgb = vec3(r, g, b);
    return rgb;
}

vec3 _main_wrap(FragPos frag_in)
{
    return PSBGR3_Full(frag_in);
}

void main(void)
{
    FragPos frag_in;
    frag_in.pos = gl_FragCoord;

    _pixel_shader_attrib0 = _main_wrap(frag_in);
}

info: ======funcs =======
info: fname:srgb_linear_to_nonlinear_channel rtype:float mapping:(null) content:{
    return (u <= 0.0031308) ? (12.92 * u) : ((1.055 * pow(u, 1. / 2.4)) - 0.055);
}
info: fname:srgb_linear_to_nonlinear rtype:float3 mapping:(null) content:{
    return float3(srgb_linear_to_nonlinear_channel(v.r), srgb_linear_to_nonlinear_channel(v.g), srgb_linear_to_nonlinear_channel(v.b));
}
info: fname:srgb_nonlinear_to_linear_channel rtype:float mapping:(null) content:{
    return (u <= 0.04045) ? (u / 12.92) : pow((u + 0.055) / 1.055, 2.4);
}
info: fname:srgb_nonlinear_to_linear rtype:float3 mapping:(null) content:{
    return float3(srgb_nonlinear_to_linear_channel(v.r), srgb_nonlinear_to_linear_channel(v.g), srgb_nonlinear_to_linear_channel(v.b));
}
info: fname:rec709_to_rec2020 rtype:float3 mapping:(null) content:{
    float r = dot(v, float3(0.62740389593469903, 0.32928303837788370, 0.043313065687417225));
    float g = dot(v, float3(0.069097289358232075, 0.91954039507545871, 0.011362315566309178));
    float b = dot(v, float3(0.016391438875150280, 0.088013307877225749, 0.89559525324762401));
    return float3(r, g, b);
}
info: fname:d65p3_to_rec709 rtype:float3 mapping:(null) content:{
    float r = dot(v, float3(1.2249401762805598, -0.22494017628055996, 0.));
    float g = dot(v, float3(-0.042056954709688163, 1.0420569547096881, 0.));
    float b = dot(v, float3(-0.019637554590334432, -0.078636045550631889, 1.0982736001409663));
    return float3(r, g, b);
}
info: fname:rec2020_to_rec709 rtype:float3 mapping:(null) content:{
    float r = dot(v, float3(1.6604910021084345, -0.58764113878854951, -0.072849863319884883));
    float g = dot(v, float3(-0.12455047452159074, 1.1328998971259603, -0.0083494226043694768));
    float b = dot(v, float3(-0.018150763354905303, -0.10057889800800739, 1.1187296613629127));
    return float3(r, g, b);
}
info: fname:reinhard rtype:float3 mapping:(null) content:{
    rgb /= rgb + float3(1., 1., 1.);
    rgb = pow(rgb, float3(1. / 2.4, 1. / 2.4, 1. / 2.4));
    rgb = srgb_nonlinear_to_linear(rgb);
    return rgb;
}
info: fname:linear_to_st2084_channel rtype:float mapping:(null) content:{
    float c = pow(abs(x), 0.1593017578);
    return pow((0.8359375 + 18.8515625 * c) / (1. + 18.6875 * c), 78.84375);
}
info: fname:linear_to_st2084 rtype:float3 mapping:(null) content:{
    return float3(linear_to_st2084_channel(rgb.r), linear_to_st2084_channel(rgb.g), linear_to_st2084_channel(rgb.b));
}
info: fname:st2084_to_linear_channel rtype:float mapping:(null) content:{
    float c = pow(abs(u), 1. / 78.84375);
    return pow(abs(max(c - 0.8359375, 0.) / (18.8515625 - 18.6875 * c)), 1. / 0.1593017578);
}
info: fname:st2084_to_linear rtype:float3 mapping:(null) content:{
    return float3(st2084_to_linear_channel(rgb.r), st2084_to_linear_channel(rgb.g), st2084_to_linear_channel(rgb.b));
}
info: fname:eetf_0_Lmax rtype:float mapping:(null) content:{
    float Lw_pq = linear_to_st2084_channel(Lw / 10000.);
    float E1 = saturate(maxRGB1_pq / Lw_pq);
    float maxLum = linear_to_st2084_channel(Lmax / 10000.) / Lw_pq;
    float KS = (1.5 * maxLum) - 0.5;
    float E2 = E1;
    if (E1 > KS)
    {
        float T = (E1 - KS) / (1. - KS);
        float Tsquared = T * T;
        float Tcubed = Tsquared * T;
        float P = (2. * Tcubed - 3. * Tsquared + 1.) * KS + (Tcubed - 2. * Tsquared + T) * (1. - KS) + (-2. * Tcubed + 3. * Tsquared) * maxLum;
        E2 = P;
    }
    float E3 = E2;
    float E4 = E3 * Lw_pq;
    return E4;
}
info: fname:maxRGB_eetf_internal rtype:float3 mapping:(null) content:{
    float maxRGB2_pq = eetf_0_Lmax(maxRGB1_pq, Lw, Lmax);
    float maxRGB2_linear = st2084_to_linear_channel(maxRGB2_pq);

     
    maxRGB1_linear = max(6.10352e-5, maxRGB1_linear);

    rgb_linear *= maxRGB2_linear / maxRGB1_linear;
    return rgb_linear;
}
info: fname:maxRGB_eetf_pq_to_linear rtype:float3 mapping:(null) content:{
    float3 rgb_linear = st2084_to_linear(rgb_pq);
    float maxRGB1_linear = max(max(rgb_linear.r, rgb_linear.g), rgb_linear.b);
    float maxRGB1_pq = max(max(rgb_pq.r, rgb_pq.g), rgb_pq.b);
    return maxRGB_eetf_internal(rgb_linear, maxRGB1_linear, maxRGB1_pq, Lw, Lmax);
}
info: fname:maxRGB_eetf_linear_to_linear rtype:float3 mapping:(null) content:{
    float maxRGB1_linear = max(max(rgb_linear.r, rgb_linear.g), rgb_linear.b);
    float maxRGB1_pq = linear_to_st2084_channel(maxRGB1_linear);
    return maxRGB_eetf_internal(rgb_linear, maxRGB1_linear, maxRGB1_pq, Lw, Lmax);
}
info: fname:st2084_to_linear_eetf rtype:float3 mapping:(null) content:{
    return (Lw > Lmax) ? maxRGB_eetf_pq_to_linear(rgb, Lw, Lmax) : st2084_to_linear(rgb);
}
info: fname:linear_to_hlg_channel rtype:float mapping:(null) content:{
    float ln2_i = 1. / log(2.);
    float m = 0.17883277 / ln2_i;
    return (u <= (1. / 12.)) ? sqrt(3. * u) : ((log2((12. * u) - 0.28466892) * m) + 0.55991073);
}
info: fname:linear_to_hlg rtype:float3 mapping:(null) content:{
    rgb = saturate(rgb);

    if (Lw > 1000.)
    {
        rgb = maxRGB_eetf_linear_to_linear(rgb, Lw, 1000.);
        rgb *= 10000. / Lw;
    }
    else
    {
        rgb *= 10.;
    }

    float Yd = dot(rgb, float3(0.2627, 0.678, 0.0593));

     
    Yd = max(6.10352e-5, Yd);

    rgb *= pow(Yd, -1. / 6.);
    return float3(linear_to_hlg_channel(rgb.r), linear_to_hlg_channel(rgb.g), linear_to_hlg_channel(rgb.b));
}
info: fname:hlg_to_linear_channel rtype:float mapping:(null) content:{
    float ln2_i = 1. / log(2.);
    float m = ln2_i / 0.17883277;
    float a = -ln2_i * 0.55991073 / 0.17883277;
    return (u <= 0.5) ? ((u * u) / 3.) : ((exp2(u * m + a) + 0.28466892) / 12.);
}
info: fname:hlg_to_linear rtype:float3 mapping:(null) content:{
    float3 rgb = float3(hlg_to_linear_channel(v.r), hlg_to_linear_channel(v.g), hlg_to_linear_channel(v.b));
    float Ys = dot(rgb, float3(0.2627, 0.678, 0.0593));
    rgb *= pow(Ys, exponent);
    return rgb;
}
info: fname:VSPos rtype:FragPos mapping:(null) content:{
    float idHigh = float(id >> 1);
    float idLow = float(id & uint(1));

    float x = idHigh * 4.0 - 1.0;
    float y = idLow * 4.0 - 1.0;

    FragPos vert_out;
    vert_out.pos = float4(x, y, 0.0, 1.0);
    return vert_out;
}
info: fname:VSTexPos_Left rtype:VertTexPosWide mapping:(null) content:{
    float idHigh = float(id >> 1);
    float idLow = float(id & uint(1));

    float x = idHigh * 4.0 - 1.0;
    float y = idLow * 4.0 - 1.0;

    float u_right = idHigh * 2.0;
    float u_left = u_right - width_i;
    float v = obs_glsl_compile ? (idLow * 2.0) : (1.0 - idLow * 2.0);

    VertTexPosWide vert_out;
    vert_out.uuv = float3(u_left, u_right, v);
    vert_out.pos = float4(x, y, 0.0, 1.0);
    return vert_out;
}
info: fname:VSTexPos_TopLeft rtype:VertTexPosWideWide mapping:(null) content:{
    float idHigh = float(id >> 1);
    float idLow = float(id & uint(1));

    float x = idHigh * 4.0 - 1.0;
    float y = idLow * 4.0 - 1.0;

    float u_right = idHigh * 2.0;
    float u_left = u_right - width_i;
    float v_bottom;
    float v_top;
    if (obs_glsl_compile) {
        v_bottom = idLow * 2.0;
        v_top = v_bottom + height_i;
    } else {
        v_bottom = 1.0 - idLow * 2.0;
        v_top = v_bottom - height_i;
    }

    VertTexPosWideWide vert_out;
    vert_out.uuvv = float4(u_left, u_right, v_top, v_bottom);
    vert_out.pos = float4(x, y, 0.0, 1.0);
    return vert_out;
}
info: fname:VSPacked422Left_Reverse rtype:VertTexTexPos mapping:(null) content:{
    float idHigh = float(id >> 1);
    float idLow = float(id & uint(1));

    float x = idHigh * 4. - 1.;
    float y = idLow * 4. - 1.;

    float u = idHigh * 2.;
    float v = idLow * 2.;
    v = obs_glsl_compile ? v : (1. - v);

    VertTexTexPos vert_out;
    vert_out.uvuv = float4(width_d2 * u, height * v, u + width_x2_i, v);
    vert_out.pos = float4(x, y, 0., 1.);
    return vert_out;
}
info: fname:VS420Left_Reverse rtype:VertTexPos mapping:(null) content:{
    float idHigh = float(id >> 1);
    float idLow = float(id & uint(1));

    float x = idHigh * 4. - 1.;
    float y = idLow * 4. - 1.;

    float u = idHigh * 2. + width_x2_i;
    float v = idLow * 2.;
    v = obs_glsl_compile ? v : (1. - v);

    VertTexPos vert_out;
    vert_out.uv = float2(u, v);
    vert_out.pos = float4(x, y, 0., 1.);
    return vert_out;
}
info: fname:VS420TopLeft_Reverse rtype:VertTexPos mapping:(null) content:{
    float idHigh = float(id >> 1);
    float idLow = float(id & uint(1));

    float x = idHigh * 4. - 1.;
    float y = idLow * 4. - 1.;

    float u = idHigh * 2. + width_x2_i;
    float v = idLow * 2. - height_x2_i;
    v = obs_glsl_compile ? v : (1. - v);

    VertTexPos vert_out;
    vert_out.uv = float2(u, v);
    vert_out.pos = float4(x, y, 0., 1.);
    return vert_out;
}
info: fname:VS422Left_Reverse rtype:VertTexPos mapping:(null) content:{
    float idHigh = float(id >> 1);
    float idLow = float(id & uint(1));

    float x = idHigh * 4.0 - 1.0;
    float y = idLow * 4.0 - 1.0;

    float u = idHigh * 2.0 + width_x2_i;
    float v = obs_glsl_compile ? (idLow * 2.0) : (1.0 - idLow * 2.0);

    VertTexPos vert_out;
    vert_out.uv = float2(u, v);
    vert_out.pos = float4(x, y, 0.0, 1.0);
    return vert_out;
}
info: fname:PS_Y rtype:float mapping:TARGET content:{
    float3 rgb = image.Load(int3(frag_in.pos.xy, 0)).rgb;
    float y = dot(color_vec0.xyz, rgb) + color_vec0.w;
    return y;
}
info: fname:PS_P010_PQ_Y_709_2020 rtype:float mapping:TARGET content:{
    float3 rgb = image.Load(int3(frag_in.pos.xy, 0)).rgb * sdr_white_nits_over_maximum;
    rgb = rec709_to_rec2020(rgb);
    rgb = linear_to_st2084(rgb);
    float y = dot(color_vec0.xyz, rgb) + color_vec0.w;
    y = floor(saturate(y) * 1023. + 0.5) * (64. / 65535.);
    return y;
}
info: fname:PS_P010_HLG_Y_709_2020 rtype:float mapping:TARGET content:{
    float3 rgb = image.Load(int3(frag_in.pos.xy, 0)).rgb * sdr_white_nits_over_maximum;
    rgb = rec709_to_rec2020(rgb);
    rgb = linear_to_hlg(rgb, hdr_lw);
    float y = dot(color_vec0.xyz, rgb) + color_vec0.w;
    y = floor(saturate(y) * 1023. + 0.5) * (64. / 65535.);
    return y;
}
info: fname:PS_P010_SRGB_Y rtype:float mapping:TARGET content:{
    float3 rgb = image.Load(int3(frag_in.pos.xy, 0)).rgb;
    rgb = srgb_linear_to_nonlinear(rgb);
    float y = dot(color_vec0.xyz, rgb) + color_vec0.w;
    y = floor(saturate(y) * 1023. + 0.5) * (64. / 65535.);
    return y;
}
info: fname:PS_P216_PQ_Y_709_2020 rtype:float mapping:TARGET content:{
    float3 rgb = image.Load(int3(frag_in.pos.xy, 0)).rgb * sdr_white_nits_over_maximum;
    rgb = rec709_to_rec2020(rgb);
    rgb = linear_to_st2084(rgb);
    float y = dot(color_vec0.xyz, rgb) + color_vec0.w;
    return y;
}
info: fname:PS_P216_HLG_Y_709_2020 rtype:float mapping:TARGET content:{
    float3 rgb = image.Load(int3(frag_in.pos.xy, 0)).rgb * sdr_white_nits_over_maximum;
    rgb = rec709_to_rec2020(rgb);
    rgb = linear_to_hlg(rgb, hdr_lw);
    float y = dot(color_vec0.xyz, rgb) + color_vec0.w;
    return y;
}
info: fname:PS_P216_SRGB_Y rtype:float mapping:TARGET content:{
    float3 rgb = image.Load(int3(frag_in.pos.xy, 0)).rgb;
    rgb = srgb_linear_to_nonlinear(rgb);
    float y = dot(color_vec0.xyz, rgb) + color_vec0.w;
    return y;
}
info: fname:PS_P416_PQ_Y_709_2020 rtype:float mapping:TARGET content:{
    float3 rgb = image.Load(int3(frag_in.pos.xy, 0)).rgb * sdr_white_nits_over_maximum;
    rgb = rec709_to_rec2020(rgb);
    rgb = linear_to_st2084(rgb);
    float y = dot(color_vec0.xyz, rgb) + color_vec0.w;
    return y;
}
info: fname:PS_P416_HLG_Y_709_2020 rtype:float mapping:TARGET content:{
    float3 rgb = image.Load(int3(frag_in.pos.xy, 0)).rgb * sdr_white_nits_over_maximum;
    rgb = rec709_to_rec2020(rgb);
    rgb = linear_to_hlg(rgb, hdr_lw);
    float y = dot(color_vec0.xyz, rgb) + color_vec0.w;
    return y;
}
info: fname:PS_P416_SRGB_Y rtype:float mapping:TARGET content:{
    float3 rgb = image.Load(int3(frag_in.pos.xy, 0)).rgb;
    rgb = srgb_linear_to_nonlinear(rgb);
    float y = dot(color_vec0.xyz, rgb) + color_vec0.w;
    return y;
}
info: fname:PS_I010_PQ_Y_709_2020 rtype:float mapping:TARGET content:{
    float3 rgb = image.Load(int3(frag_in.pos.xy, 0)).rgb * sdr_white_nits_over_maximum;
    rgb = rec709_to_rec2020(rgb);
    rgb = linear_to_st2084(rgb);
    float y = dot(color_vec0.xyz, rgb) + color_vec0.w;
    return y * (1023. / 65535.);
}
info: fname:PS_I010_HLG_Y_709_2020 rtype:float mapping:TARGET content:{
    float3 rgb = image.Load(int3(frag_in.pos.xy, 0)).rgb * sdr_white_nits_over_maximum;
    rgb = rec709_to_rec2020(rgb);
    rgb = linear_to_hlg(rgb, hdr_lw);
    float y = dot(color_vec0.xyz, rgb) + color_vec0.w;
    return y * (1023. / 65535.);
}
info: fname:PS_I010_SRGB_Y rtype:float mapping:TARGET content:{
    float3 rgb = image.Load(int3(frag_in.pos.xy, 0)).rgb;
    rgb = srgb_linear_to_nonlinear(rgb);
    float y = dot(color_vec0.xyz, rgb) + color_vec0.w;
    return y * (1023. / 65535.);
}
info: fname:PS_UV_Wide rtype:float2 mapping:TARGET content:{
    float3 rgb_left = image.Sample(def_sampler, frag_in.uuv.xz).rgb;
    float3 rgb_right = image.Sample(def_sampler, frag_in.uuv.yz).rgb;
    float3 rgb = (rgb_left + rgb_right) * 0.5;
    float u = dot(color_vec1.xyz, rgb) + color_vec1.w;
    float v = dot(color_vec2.xyz, rgb) + color_vec2.w;
    return float2(u, v);
}
info: fname:PS_P010_PQ_UV_709_2020_WideWide rtype:float2 mapping:TARGET content:{
    float3 rgb_topleft = image.Sample(def_sampler, frag_in.uuvv.xz).rgb;
    float3 rgb_topright = image.Sample(def_sampler, frag_in.uuvv.yz).rgb;
    float3 rgb_bottomleft = image.Sample(def_sampler, frag_in.uuvv.xw).rgb;
    float3 rgb_bottomright = image.Sample(def_sampler, frag_in.uuvv.yw).rgb;
    float3 rgb = (rgb_topleft + rgb_topright + rgb_bottomleft + rgb_bottomright) * (0.25 * sdr_white_nits_over_maximum);
    rgb = rec709_to_rec2020(rgb);
    rgb = linear_to_st2084(rgb);
    float u = dot(color_vec1.xyz, rgb) + color_vec1.w;
    float v = dot(color_vec2.xyz, rgb) + color_vec2.w;
    float2 uv = float2(u, v);
    uv = floor(saturate(uv) * 1023. + 0.5) * (64. / 65535.);
    return uv;
}
info: fname:PS_P010_HLG_UV_709_2020_WideWide rtype:float2 mapping:TARGET content:{
    float3 rgb_topleft = image.Sample(def_sampler, frag_in.uuvv.xz).rgb;
    float3 rgb_topright = image.Sample(def_sampler, frag_in.uuvv.yz).rgb;
    float3 rgb_bottomleft = image.Sample(def_sampler, frag_in.uuvv.xw).rgb;
    float3 rgb_bottomright = image.Sample(def_sampler, frag_in.uuvv.yw).rgb;
    float3 rgb = (rgb_topleft + rgb_topright + rgb_bottomleft + rgb_bottomright) * (0.25 * sdr_white_nits_over_maximum);
    rgb = rec709_to_rec2020(rgb);
    rgb = linear_to_hlg(rgb, hdr_lw);
    float u = dot(color_vec1.xyz, rgb) + color_vec1.w;
    float v = dot(color_vec2.xyz, rgb) + color_vec2.w;
    float2 uv = float2(u, v);
    uv = floor(saturate(uv) * 1023. + 0.5) * (64. / 65535.);
    return uv;
}
info: fname:PS_P010_SRGB_UV_Wide rtype:float2 mapping:TARGET content:{
    float3 rgb_left = image.Sample(def_sampler, frag_in.uuv.xz).rgb;
    float3 rgb_right = image.Sample(def_sampler, frag_in.uuv.yz).rgb;
    float3 rgb = (rgb_left + rgb_right) * 0.5;
    rgb = srgb_linear_to_nonlinear(rgb);
    float u = dot(color_vec1.xyz, rgb) + color_vec1.w;
    float v = dot(color_vec2.xyz, rgb) + color_vec2.w;
    float2 uv = float2(u, v);
    uv = floor(saturate(uv) * 1023. + 0.5) * (64. / 65535.);
    return uv;
}
info: fname:PS_P216_PQ_UV_709_2020_Wide rtype:float2 mapping:TARGET content:{
    float3 rgb_left = image.Sample(def_sampler, frag_in.uuv.xz).rgb;
    float3 rgb_right = image.Sample(def_sampler, frag_in.uuv.yz).rgb;
    float3 rgb = (rgb_left + rgb_right) * (0.5 * sdr_white_nits_over_maximum);
    rgb = rec709_to_rec2020(rgb);
    rgb = linear_to_st2084(rgb);
    float u = dot(color_vec1.xyz, rgb) + color_vec1.w;
    float v = dot(color_vec2.xyz, rgb) + color_vec2.w;
    float2 uv = float2(u, v);
    return uv;
}
info: fname:PS_P216_HLG_UV_709_2020_Wide rtype:float2 mapping:TARGET content:{
    float3 rgb_left = image.Sample(def_sampler, frag_in.uuv.xz).rgb;
    float3 rgb_right = image.Sample(def_sampler, frag_in.uuv.yz).rgb;
    float3 rgb = (rgb_left + rgb_right) * (0.5 * sdr_white_nits_over_maximum);
    rgb = rec709_to_rec2020(rgb);
    rgb = linear_to_hlg(rgb, hdr_lw);
    float u = dot(color_vec1.xyz, rgb) + color_vec1.w;
    float v = dot(color_vec2.xyz, rgb) + color_vec2.w;
    float2 uv = float2(u, v);
    return uv;
}
info: fname:PS_P216_SRGB_UV_Wide rtype:float2 mapping:TARGET content:{
    float3 rgb_left = image.Sample(def_sampler, frag_in.uuv.xz).rgb;
    float3 rgb_right = image.Sample(def_sampler, frag_in.uuv.yz).rgb;
    float3 rgb = (rgb_left + rgb_right) * 0.5;
    rgb = srgb_linear_to_nonlinear(rgb);
    float u = dot(color_vec1.xyz, rgb) + color_vec1.w;
    float v = dot(color_vec2.xyz, rgb) + color_vec2.w;
    float2 uv = float2(u, v);
    return uv;
}
info: fname:PS_P416_PQ_UV_709_2020 rtype:float2 mapping:TARGET content:{
    float3 rgb = image.Load(int3(frag_in.pos.xy, 0)).rgb;
    rgb = rec709_to_rec2020(rgb);
    rgb = linear_to_st2084(rgb);
    float u = dot(color_vec1.xyz, rgb) + color_vec1.w;
    float v = dot(color_vec2.xyz, rgb) + color_vec2.w;
    float2 uv = float2(u, v);
    return uv;
}
info: fname:PS_P416_HLG_UV_709_2020 rtype:float2 mapping:TARGET content:{
    float3 rgb = image.Load(int3(frag_in.pos.xy, 0)).rgb;
    rgb = rec709_to_rec2020(rgb);
    rgb = linear_to_hlg(rgb, hdr_lw);
    float u = dot(color_vec1.xyz, rgb) + color_vec1.w;
    float v = dot(color_vec2.xyz, rgb) + color_vec2.w;
    float2 uv = float2(u, v);
    return uv;
}
info: fname:PS_P416_SRGB_UV rtype:float2 mapping:TARGET content:{
    float3 rgb = image.Load(int3(frag_in.pos.xy, 0)).rgb;
    rgb = srgb_linear_to_nonlinear(rgb);
    float u = dot(color_vec1.xyz, rgb) + color_vec1.w;
    float v = dot(color_vec2.xyz, rgb) + color_vec2.w;
    float2 uv = float2(u, v);
    return uv;
}
info: fname:PS_U rtype:float mapping:TARGET content:{
    float3 rgb = image.Load(int3(frag_in.pos.xy, 0)).rgb;
    float u = dot(color_vec1.xyz, rgb) + color_vec1.w;
    return u;
}
info: fname:PS_V rtype:float mapping:TARGET content:{
    float3 rgb = image.Load(int3(frag_in.pos.xy, 0)).rgb;
    float v = dot(color_vec2.xyz, rgb) + color_vec2.w;
    return v;
}
info: fname:PS_U_Wide rtype:float mapping:TARGET content:{
    float3 rgb_left = image.Sample(def_sampler, frag_in.uuv.xz).rgb;
    float3 rgb_right = image.Sample(def_sampler, frag_in.uuv.yz).rgb;
    float3 rgb = (rgb_left + rgb_right) * 0.5;
    float u = dot(color_vec1.xyz, rgb) + color_vec1.w;
    return u;
}
info: fname:PS_V_Wide rtype:float mapping:TARGET content:{
    float3 rgb_left = image.Sample(def_sampler, frag_in.uuv.xz).rgb;
    float3 rgb_right = image.Sample(def_sampler, frag_in.uuv.yz).rgb;
    float3 rgb = (rgb_left + rgb_right) * 0.5;
    float v = dot(color_vec2.xyz, rgb) + color_vec2.w;
    return v;
}
info: fname:PS_I010_PQ_U_709_2020_WideWide rtype:float mapping:TARGET content:{
    float3 rgb_topleft = image.Sample(def_sampler, frag_in.uuvv.xz).rgb;
    float3 rgb_topright = image.Sample(def_sampler, frag_in.uuvv.yz).rgb;
    float3 rgb_bottomleft = image.Sample(def_sampler, frag_in.uuvv.xw).rgb;
    float3 rgb_bottomright = image.Sample(def_sampler, frag_in.uuvv.yw).rgb;
    float3 rgb = (rgb_topleft + rgb_topright + rgb_bottomleft + rgb_bottomright) * (0.25 * sdr_white_nits_over_maximum);
    rgb = rec709_to_rec2020(rgb);
    rgb = linear_to_st2084(rgb);
    float u = dot(color_vec1.xyz, rgb) + color_vec1.w;
    return u * (1023. / 65535.);
}
info: fname:PS_I010_HLG_U_709_2020_WideWide rtype:float mapping:TARGET content:{
    float3 rgb_topleft = image.Sample(def_sampler, frag_in.uuvv.xz).rgb;
    float3 rgb_topright = image.Sample(def_sampler, frag_in.uuvv.yz).rgb;
    float3 rgb_bottomleft = image.Sample(def_sampler, frag_in.uuvv.xw).rgb;
    float3 rgb_bottomright = image.Sample(def_sampler, frag_in.uuvv.yw).rgb;
    float3 rgb = (rgb_topleft + rgb_topright + rgb_bottomleft + rgb_bottomright) * (0.25 * sdr_white_nits_over_maximum);
    rgb = rec709_to_rec2020(rgb);
    rgb = linear_to_hlg(rgb, hdr_lw);
    float u = dot(color_vec1.xyz, rgb) + color_vec1.w;
    return u * (1023. / 65535.);
}
info: fname:PS_I010_SRGB_U_Wide rtype:float mapping:TARGET content:{
    float3 rgb_left = image.Sample(def_sampler, frag_in.uuv.xz).rgb;
    float3 rgb_right = image.Sample(def_sampler, frag_in.uuv.yz).rgb;
    float3 rgb = (rgb_left + rgb_right) * 0.5;
    rgb = srgb_linear_to_nonlinear(rgb);
    float u = dot(color_vec1.xyz, rgb) + color_vec1.w;
    return u * (1023. / 65535.);
}
info: fname:PS_I010_PQ_V_709_2020_WideWide rtype:float mapping:TARGET content:{
    float3 rgb_topleft = image.Sample(def_sampler, frag_in.uuvv.xz).rgb;
    float3 rgb_topright = image.Sample(def_sampler, frag_in.uuvv.yz).rgb;
    float3 rgb_bottomleft = image.Sample(def_sampler, frag_in.uuvv.xw).rgb;
    float3 rgb_bottomright = image.Sample(def_sampler, frag_in.uuvv.yw).rgb;
    float3 rgb = (rgb_topleft + rgb_topright + rgb_bottomleft + rgb_bottomright) * (0.25 * sdr_white_nits_over_maximum);
    rgb = rec709_to_rec2020(rgb);
    rgb = linear_to_st2084(rgb);
    float v = dot(color_vec2.xyz, rgb) + color_vec2.w;
    return v * (1023. / 65535.);
}
info: fname:PS_I010_HLG_V_709_2020_WideWide rtype:float mapping:TARGET content:{
    float3 rgb_topleft = image.Sample(def_sampler, frag_in.uuvv.xz).rgb;
    float3 rgb_topright = image.Sample(def_sampler, frag_in.uuvv.yz).rgb;
    float3 rgb_bottomleft = image.Sample(def_sampler, frag_in.uuvv.xw).rgb;
    float3 rgb_bottomright = image.Sample(def_sampler, frag_in.uuvv.yw).rgb;
    float3 rgb = (rgb_topleft + rgb_topright + rgb_bottomleft + rgb_bottomright) * (0.25 * sdr_white_nits_over_maximum);
    rgb = rec709_to_rec2020(rgb);
    rgb = linear_to_hlg(rgb, hdr_lw);
    float v = dot(color_vec2.xyz, rgb) + color_vec2.w;
    return v * (1023. / 65535.);
}
info: fname:PS_I010_SRGB_V_Wide rtype:float mapping:TARGET content:{
    float3 rgb_left = image.Sample(def_sampler, frag_in.uuv.xz).rgb;
    float3 rgb_right = image.Sample(def_sampler, frag_in.uuv.yz).rgb;
    float3 rgb = (rgb_left + rgb_right) * 0.5;
    rgb = srgb_linear_to_nonlinear(rgb);
    float v = dot(color_vec2.xyz, rgb) + color_vec2.w;
    return v * (1023. / 65535.);
}
info: fname:YUV_to_RGB rtype:float3 mapping:(null) content:{
    yuv = clamp(yuv, color_range_min, color_range_max);
    float r = dot(color_vec0.xyz, yuv) + color_vec0.w;
    float g = dot(color_vec1.xyz, yuv) + color_vec1.w;
    float b = dot(color_vec2.xyz, yuv) + color_vec2.w;
    return float3(r, g, b);
}
info: fname:PSUYVY_Reverse rtype:float3 mapping:TARGET content:{
    float2 y01 = image.Load(int3(frag_in.uvuv.xy, 0)).yw;
    float2 cbcr = image.Sample(def_sampler, frag_in.uvuv.zw, 0).zx;
    float leftover = frac(frag_in.uvuv.x);
    float y = (leftover < 0.5) ? y01.x : y01.y;
    float3 yuv = float3(y, cbcr);
    float3 rgb = YUV_to_RGB(yuv);
    return rgb;
}
info: fname:PSYUY2_Reverse rtype:float3 mapping:TARGET content:{
    float2 y01 = image.Load(int3(frag_in.uvuv.xy, 0)).zx;
    float2 cbcr = image.Sample(def_sampler, frag_in.uvuv.zw, 0).yw;
    float leftover = frac(frag_in.uvuv.x);
    float y = (leftover < 0.5) ? y01.x : y01.y;
    float3 yuv = float3(y, cbcr);
    float3 rgb = YUV_to_RGB(yuv);
    return rgb;
}
info: fname:PSYUY2_PQ_Reverse rtype:float4 mapping:TARGET content:{
    float2 y01 = image.Load(int3(frag_in.uvuv.xy, 0)).zx;
    float2 cbcr = image.Sample(def_sampler, frag_in.uvuv.zw, 0).yw;
    float leftover = frac(frag_in.uvuv.x);
    float y = (leftover < 0.5) ? y01.x : y01.y;
    float3 yuv = float3(y, cbcr);
    float3 pq = YUV_to_RGB(yuv);
    float3 hdr2020 = st2084_to_linear_eetf(pq, hdr_lw, hdr_lmax) * maximum_over_sdr_white_nits;
    float3 rgb = rec2020_to_rec709(hdr2020);
    return float4(rgb, 1.);
}
info: fname:PSYUY2_HLG_Reverse rtype:float4 mapping:TARGET content:{
    float2 y01 = image.Load(int3(frag_in.uvuv.xy, 0)).zx;
    float2 cbcr = image.Sample(def_sampler, frag_in.uvuv.zw, 0).yw;
    float leftover = frac(frag_in.uvuv.x);
    float y = (leftover < 0.5) ? y01.x : y01.y;
    float3 yuv = float3(y, cbcr);
    float3 hlg = YUV_to_RGB(yuv);
    float3 hdr2020 = hlg_to_linear(hlg, hlg_exponent) * maximum_over_sdr_white_nits;
    float3 rgb = rec2020_to_rec709(hdr2020);
    return float4(rgb, 1.);
}
info: fname:PSYVYU_Reverse rtype:float3 mapping:TARGET content:{
    float2 y01 = image.Load(int3(frag_in.uvuv.xy, 0)).zx;
    float2 cbcr = image.Sample(def_sampler, frag_in.uvuv.zw, 0).wy;
    float leftover = frac(frag_in.uvuv.x);
    float y = (leftover < 0.5) ? y01.x : y01.y;
    float3 yuv = float3(y, cbcr);
    float3 rgb = YUV_to_RGB(yuv);
    return rgb;
}
info: fname:PSPlanar420_Reverse rtype:float3 mapping:TARGET content:{
    float y = image.Load(int3(frag_in.pos.xy, 0)).x;
    float cb = image1.Sample(def_sampler, frag_in.uv).x;
    float cr = image2.Sample(def_sampler, frag_in.uv).x;
    float3 yuv = float3(y, cb, cr);
    float3 rgb = YUV_to_RGB(yuv);
    return rgb;
}
info: fname:PSPlanar420_PQ_Reverse rtype:float4 mapping:TARGET content:{
    float y = image.Load(int3(frag_in.pos.xy, 0)).x;
    float cb = image1.Sample(def_sampler, frag_in.uv).x;
    float cr = image2.Sample(def_sampler, frag_in.uv).x;
    float3 yuv = float3(y, cb, cr);
    float3 pq = YUV_to_RGB(yuv);
    float3 hdr2020 = st2084_to_linear_eetf(pq, hdr_lw, hdr_lmax) * maximum_over_sdr_white_nits;
    float3 rgb = rec2020_to_rec709(hdr2020);
    return float4(rgb, 1.);
}
info: fname:PSPlanar420_HLG_Reverse rtype:float4 mapping:TARGET content:{
    float y = image.Load(int3(frag_in.pos.xy, 0)).x;
    float cb = image1.Sample(def_sampler, frag_in.uv).x;
    float cr = image2.Sample(def_sampler, frag_in.uv).x;
    float3 yuv = float3(y, cb, cr);
    float3 hlg = YUV_to_RGB(yuv);
    float3 hdr2020 = hlg_to_linear(hlg, hlg_exponent) * maximum_over_sdr_white_nits;
    float3 rgb = rec2020_to_rec709(hdr2020);
    return float4(rgb, 1.);
}
info: fname:PSPlanar420A_Reverse rtype:float4 mapping:TARGET content:{
    int3 xy0_luma = int3(frag_in.pos.xy, 0);
    float y = image.Load(xy0_luma).x;
    float alpha = image3.Load(xy0_luma).x;
    float cb = image1.Sample(def_sampler, frag_in.uv).x;
    float cr = image2.Sample(def_sampler, frag_in.uv).x;
    float3 yuv = float3(y, cb, cr);
    float4 rgba = float4(YUV_to_RGB(yuv), alpha);
    return rgba;
}
info: fname:PSPlanar422_Reverse rtype:float3 mapping:TARGET content:{
    float y = image.Load(int3(frag_in.pos.xy, 0)).x;
    float cb = image1.Sample(def_sampler, frag_in.uv).x;
    float cr = image2.Sample(def_sampler, frag_in.uv).x;
    float3 yuv = float3(y, cb, cr);
    float3 rgb = YUV_to_RGB(yuv);
    return rgb;
}
info: fname:PSPlanar422_10LE_Reverse rtype:float4 mapping:TARGET content:{
    float y = image.Load(int3(frag_in.pos.xy, 0)).x;
    float cb = image1.Sample(def_sampler, frag_in.uv).x;
    float cr = image2.Sample(def_sampler, frag_in.uv).x;
    float3 yuv = float3(y, cb, cr);
    yuv *= 65535. / 1023.;
    float3 rgb = YUV_to_RGB(yuv);
    rgb = srgb_nonlinear_to_linear(rgb);
    return float4(rgb, 1.);
}
info: fname:PSPlanar422_10LE_PQ_Reverse rtype:float4 mapping:TARGET content:{
    float y = image.Load(int3(frag_in.pos.xy, 0)).x;
    float cb = image1.Sample(def_sampler, frag_in.uv).x;
    float cr = image2.Sample(def_sampler, frag_in.uv).x;
    float3 yuv = float3(y, cb, cr);
    yuv *= 65535. / 1023.;
    float3 pq = YUV_to_RGB(yuv);
    float3 hdr2020 = st2084_to_linear_eetf(pq, hdr_lw, hdr_lmax) * maximum_over_sdr_white_nits;
    float3 rgb = rec2020_to_rec709(hdr2020);
    return float4(rgb, 1.);
}
info: fname:PSPlanar422_10LE_HLG_Reverse rtype:float4 mapping:TARGET content:{
    float y = image.Load(int3(frag_in.pos.xy, 0)).x;
    float cb = image1.Sample(def_sampler, frag_in.uv).x;
    float cr = image2.Sample(def_sampler, frag_in.uv).x;
    float3 yuv = float3(y, cb, cr);
    yuv *= 65535. / 1023.;
    float3 hlg = YUV_to_RGB(yuv);
    float3 hdr2020 = hlg_to_linear(hlg, hlg_exponent) * maximum_over_sdr_white_nits;
    float3 rgb = rec2020_to_rec709(hdr2020);
    return float4(rgb, 1.);
}
info: fname:PSPlanar422A_Reverse rtype:float4 mapping:TARGET content:{
    int3 xy0_luma = int3(frag_in.pos.xy, 0);
    float y = image.Load(xy0_luma).x;
    float alpha = image3.Load(xy0_luma).x;
    float cb = image1.Sample(def_sampler, frag_in.uv).x;
    float cr = image2.Sample(def_sampler, frag_in.uv).x;
    float3 yuv = float3(y, cb, cr);
    float4 rgba = float4(YUV_to_RGB(yuv), alpha);
    return rgba;
}
info: fname:PSPlanar444_Reverse rtype:float3 mapping:TARGET content:{
    int3 xy0 = int3(frag_in.pos.xy, 0);
    float y = image.Load(xy0).x;
    float cb = image1.Load(xy0).x;
    float cr = image2.Load(xy0).x;
    float3 yuv = float3(y, cb, cr);
    float3 rgb = YUV_to_RGB(yuv);
    return rgb;
}
info: fname:PSPlanar444_12LE_Reverse rtype:float4 mapping:TARGET content:{
    int3 xy0 = int3(frag_in.pos.xy, 0);
    float y = image.Load(xy0).x;
    float cb = image1.Load(xy0).x;
    float cr = image2.Load(xy0).x;
    float3 yuv = float3(y, cb, cr);
    yuv *= 65535. / 4095.;
    float3 rgb = YUV_to_RGB(yuv);
    rgb = srgb_nonlinear_to_linear(rgb);
    return float4(rgb, 1.);
}
info: fname:PSPlanar444_12LE_PQ_Reverse rtype:float4 mapping:TARGET content:{
    int3 xy0 = int3(frag_in.pos.xy, 0);
    float y = image.Load(xy0).x;
    float cb = image1.Load(xy0).x;
    float cr = image2.Load(xy0).x;
    float3 yuv = float3(y, cb, cr);
    yuv *= 65535. / 4095;
    float3 pq = YUV_to_RGB(yuv);
    float3 hdr2020 = st2084_to_linear_eetf(pq, hdr_lw, hdr_lmax) * maximum_over_sdr_white_nits;
    float3 rgb = rec2020_to_rec709(hdr2020);
    return float4(rgb, 1.);
}
info: fname:PSPlanar444_12LE_HLG_Reverse rtype:float4 mapping:TARGET content:{
    int3 xy0 = int3(frag_in.pos.xy, 0);
    float y = image.Load(xy0).x;
    float cb = image1.Load(xy0).x;
    float cr = image2.Load(xy0).x;
    float3 yuv = float3(y, cb, cr);
    yuv *= 65535. / 4095;
    float3 hlg = YUV_to_RGB(yuv);
    float3 hdr2020 = hlg_to_linear(hlg, hlg_exponent) * maximum_over_sdr_white_nits;
    float3 rgb = rec2020_to_rec709(hdr2020);
    return float4(rgb, 1.);
}
info: fname:PSPlanar444A_Reverse rtype:float4 mapping:TARGET content:{
    int3 xy0 = int3(frag_in.pos.xy, 0);
    float y = image.Load(xy0).x;
    float cb = image1.Load(xy0).x;
    float cr = image2.Load(xy0).x;
    float alpha = image3.Load(xy0).x;
    float3 yuv = float3(y, cb, cr);
    float4 rgba = float4(YUV_to_RGB(yuv), alpha);
    return rgba;
}
info: fname:PSPlanar444A_12LE_Reverse rtype:float4 mapping:TARGET content:{
    int3 xy0 = int3(frag_in.pos.xy, 0);
    float y = image.Load(xy0).x;
    float cb = image1.Load(xy0).x;
    float cr = image2.Load(xy0).x;
    float alpha = image3.Load(xy0).x * 16.;
    float3 yuv = float3(y, cb, cr);
    yuv *= 65535. / 4095.;
    float3 rgb = YUV_to_RGB(yuv);
    rgb = srgb_nonlinear_to_linear(rgb);
    return float4(rgb, alpha);
}
info: fname:PSAYUV_Reverse rtype:float4 mapping:TARGET content:{
    float4 yuva = image.Load(int3(frag_in.pos.xy, 0));
    float4 rgba = float4(YUV_to_RGB(yuva.xyz), yuva.a);
    return rgba;
}
info: fname:PSNV12_Reverse rtype:float3 mapping:TARGET content:{
    float y = image.Load(int3(frag_in.pos.xy, 0)).x;
    float2 cbcr = image1.Sample(def_sampler, frag_in.uv).xy;
    float3 yuv = float3(y, cbcr);
    float3 rgb = YUV_to_RGB(yuv);
    return rgb;
}
info: fname:PSNV12_PQ_Reverse rtype:float4 mapping:TARGET content:{
    float y = image.Load(int3(frag_in.pos.xy, 0)).x;
    float2 cbcr = image1.Sample(def_sampler, frag_in.uv).xy;
    float3 yuv = float3(y, cbcr);
    float3 pq = YUV_to_RGB(yuv);
    float3 hdr2020 = st2084_to_linear_eetf(pq, hdr_lw, hdr_lmax) * maximum_over_sdr_white_nits;
    float3 rgb = rec2020_to_rec709(hdr2020);
    return float4(rgb, 1.);
}
info: fname:PSNV12_HLG_Reverse rtype:float4 mapping:TARGET content:{
    float y = image.Load(int3(frag_in.pos.xy, 0)).x;
    float2 cbcr = image1.Sample(def_sampler, frag_in.uv).xy;
    float3 yuv = float3(y, cbcr);
    float3 hlg = YUV_to_RGB(yuv);
    float3 hdr2020 = hlg_to_linear(hlg, hlg_exponent) * maximum_over_sdr_white_nits;
    float3 rgb = rec2020_to_rec709(hdr2020);
    return float4(rgb, 1.);
}
info: fname:PSI010_SRGB_Reverse rtype:float4 mapping:TARGET content:{
    float ratio = 65535. / 1023.;
    float y = image.Load(int3(frag_in.pos.xy, 0)).x * ratio;
    float cb = image1.Sample(def_sampler, frag_in.uv).x * ratio;
    float cr = image2.Sample(def_sampler, frag_in.uv).x * ratio;
    float3 yuv = float3(y, cb, cr);
    float3 rgb = YUV_to_RGB(yuv);
    rgb = srgb_nonlinear_to_linear(rgb);
    return float4(rgb, 1.);
}
info: fname:PSI010_PQ_2020_709_Reverse rtype:float4 mapping:TARGET content:{
    float ratio = 65535. / 1023.;
    float y = image.Load(int3(frag_in.pos.xy, 0)).x * ratio;
    float cb = image1.Sample(def_sampler, frag_in.uv).x * ratio;
    float cr = image2.Sample(def_sampler, frag_in.uv).x * ratio;
    float3 yuv = float3(y, cb, cr);
    float3 pq = YUV_to_RGB(yuv);
    float3 hdr2020 = st2084_to_linear_eetf(pq, hdr_lw, hdr_lmax) * maximum_over_sdr_white_nits;
    float3 rgb = rec2020_to_rec709(hdr2020);
    return float4(rgb, 1.);
}
info: fname:PSI010_HLG_2020_709_Reverse rtype:float4 mapping:TARGET content:{
    float ratio = 65535. / 1023.;
    float y = image.Load(int3(frag_in.pos.xy, 0)).x * ratio;
    float cb = image1.Sample(def_sampler, frag_in.uv).x * ratio;
    float cr = image2.Sample(def_sampler, frag_in.uv).x * ratio;
    float3 yuv = float3(y, cb, cr);
    float3 hlg = YUV_to_RGB(yuv);
    float3 hdr2020 = hlg_to_linear(hlg, hlg_exponent) * maximum_over_sdr_white_nits;
    float3 rgb = rec2020_to_rec709(hdr2020);
    return float4(rgb, 1.);
}
info: fname:PSP010_SRGB_Reverse rtype:float4 mapping:TARGET content:{
    float y = image.Load(int3(frag_in.pos.xy, 0)).x;
    float2 cbcr = image1.Sample(def_sampler, frag_in.uv).xy;
    float3 yuv_65535 = floor(float3(y, cbcr) * 65535. + 0.5);
    float3 yuv_1023 = floor(yuv_65535 * 0.015625);
    float3 yuv = yuv_1023 / 1023.;
    float3 rgb = YUV_to_RGB(yuv);
    rgb = srgb_nonlinear_to_linear(rgb);
    return float4(rgb, 1.);
}
info: fname:PSP010_PQ_2020_709_Reverse rtype:float4 mapping:TARGET content:{
    float y = image.Load(int3(frag_in.pos.xy, 0)).x;
    float2 cbcr = image1.Sample(def_sampler, frag_in.uv).xy;
    float3 yuv_65535 = floor(float3(y, cbcr) * 65535. + 0.5);
    float3 yuv_1023 = floor(yuv_65535 * 0.015625);
    float3 yuv = yuv_1023 / 1023.;
    float3 pq = YUV_to_RGB(yuv);
    float3 hdr2020 = st2084_to_linear_eetf(pq, hdr_lw, hdr_lmax) * maximum_over_sdr_white_nits;
    float3 rgb = rec2020_to_rec709(hdr2020);
    return float4(rgb, 1.);
}
info: fname:PSP010_HLG_2020_709_Reverse rtype:float4 mapping:TARGET content:{
    float y = image.Load(int3(frag_in.pos.xy, 0)).x;
    float2 cbcr = image1.Sample(def_sampler, frag_in.uv).xy;
    float3 yuv_65535 = floor(float3(y, cbcr) * 65535. + 0.5);
    float3 yuv_1023 = floor(yuv_65535 * 0.015625);
    float3 yuv = yuv_1023 / 1023.;
    float3 hlg = YUV_to_RGB(yuv);
    float3 hdr2020 = hlg_to_linear(hlg, hlg_exponent) * maximum_over_sdr_white_nits;
    float3 rgb = rec2020_to_rec709(hdr2020);
    return float4(rgb, 1.);
}
info: fname:compute_v210_reverse rtype:float3 mapping:(null) content:{
    uint x = uint(pos.x);
    uint packed_x = x % 6u;
    uint base_x = x / 6u * 4u;
    float y, cb, cr;
    if (packed_x == 0u)
    {
        float3 word0_rgb = image.Load(int3(base_x, pos.y, 0)).rgb;
        y = word0_rgb.y;
        cb = word0_rgb.x;
        cr = word0_rgb.z;
    }
    else if (packed_x == 1u)
    {
        float2 word0_rb = image.Load(int3(base_x, pos.y, 0)).rb;
        float2 word1_rg = image.Load(int3(base_x + 1u, pos.y, 0)).rg;
        y = word1_rg.x;
        cb = (word0_rb.x + word1_rg.y) * 0.5;
        cr = (word0_rb.y + image.Load(int3(base_x + 2u, pos.y, 0)).r) * 0.5;
    }
    else if (packed_x == 2u)
    {
        float2 word1_gb = image.Load(int3(base_x + 1u, pos.y, 0)).gb;
        y = word1_gb.y;
        cb = word1_gb.x;
        cr = image.Load(int3(base_x + 2u, pos.y, 0)).r;
    }
    else if (packed_x == 3u)
    {
        float2 word2_rb = image.Load(int3(base_x + 2u, pos.y, 0)).rb;
        y = image.Load(int3(base_x + 2u, pos.y, 0)).g;
        cb = (image.Load(int3(base_x + 1u, pos.y, 0)).g + word2_rb.y) * 0.5;
        cr = (word2_rb.x + image.Load(int3(base_x + 3u, pos.y, 0)).g) * 0.5;
    }
    else if (packed_x == 4u)
    {
        float2 word3_rg = image.Load(int3(base_x + 3u, pos.y, 0)).rg;
        y = word3_rg.x;
        cb = image.Load(int3(base_x + 2u, pos.y, 0)).b;
        cr = word3_rg.y;
    }
    else
    {
        float2 word3_gb = image.Load(int3(base_x + 3u, pos.y, 0)).gb;
        y = word3_gb.y;
        cb = image.Load(int3(base_x + 2u, pos.y, 0)).b;
        cr = word3_gb.x;
        uint base_x_4 = base_x + 4u;
        if ((pos.x + 1.) < width)
        {
            float2 word4_gb = image.Load(int3(base_x + 4u, pos.y, 0)).rb;
            cb = (cb + word4_gb.x) * 0.5;
            cr = (cr + word4_gb.y) * 0.5;
        }
    }
    float3 yuv_65535 = floor(float3(y, cb, cr) * 65535. + 0.5);
    float3 yuv_1023 = floor(yuv_65535 * 0.015625);
    float3 yuv = yuv_1023 / 1023.;
    float3 rgb = YUV_to_RGB(yuv);
    return rgb;
}
info: fname:PSV210_SRGB_Reverse rtype:float4 mapping:TARGET content:{
    float3 rgb = compute_v210_reverse(frag_in.pos.xy);
    rgb = srgb_nonlinear_to_linear(rgb);
    return float4(rgb, 1.);
}
info: fname:PSV210_PQ_2020_709_Reverse rtype:float4 mapping:TARGET content:{
    float3 pq = compute_v210_reverse(frag_in.pos.xy);
    float3 hdr2020 = st2084_to_linear_eetf(pq, hdr_lw, hdr_lmax) * maximum_over_sdr_white_nits;
    float3 rgb = rec2020_to_rec709(hdr2020);
    return float4(rgb, 1.);
}
info: fname:PSV210_HLG_2020_709_Reverse rtype:float4 mapping:TARGET content:{
    float3 hlg = compute_v210_reverse(frag_in.pos.xy);
    float3 hdr2020 = hlg_to_linear(hlg, hlg_exponent) * maximum_over_sdr_white_nits;
    float3 rgb = rec2020_to_rec709(hdr2020);
    return float4(rgb, 1.);
}
info: fname:PSY800_Limited rtype:float3 mapping:TARGET content:{
    float limited = image.Load(int3(frag_in.pos.xy, 0)).x;
    float full = (255.0 / 219.0) * limited - (16.0 / 219.0);
    return float3(full, full, full);
}
info: fname:PSY800_Full rtype:float3 mapping:TARGET content:{
    float3 full = image.Load(int3(frag_in.pos.xy, 0)).xxx;
    return full;
}
info: fname:PSRGB_Limited rtype:float4 mapping:TARGET content:{
    float4 rgba = image.Load(int3(frag_in.pos.xy, 0));
    rgba.rgb = (255.0 / 219.0) * rgba.rgb - (16.0 / 219.0);
    return rgba;
}
info: fname:PSBGR3_Limited rtype:float3 mapping:TARGET content:{
    float x = frag_in.pos.x * 3.0;
    float y = frag_in.pos.y;
    float b = image.Load(int3(x - 1.0, y, 0)).x;
    float g = image.Load(int3(x, y, 0)).x;
    float r = image.Load(int3(x + 1.0, y, 0)).x;
    float3 rgb = float3(r, g, b);
    rgb = (255.0 / 219.0) * rgb - (16.0 / 219.0);
    return rgb;
}
info: fname:PSBGR3_Full rtype:float3 mapping:TARGET content:{
    float x = frag_in.pos.x * 3.0;
    float y = frag_in.pos.y;
    float b = image.Load(int3(x - 1.0, y, 0)).x;
    float g = image.Load(int3(x, y, 0)).x;
    float r = image.Load(int3(x + 1.0, y, 0)).x;
    float3 rgb = float3(r, g, b);
    return rgb;
}
info: ======params =======
info: fname:width type:float
info: fname:height type:float
info: fname:width_i type:float
info: fname:height_i type:float
info: fname:width_d2 type:float
info: fname:height_d2 type:float
info: fname:width_x2_i type:float
info: fname:height_x2_i type:float
info: fname:maximum_over_sdr_white_nits type:float
info: fname:sdr_white_nits_over_maximum type:float
info: fname:hlg_exponent type:float
info: fname:hdr_lw type:float
info: fname:hdr_lmax type:float
info: fname:color_vec0 type:float4
info: fname:color_vec1 type:float4
info: fname:color_vec2 type:float4
info: fname:color_range_min type:float3
info: fname:color_range_max type:float3
info: fname:image type:texture2d
info: fname:image1 type:texture2d
info: fname:image2 type:texture2d
info: fname:image3 type:texture2d
info: ======structs =======
info: fname:FragPos
info: fname:VertTexPos
info: fname:VertTexTexPos
info: fname:VertTexPosWide
info: fname:VertTexPosWideWide
info: fname:FragTex
info: fname:FragTexTex
info: fname:FragTexWide
info: fname:FragTexWideWide
info: ======samplers =======
info: fname:def_sampler
info: ======techniques =======
info: fname:Planar_Y
info: fname:Planar_U
info: fname:Planar_V
info: fname:Planar_U_Left
info: fname:Planar_V_Left
info: fname:NV12_Y
info: fname:NV12_UV
info: fname:I010_PQ_Y
info: fname:I010_HLG_Y
info: fname:I010_SRGB_Y
info: fname:I010_PQ_U
info: fname:I010_HLG_U
info: fname:I010_SRGB_U
info: fname:I010_PQ_V
info: fname:I010_HLG_V
info: fname:I010_SRGB_V
info: fname:P010_PQ_Y
info: fname:P010_HLG_Y
info: fname:P010_SRGB_Y
info: fname:P010_PQ_UV
info: fname:P010_HLG_UV
info: fname:P010_SRGB_UV
info: fname:P216_PQ_Y
info: fname:P216_HLG_Y
info: fname:P216_SRGB_Y
info: fname:P216_PQ_UV
info: fname:P216_HLG_UV
info: fname:P216_SRGB_UV
info: fname:P416_PQ_Y
info: fname:P416_HLG_Y
info: fname:P416_SRGB_Y
info: fname:P416_PQ_UV
info: fname:P416_HLG_UV
info: fname:P416_SRGB_UV
info: fname:UYVY_Reverse
info: fname:YUY2_Reverse
info: fname:YUY2_PQ_Reverse
info: fname:YUY2_HLG_Reverse
info: fname:YVYU_Reverse
info: fname:I420_Reverse
info: fname:I420_PQ_Reverse
info: fname:I420_HLG_Reverse
info: fname:I40A_Reverse
info: fname:I422_Reverse
info: fname:I210_Reverse
info: fname:I210_PQ_Reverse
info: fname:I210_HLG_Reverse
info: fname:I42A_Reverse
info: fname:I444_Reverse
info: fname:I412_Reverse
info: fname:I412_PQ_Reverse
info: fname:I412_HLG_Reverse
info: fname:YUVA_Reverse
info: fname:YA2L_Reverse
info: fname:AYUV_Reverse
info: fname:NV12_Reverse
info: fname:NV12_PQ_Reverse
info: fname:NV12_HLG_Reverse
info: fname:I010_SRGB_Reverse
info: fname:I010_PQ_2020_709_Reverse
info: fname:I010_HLG_2020_709_Reverse
info: fname:P010_SRGB_Reverse
info: fname:P010_PQ_2020_709_Reverse
info: fname:P010_HLG_2020_709_Reverse
info: fname:V210_SRGB_Reverse
info: fname:V210_PQ_2020_709_Reverse
info: fname:V210_HLG_2020_709_Reverse
info: fname:Y800_Limited
info: fname:Y800_Full
info: fname:RGB_Limited
info: fname:BGR3_Limited
info: fname:BGR3_Full
info: ======files =======
info: ======tokens =======
info: ======techniques =======
info: tname:Planar_Y
info: tname:(null)
info: tname:Planar_U
info: tname:(null)
info: tname:Planar_V
info: tname:(null)
info: tname:Planar_U_Left
info: tname:(null)
info: tname:Planar_V_Left
info: tname:(null)
info: tname:NV12_Y
info: tname:(null)
info: tname:NV12_UV
info: tname:(null)
info: tname:I010_PQ_Y
info: tname:(null)
info: tname:I010_HLG_Y
info: tname:(null)
info: tname:I010_SRGB_Y
info: tname:(null)
info: tname:I010_PQ_U
info: tname:(null)
info: tname:I010_HLG_U
info: tname:(null)
info: tname:I010_SRGB_U
info: tname:(null)
info: tname:I010_PQ_V
info: tname:(null)
info: tname:I010_HLG_V
info: tname:(null)
info: tname:I010_SRGB_V
info: tname:(null)
info: tname:P010_PQ_Y
info: tname:(null)
info: tname:P010_HLG_Y
info: tname:(null)
info: tname:P010_SRGB_Y
info: tname:(null)
info: tname:P010_PQ_UV
info: tname:(null)
info: tname:P010_HLG_UV
info: tname:(null)
info: tname:P010_SRGB_UV
info: tname:(null)
info: tname:P216_PQ_Y
info: tname:(null)
info: tname:P216_HLG_Y
info: tname:(null)
info: tname:P216_SRGB_Y
info: tname:(null)
info: tname:P216_PQ_UV
info: tname:(null)
info: tname:P216_HLG_UV
info: tname:(null)
info: tname:P216_SRGB_UV
info: tname:(null)
info: tname:P416_PQ_Y
info: tname:(null)
info: tname:P416_HLG_Y
info: tname:(null)
info: tname:P416_SRGB_Y
info: tname:(null)
info: tname:P416_PQ_UV
info: tname:(null)
info: tname:P416_HLG_UV
info: tname:(null)
info: tname:P416_SRGB_UV
info: tname:(null)
info: tname:UYVY_Reverse
info: tname:(null)
info: tname:YUY2_Reverse
info: tname:(null)
info: tname:YUY2_PQ_Reverse
info: tname:(null)
info: tname:YUY2_HLG_Reverse
info: tname:(null)
info: tname:YVYU_Reverse
info: tname:(null)
info: tname:I420_Reverse
info: tname:(null)
info: tname:I420_PQ_Reverse
info: tname:(null)
info: tname:I420_HLG_Reverse
info: tname:(null)
info: tname:I40A_Reverse
info: tname:(null)
info: tname:I422_Reverse
info: tname:(null)
info: tname:I210_Reverse
info: tname:(null)
info: tname:I210_PQ_Reverse
info: tname:(null)
info: tname:I210_HLG_Reverse
info: tname:(null)
info: tname:I42A_Reverse
info: tname:(null)
info: tname:I444_Reverse
info: tname:(null)
info: tname:I412_Reverse
info: tname:(null)
info: tname:I412_PQ_Reverse
info: tname:(null)
info: tname:I412_HLG_Reverse
info: tname:(null)
info: tname:YUVA_Reverse
info: tname:(null)
info: tname:YA2L_Reverse
info: tname:(null)
info: tname:AYUV_Reverse
info: tname:(null)
info: tname:NV12_Reverse
info: tname:(null)
info: tname:NV12_PQ_Reverse
info: tname:(null)
info: tname:NV12_HLG_Reverse
info: tname:(null)
info: tname:I010_SRGB_Reverse
info: tname:(null)
info: tname:I010_PQ_2020_709_Reverse
info: tname:(null)
info: tname:I010_HLG_2020_709_Reverse
info: tname:(null)
info: tname:P010_SRGB_Reverse
info: tname:(null)
info: tname:P010_PQ_2020_709_Reverse
info: tname:(null)
info: tname:P010_HLG_2020_709_Reverse
info: tname:(null)
info: tname:V210_SRGB_Reverse
info: tname:(null)
info: tname:V210_PQ_2020_709_Reverse
info: tname:(null)
info: tname:V210_HLG_2020_709_Reverse
info: tname:(null)
info: tname:Y800_Limited
info: tname:(null)
info: tname:Y800_Full
info: tname:(null)
info: tname:RGB_Limited
info: tname:(null)
info: tname:BGR3_Limited
info: tname:(null)
info: tname:BGR3_Full
info: tname:(null)
info: ======params =======
info: tname:width
info: tname:height
info: tname:width_i
info: tname:height_i
info: tname:width_d2
info: tname:height_d2
info: tname:width_x2_i
info: tname:height_x2_i
info: tname:maximum_over_sdr_white_nits
info: tname:sdr_white_nits_over_maximum
info: tname:hlg_exponent
info: tname:hdr_lw
info: tname:hdr_lmax
info: tname:color_vec0
info: tname:color_vec1
info: tname:color_vec2
info: tname:color_range_min
info: tname:color_range_max
info: tname:image
info: tname:image1
info: tname:image2
info: tname:image3
info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform vec2 base_dimension;
uniform mat4x4 ViewProj;

in vec4 _input_attrib0;
in vec2 _input_attrib1;

out vec2 _vertex_shader_attrib0;

out gl_PerVertex {
    vec4 gl_Position;
};

struct VertOut {
    vec2 uv;
    vec4 pos;
};

struct VertData {
    vec4 pos;
    vec2 uv;
};

VertOut VSDefault(VertData v_in)
{
    VertOut vert_out;
    vert_out.uv = v_in.uv * base_dimension;
    vert_out.pos = ((vec4(v_in.pos.xyz, 1.0)) * (ViewProj));
    return vert_out;
}

VertOut _main_wrap(VertData v_in)
{
    return VSDefault(v_in);
}

void main(void)
{
    VertData v_in;
    VertOut outputval;

    v_in.pos = _input_attrib0;
    v_in.uv = _input_attrib1;

    outputval = _main_wrap(v_in);

    _vertex_shader_attrib0 = outputval.uv;
    gl_Position = outputval.pos;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform vec2 base_dimension_i;
uniform vec2 base_dimension;
uniform sampler2D image;
uniform float undistort_factor;

in vec2 _vertex_shader_attrib0;

out vec4 _pixel_shader_attrib0;

struct FragData {
    vec2 uv;
};

vec4 weight4(float x)
{
     
    return vec4(
        ((-0.75 * x + 1.5) * x - 0.75) * x,
        (1.25 * x - 2.25) * x * x + 1.0,
        ((-1.25 * x + 1.5) * x + 0.75) * x,
        (0.75 * x - 0.75) * x * x);
}

float AspectUndistortX(float x, float a)
{
     
    return (1.0 - a) * (x * x * x * x * x) + a * x;
}

float AspectUndistortU(float u)
{
     
    return AspectUndistortX((u - 0.5) * 2.0, undistort_factor) * 0.5 + 0.5;
}

vec2 undistort_coord(float xpos, float ypos)
{
    return vec2(AspectUndistortU(xpos), ypos);
}

vec4 undistort_pixel(float xpos, float ypos)
{
    return texture(image, undistort_coord(xpos, ypos));
}

vec4 undistort_line(vec4 xpos, float ypos, vec4 rowtaps)
{
    return undistort_pixel(xpos.x, ypos) * rowtaps.x +
           undistort_pixel(xpos.y, ypos) * rowtaps.y +
           undistort_pixel(xpos.z, ypos) * rowtaps.z +
           undistort_pixel(xpos.w, ypos) * rowtaps.w;
}

vec4 DrawBicubic(FragData f_in, bool undistort)
{
    vec2 pos = f_in.uv;
    vec2 pos1 = floor(pos - 0.5) + 0.5;
    vec2 f = pos - pos1;

    vec4 rowtaps = weight4(f.x);
    vec4 coltaps = weight4(f.y);

    vec2 uv1 = pos1 * base_dimension_i;
    vec2 uv0 = uv1 - base_dimension_i;
    vec2 uv2 = uv1 + base_dimension_i;
    vec2 uv3 = uv2 + base_dimension_i;

    if (undistort) {
        vec4 xpos = vec4(uv0.x, uv1.x, uv2.x, uv3.x);
        return undistort_line(xpos, uv0.y, rowtaps) * coltaps.x +
               undistort_line(xpos, uv1.y, rowtaps) * coltaps.y +
               undistort_line(xpos, uv2.y, rowtaps) * coltaps.z +
               undistort_line(xpos, uv3.y, rowtaps) * coltaps.w;
    }

    float u_weight_sum = rowtaps.y + rowtaps.z;
    float u_middle_offset = rowtaps.z * base_dimension_i.x / u_weight_sum;
    float u_middle = uv1.x + u_middle_offset;

    float v_weight_sum = coltaps.y + coltaps.z;
    float v_middle_offset = coltaps.z * base_dimension_i.y / v_weight_sum;
    float v_middle = uv1.y + v_middle_offset;

    ivec2 coord_top_left = ivec2(max(uv0 * base_dimension, 0.5));
    ivec2 coord_bottom_right = ivec2(min(uv3 * base_dimension, base_dimension - 0.5));

    vec4 top = obs_load_2d(image, ivec3(coord_top_left, 0)) * rowtaps.x;
    top += texture(image, vec2(u_middle, uv0.y)) * u_weight_sum;
    top += obs_load_2d(image, ivec3(coord_bottom_right.x, coord_top_left.y, 0)) * rowtaps.w;
    vec4 total = top * coltaps.x;

    vec4 middle = texture(image, vec2(uv0.x, v_middle)) * rowtaps.x;
    middle += texture(image, vec2(u_middle, v_middle)) * u_weight_sum;
    middle += texture(image, vec2(uv3.x, v_middle)) * rowtaps.w;
    total += middle * v_weight_sum;

    vec4 bottom = obs_load_2d(image, ivec3(coord_top_left.x, coord_bottom_right.y, 0)) * rowtaps.x;
    bottom += texture(image, vec2(u_middle, uv3.y)) * u_weight_sum;
    bottom += obs_load_2d(image, ivec3(coord_bottom_right, 0)) * rowtaps.w;
    total += bottom * coltaps.w;

    return total;
}

vec4 PSDrawBicubicRGBA(FragData f_in, bool undistort)
{
    return DrawBicubic(f_in, undistort);
}

vec4 _main_wrap(FragData f_in)
{
    return PSDrawBicubicRGBA(f_in,false);
}

void main(void)
{
    FragData f_in;
    f_in.uv = _vertex_shader_attrib0;

    _pixel_shader_attrib0 = _main_wrap(f_in);
}

info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform vec2 base_dimension;
uniform mat4x4 ViewProj;

in vec4 _input_attrib0;
in vec2 _input_attrib1;

out vec2 _vertex_shader_attrib0;

out gl_PerVertex {
    vec4 gl_Position;
};

struct VertOut {
    vec2 uv;
    vec4 pos;
};

struct VertData {
    vec4 pos;
    vec2 uv;
};

VertOut VSDefault(VertData v_in)
{
    VertOut vert_out;
    vert_out.uv = v_in.uv * base_dimension;
    vert_out.pos = ((vec4(v_in.pos.xyz, 1.0)) * (ViewProj));
    return vert_out;
}

VertOut _main_wrap(VertData v_in)
{
    return VSDefault(v_in);
}

void main(void)
{
    VertData v_in;
    VertOut outputval;

    v_in.pos = _input_attrib0;
    v_in.uv = _input_attrib1;

    outputval = _main_wrap(v_in);

    _vertex_shader_attrib0 = outputval.uv;
    gl_Position = outputval.pos;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform float multiplier;
uniform vec2 base_dimension_i;
uniform vec2 base_dimension;
uniform sampler2D image;
uniform float undistort_factor;

in vec2 _vertex_shader_attrib0;

out vec4 _pixel_shader_attrib0;

struct FragData {
    vec2 uv;
};

vec4 weight4(float x)
{
     
    return vec4(
        ((-0.75 * x + 1.5) * x - 0.75) * x,
        (1.25 * x - 2.25) * x * x + 1.0,
        ((-1.25 * x + 1.5) * x + 0.75) * x,
        (0.75 * x - 0.75) * x * x);
}

float AspectUndistortX(float x, float a)
{
     
    return (1.0 - a) * (x * x * x * x * x) + a * x;
}

float AspectUndistortU(float u)
{
     
    return AspectUndistortX((u - 0.5) * 2.0, undistort_factor) * 0.5 + 0.5;
}

vec2 undistort_coord(float xpos, float ypos)
{
    return vec2(AspectUndistortU(xpos), ypos);
}

vec4 undistort_pixel(float xpos, float ypos)
{
    return texture(image, undistort_coord(xpos, ypos));
}

vec4 undistort_line(vec4 xpos, float ypos, vec4 rowtaps)
{
    return undistort_pixel(xpos.x, ypos) * rowtaps.x +
           undistort_pixel(xpos.y, ypos) * rowtaps.y +
           undistort_pixel(xpos.z, ypos) * rowtaps.z +
           undistort_pixel(xpos.w, ypos) * rowtaps.w;
}

vec4 DrawBicubic(FragData f_in, bool undistort)
{
    vec2 pos = f_in.uv;
    vec2 pos1 = floor(pos - 0.5) + 0.5;
    vec2 f = pos - pos1;

    vec4 rowtaps = weight4(f.x);
    vec4 coltaps = weight4(f.y);

    vec2 uv1 = pos1 * base_dimension_i;
    vec2 uv0 = uv1 - base_dimension_i;
    vec2 uv2 = uv1 + base_dimension_i;
    vec2 uv3 = uv2 + base_dimension_i;

    if (undistort) {
        vec4 xpos = vec4(uv0.x, uv1.x, uv2.x, uv3.x);
        return undistort_line(xpos, uv0.y, rowtaps) * coltaps.x +
               undistort_line(xpos, uv1.y, rowtaps) * coltaps.y +
               undistort_line(xpos, uv2.y, rowtaps) * coltaps.z +
               undistort_line(xpos, uv3.y, rowtaps) * coltaps.w;
    }

    float u_weight_sum = rowtaps.y + rowtaps.z;
    float u_middle_offset = rowtaps.z * base_dimension_i.x / u_weight_sum;
    float u_middle = uv1.x + u_middle_offset;

    float v_weight_sum = coltaps.y + coltaps.z;
    float v_middle_offset = coltaps.z * base_dimension_i.y / v_weight_sum;
    float v_middle = uv1.y + v_middle_offset;

    ivec2 coord_top_left = ivec2(max(uv0 * base_dimension, 0.5));
    ivec2 coord_bottom_right = ivec2(min(uv3 * base_dimension, base_dimension - 0.5));

    vec4 top = obs_load_2d(image, ivec3(coord_top_left, 0)) * rowtaps.x;
    top += texture(image, vec2(u_middle, uv0.y)) * u_weight_sum;
    top += obs_load_2d(image, ivec3(coord_bottom_right.x, coord_top_left.y, 0)) * rowtaps.w;
    vec4 total = top * coltaps.x;

    vec4 middle = texture(image, vec2(uv0.x, v_middle)) * rowtaps.x;
    middle += texture(image, vec2(u_middle, v_middle)) * u_weight_sum;
    middle += texture(image, vec2(uv3.x, v_middle)) * rowtaps.w;
    total += middle * v_weight_sum;

    vec4 bottom = obs_load_2d(image, ivec3(coord_top_left.x, coord_bottom_right.y, 0)) * rowtaps.x;
    bottom += texture(image, vec2(u_middle, uv3.y)) * u_weight_sum;
    bottom += obs_load_2d(image, ivec3(coord_bottom_right, 0)) * rowtaps.w;
    total += bottom * coltaps.w;

    return total;
}

vec4 PSDrawBicubicRGBAMultiply(FragData f_in, bool undistort)
{
    vec4 rgba = DrawBicubic(f_in, undistort);
    rgba.rgb *= multiplier;
    return rgba;
}

vec4 _main_wrap(FragData f_in)
{
    return PSDrawBicubicRGBAMultiply(f_in,false);
}

void main(void)
{
    FragData f_in;
    f_in.uv = _vertex_shader_attrib0;

    _pixel_shader_attrib0 = _main_wrap(f_in);
}

info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform vec2 base_dimension;
uniform mat4x4 ViewProj;

in vec4 _input_attrib0;
in vec2 _input_attrib1;

out vec2 _vertex_shader_attrib0;

out gl_PerVertex {
    vec4 gl_Position;
};

struct VertOut {
    vec2 uv;
    vec4 pos;
};

struct VertData {
    vec4 pos;
    vec2 uv;
};

VertOut VSDefault(VertData v_in)
{
    VertOut vert_out;
    vert_out.uv = v_in.uv * base_dimension;
    vert_out.pos = ((vec4(v_in.pos.xyz, 1.0)) * (ViewProj));
    return vert_out;
}

VertOut _main_wrap(VertData v_in)
{
    return VSDefault(v_in);
}

void main(void)
{
    VertData v_in;
    VertOut outputval;

    v_in.pos = _input_attrib0;
    v_in.uv = _input_attrib1;

    outputval = _main_wrap(v_in);

    _vertex_shader_attrib0 = outputval.uv;
    gl_Position = outputval.pos;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform vec2 base_dimension_i;
uniform vec2 base_dimension;
uniform sampler2D image;
uniform float undistort_factor;

in vec2 _vertex_shader_attrib0;

out vec4 _pixel_shader_attrib0;

struct FragData {
    vec2 uv;
};

vec4 weight4(float x)
{
     
    return vec4(
        ((-0.75 * x + 1.5) * x - 0.75) * x,
        (1.25 * x - 2.25) * x * x + 1.0,
        ((-1.25 * x + 1.5) * x + 0.75) * x,
        (0.75 * x - 0.75) * x * x);
}

float AspectUndistortX(float x, float a)
{
     
    return (1.0 - a) * (x * x * x * x * x) + a * x;
}

float AspectUndistortU(float u)
{
     
    return AspectUndistortX((u - 0.5) * 2.0, undistort_factor) * 0.5 + 0.5;
}

vec2 undistort_coord(float xpos, float ypos)
{
    return vec2(AspectUndistortU(xpos), ypos);
}

vec4 undistort_pixel(float xpos, float ypos)
{
    return texture(image, undistort_coord(xpos, ypos));
}

vec4 undistort_line(vec4 xpos, float ypos, vec4 rowtaps)
{
    return undistort_pixel(xpos.x, ypos) * rowtaps.x +
           undistort_pixel(xpos.y, ypos) * rowtaps.y +
           undistort_pixel(xpos.z, ypos) * rowtaps.z +
           undistort_pixel(xpos.w, ypos) * rowtaps.w;
}

vec4 DrawBicubic(FragData f_in, bool undistort)
{
    vec2 pos = f_in.uv;
    vec2 pos1 = floor(pos - 0.5) + 0.5;
    vec2 f = pos - pos1;

    vec4 rowtaps = weight4(f.x);
    vec4 coltaps = weight4(f.y);

    vec2 uv1 = pos1 * base_dimension_i;
    vec2 uv0 = uv1 - base_dimension_i;
    vec2 uv2 = uv1 + base_dimension_i;
    vec2 uv3 = uv2 + base_dimension_i;

    if (undistort) {
        vec4 xpos = vec4(uv0.x, uv1.x, uv2.x, uv3.x);
        return undistort_line(xpos, uv0.y, rowtaps) * coltaps.x +
               undistort_line(xpos, uv1.y, rowtaps) * coltaps.y +
               undistort_line(xpos, uv2.y, rowtaps) * coltaps.z +
               undistort_line(xpos, uv3.y, rowtaps) * coltaps.w;
    }

    float u_weight_sum = rowtaps.y + rowtaps.z;
    float u_middle_offset = rowtaps.z * base_dimension_i.x / u_weight_sum;
    float u_middle = uv1.x + u_middle_offset;

    float v_weight_sum = coltaps.y + coltaps.z;
    float v_middle_offset = coltaps.z * base_dimension_i.y / v_weight_sum;
    float v_middle = uv1.y + v_middle_offset;

    ivec2 coord_top_left = ivec2(max(uv0 * base_dimension, 0.5));
    ivec2 coord_bottom_right = ivec2(min(uv3 * base_dimension, base_dimension - 0.5));

    vec4 top = obs_load_2d(image, ivec3(coord_top_left, 0)) * rowtaps.x;
    top += texture(image, vec2(u_middle, uv0.y)) * u_weight_sum;
    top += obs_load_2d(image, ivec3(coord_bottom_right.x, coord_top_left.y, 0)) * rowtaps.w;
    vec4 total = top * coltaps.x;

    vec4 middle = texture(image, vec2(uv0.x, v_middle)) * rowtaps.x;
    middle += texture(image, vec2(u_middle, v_middle)) * u_weight_sum;
    middle += texture(image, vec2(uv3.x, v_middle)) * rowtaps.w;
    total += middle * v_weight_sum;

    vec4 bottom = obs_load_2d(image, ivec3(coord_top_left.x, coord_bottom_right.y, 0)) * rowtaps.x;
    bottom += texture(image, vec2(u_middle, uv3.y)) * u_weight_sum;
    bottom += obs_load_2d(image, ivec3(coord_bottom_right, 0)) * rowtaps.w;
    total += bottom * coltaps.w;

    return total;
}

vec3 rec709_to_rec2020(vec3 v)
{
    float r = dot(v, vec3(0.62740389593469903, 0.32928303837788370, 0.043313065687417225));
    float g = dot(v, vec3(0.069097289358232075, 0.91954039507545871, 0.011362315566309178));
    float b = dot(v, vec3(0.016391438875150280, 0.088013307877225749, 0.89559525324762401));
    return vec3(r, g, b);
}

float srgb_nonlinear_to_linear_channel(float u)
{
    return (u <= 0.04045) ? (u / 12.92) : pow((u + 0.055) / 1.055, 2.4);
}

vec3 srgb_nonlinear_to_linear(vec3 v)
{
    return vec3(srgb_nonlinear_to_linear_channel(v.r), srgb_nonlinear_to_linear_channel(v.g), srgb_nonlinear_to_linear_channel(v.b));
}

vec3 reinhard(vec3 rgb)
{
    rgb /= rgb + vec3(1., 1., 1.);
    rgb =
info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform vec2 base_dimension;
uniform mat4x4 ViewProj;

in vec4 _input_attrib0;
in vec2 _input_attrib1;

out vec2 _vertex_shader_attrib0;

out gl_PerVertex {
    vec4 gl_Position;
};

struct VertOut {
    vec2 uv;
    vec4 pos;
};

struct VertData {
    vec4 pos;
    vec2 uv;
};

VertOut VSDefault(VertData v_in)
{
    VertOut vert_out;
    vert_out.uv = v_in.uv * base_dimension;
    vert_out.pos = ((vec4(v_in.pos.xyz, 1.0)) * (ViewProj));
    return vert_out;
}

VertOut _main_wrap(VertData v_in)
{
    return VSDefault(v_in);
}

void main(void)
{
    VertData v_in;
    VertOut outputval;

    v_in.pos = _input_attrib0;
    v_in.uv = _input_attrib1;

    outputval = _main_wrap(v_in);

    _vertex_shader_attrib0 = outputval.uv;
    gl_Position = outputval.pos;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform float multiplier;
uniform vec2 base_dimension_i;
uniform vec2 base_dimension;
uniform sampler2D image;
uniform float undistort_factor;

in vec2 _vertex_shader_attrib0;

out vec4 _pixel_shader_attrib0;

struct FragData {
    vec2 uv;
};

vec4 weight4(float x)
{
     
    return vec4(
        ((-0.75 * x + 1.5) * x - 0.75) * x,
        (1.25 * x - 2.25) * x * x + 1.0,
        ((-1.25 * x + 1.5) * x + 0.75) * x,
        (0.75 * x - 0.75) * x * x);
}

float AspectUndistortX(float x, float a)
{
     
    return (1.0 - a) * (x * x * x * x * x) + a * x;
}

float AspectUndistortU(float u)
{
     
    return AspectUndistortX((u - 0.5) * 2.0, undistort_factor) * 0.5 + 0.5;
}

vec2 undistort_coord(float xpos, float ypos)
{
    return vec2(AspectUndistortU(xpos), ypos);
}

vec4 undistort_pixel(float xpos, float ypos)
{
    return texture(image, undistort_coord(xpos, ypos));
}

vec4 undistort_line(vec4 xpos, float ypos, vec4 rowtaps)
{
    return undistort_pixel(xpos.x, ypos) * rowtaps.x +
           undistort_pixel(xpos.y, ypos) * rowtaps.y +
           undistort_pixel(xpos.z, ypos) * rowtaps.z +
           undistort_pixel(xpos.w, ypos) * rowtaps.w;
}

vec4 DrawBicubic(FragData f_in, bool undistort)
{
    vec2 pos = f_in.uv;
    vec2 pos1 = floor(pos - 0.5) + 0.5;
    vec2 f = pos - pos1;

    vec4 rowtaps = weight4(f.x);
    vec4 coltaps = weight4(f.y);

    vec2 uv1 = pos1 * base_dimension_i;
    vec2 uv0 = uv1 - base_dimension_i;
    vec2 uv2 = uv1 + base_dimension_i;
    vec2 uv3 = uv2 + base_dimension_i;

    if (undistort) {
        vec4 xpos = vec4(uv0.x, uv1.x, uv2.x, uv3.x);
        return undistort_line(xpos, uv0.y, rowtaps) * coltaps.x +
               undistort_line(xpos, uv1.y, rowtaps) * coltaps.y +
               undistort_line(xpos, uv2.y, rowtaps) * coltaps.z +
               undistort_line(xpos, uv3.y, rowtaps) * coltaps.w;
    }

    float u_weight_sum = rowtaps.y + rowtaps.z;
    float u_middle_offset = rowtaps.z * base_dimension_i.x / u_weight_sum;
    float u_middle = uv1.x + u_middle_offset;

    float v_weight_sum = coltaps.y + coltaps.z;
    float v_middle_offset = coltaps.z * base_dimension_i.y / v_weight_sum;
    float v_middle = uv1.y + v_middle_offset;

    ivec2 coord_top_left = ivec2(max(uv0 * base_dimension, 0.5));
    ivec2 coord_bottom_right = ivec2(min(uv3 * base_dimension, base_dimension - 0.5));

    vec4 top = obs_load_2d(image, ivec3(coord_top_left, 0)) * rowtaps.x;
    top += texture(image, vec2(u_middle, uv0.y)) * u_weight_sum;
    top += obs_load_2d(image, ivec3(coord_bottom_right.x, coord_top_left.y, 0)) * rowtaps.w;
    vec4 total = top * coltaps.x;

    vec4 middle = texture(image, vec2(uv0.x, v_middle)) * rowtaps.x;
    middle += texture(image, vec2(u_middle, v_middle)) * u_weight_sum;
    middle += texture(image, vec2(uv3.x, v_middle)) * rowtaps.w;
    total += middle * v_weight_sum;

    vec4 bottom = obs_load_2d(image, ivec3(coord_top_left.x, coord_bottom_right.y, 0)) * rowtaps.x;
    bottom += texture(image, vec2(u_middle, uv3.y)) * u_weight_sum;
    bottom += obs_load_2d(image, ivec3(coord_bottom_right, 0)) * rowtaps.w;
    total += bottom * coltaps.w;

    return total;
}

vec3 rec709_to_rec2020(vec3 v)
{
    float r = dot(v, vec3(0.62740389593469903, 0.32928303837788370, 0.043313065687417225));
    float g = dot(v, vec3(0.069097289358232075, 0.91954039507545871, 0.011362315566309178));
    float b = dot(v, vec3(0.016391438875150280, 0.088013307877225749, 0.89559525324762401));
    return vec3(r, g, b);
}

float srgb_nonlinear_to_linear_channel(float u)
{
    return (u <= 0.04045) ? (u / 12.92) : pow((u + 0.055) / 1.055, 2.4);
}

vec3 srgb_nonlinear_to_linear(vec3 v)
{
    return vec3(srgb_nonlinear_to_linear_channel(v.r), srgb_nonlinear_to_linear_channel(v.g), srgb_nonlinear_to_linear_channel(v.b));
}

vec3 reinhard(vec3 rgb)
{
    rgb /= rgb
info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform vec2 base_dimension;
uniform mat4x4 ViewProj;

in vec4 _input_attrib0;
in vec2 _input_attrib1;

out vec2 _vertex_shader_attrib0;

out gl_PerVertex {
    vec4 gl_Position;
};

struct VertOut {
    vec2 uv;
    vec4 pos;
};

struct VertData {
    vec4 pos;
    vec2 uv;
};

VertOut VSDefault(VertData v_in)
{
    VertOut vert_out;
    vert_out.uv = v_in.uv * base_dimension;
    vert_out.pos = ((vec4(v_in.pos.xyz, 1.0)) * (ViewProj));
    return vert_out;
}

VertOut _main_wrap(VertData v_in)
{
    return VSDefault(v_in);
}

void main(void)
{
    VertData v_in;
    VertOut outputval;

    v_in.pos = _input_attrib0;
    v_in.uv = _input_attrib1;

    outputval = _main_wrap(v_in);

    _vertex_shader_attrib0 = outputval.uv;
    gl_Position = outputval.pos;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform vec2 base_dimension_i;
uniform vec2 base_dimension;
uniform sampler2D image;
uniform float undistort_factor;

in vec2 _vertex_shader_attrib0;

out vec4 _pixel_shader_attrib0;

struct FragData {
    vec2 uv;
};

vec4 weight4(float x)
{
     
    return vec4(
        ((-0.75 * x + 1.5) * x - 0.75) * x,
        (1.25 * x - 2.25) * x * x + 1.0,
        ((-1.25 * x + 1.5) * x + 0.75) * x,
        (0.75 * x - 0.75) * x * x);
}

float AspectUndistortX(float x, float a)
{
     
    return (1.0 - a) * (x * x * x * x * x) + a * x;
}

float AspectUndistortU(float u)
{
     
    return AspectUndistortX((u - 0.5) * 2.0, undistort_factor) * 0.5 + 0.5;
}

vec2 undistort_coord(float xpos, float ypos)
{
    return vec2(AspectUndistortU(xpos), ypos);
}

vec4 undistort_pixel(float xpos, float ypos)
{
    return texture(image, undistort_coord(xpos, ypos));
}

vec4 undistort_line(vec4 xpos, float ypos, vec4 rowtaps)
{
    return undistort_pixel(xpos.x, ypos) * rowtaps.x +
           undistort_pixel(xpos.y, ypos) * rowtaps.y +
           undistort_pixel(xpos.z, ypos) * rowtaps.z +
           undistort_pixel(xpos.w, ypos) * rowtaps.w;
}

vec4 DrawBicubic(FragData f_in, bool undistort)
{
    vec2 pos = f_in.uv;
    vec2 pos1 = floor(pos - 0.5) + 0.5;
    vec2 f = pos - pos1;

    vec4 rowtaps = weight4(f.x);
    vec4 coltaps = weight4(f.y);

    vec2 uv1 = pos1 * base_dimension_i;
    vec2 uv0 = uv1 - base_dimension_i;
    vec2 uv2 = uv1 + base_dimension_i;
    vec2 uv3 = uv2 + base_dimension_i;

    if (undistort) {
        vec4 xpos = vec4(uv0.x, uv1.x, uv2.x, uv3.x);
        return undistort_line(xpos, uv0.y, rowtaps) * coltaps.x +
               undistort_line(xpos, uv1.y, rowtaps) * coltaps.y +
               undistort_line(xpos, uv2.y, rowtaps) * coltaps.z +
               undistort_line(xpos, uv3.y, rowtaps) * coltaps.w;
    }

    float u_weight_sum = rowtaps.y + rowtaps.z;
    float u_middle_offset = rowtaps.z * base_dimension_i.x / u_weight_sum;
    float u_middle = uv1.x + u_middle_offset;

    float v_weight_sum = coltaps.y + coltaps.z;
    float v_middle_offset = coltaps.z * base_dimension_i.y / v_weight_sum;
    float v_middle = uv1.y + v_middle_offset;

    ivec2 coord_top_left = ivec2(max(uv0 * base_dimension, 0.5));
    ivec2 coord_bottom_right = ivec2(min(uv3 * base_dimension, base_dimension - 0.5));

    vec4 top = obs_load_2d(image, ivec3(coord_top_left, 0)) * rowtaps.x;
    top += texture(image, vec2(u_middle, uv0.y)) * u_weight_sum;
    top += obs_load_2d(image, ivec3(coord_bottom_right.x, coord_top_left.y, 0)) * rowtaps.w;
    vec4 total = top * coltaps.x;

    vec4 middle = texture(image, vec2(uv0.x, v_middle)) * rowtaps.x;
    middle += texture(image, vec2(u_middle, v_middle)) * u_weight_sum;
    middle += texture(image, vec2(uv3.x, v_middle)) * rowtaps.w;
    total += middle * v_weight_sum;

    vec4 bottom = obs_load_2d(image, ivec3(coord_top_left.x, coord_bottom_right.y, 0)) * rowtaps.x;
    bottom += texture(image, vec2(u_middle, uv3.y)) * u_weight_sum;
    bottom += obs_load_2d(image, ivec3(coord_bottom_right, 0)) * rowtaps.w;
    total += bottom * coltaps.w;

    return total;
}

vec4 PSDrawBicubicRGBADivide(FragData f_in)
{
    vec4 rgba = DrawBicubic(f_in, false);
    rgba.rgb *= max(1. / rgba.a, 0.);
    return rgba;
}

vec4 _main_wrap(FragData f_in)
{
    return PSDrawBicubicRGBADivide(f_in);
}

void main(void)
{
    FragData f_in;
    f_in.uv = _vertex_shader_attrib0;

    _pixel_shader_attrib0 = _main_wrap(f_in);
}

info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform vec2 base_dimension;
uniform mat4x4 ViewProj;

in vec4 _input_attrib0;
in vec2 _input_attrib1;

out vec2 _vertex_shader_attrib0;

out gl_PerVertex {
    vec4 gl_Position;
};

struct VertOut {
    vec2 uv;
    vec4 pos;
};

struct VertData {
    vec4 pos;
    vec2 uv;
};

VertOut VSDefault(VertData v_in)
{
    VertOut vert_out;
    vert_out.uv = v_in.uv * base_dimension;
    vert_out.pos = ((vec4(v_in.pos.xyz, 1.0)) * (ViewProj));
    return vert_out;
}

VertOut _main_wrap(VertData v_in)
{
    return VSDefault(v_in);
}

void main(void)
{
    VertData v_in;
    VertOut outputval;

    v_in.pos = _input_attrib0;
    v_in.uv = _input_attrib1;

    outputval = _main_wrap(v_in);

    _vertex_shader_attrib0 = outputval.uv;
    gl_Position = outputval.pos;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform vec2 base_dimension_i;
uniform vec2 base_dimension;
uniform sampler2D image;
uniform float undistort_factor;

in vec2 _vertex_shader_attrib0;

out vec4 _pixel_shader_attrib0;

struct FragData {
    vec2 uv;
};

vec4 weight4(float x)
{
     
    return vec4(
        ((-0.75 * x + 1.5) * x - 0.75) * x,
        (1.25 * x - 2.25) * x * x + 1.0,
        ((-1.25 * x + 1.5) * x + 0.75) * x,
        (0.75 * x - 0.75) * x * x);
}

float AspectUndistortX(float x, float a)
{
     
    return (1.0 - a) * (x * x * x * x * x) + a * x;
}

float AspectUndistortU(float u)
{
     
    return AspectUndistortX((u - 0.5) * 2.0, undistort_factor) * 0.5 + 0.5;
}

vec2 undistort_coord(float xpos, float ypos)
{
    return vec2(AspectUndistortU(xpos), ypos);
}

vec4 undistort_pixel(float xpos, float ypos)
{
    return texture(image, undistort_coord(xpos, ypos));
}

vec4 undistort_line(vec4 xpos, float ypos, vec4 rowtaps)
{
    return undistort_pixel(xpos.x, ypos) * rowtaps.x +
           undistort_pixel(xpos.y, ypos) * rowtaps.y +
           undistort_pixel(xpos.z, ypos) * rowtaps.z +
           undistort_pixel(xpos.w, ypos) * rowtaps.w;
}

vec4 DrawBicubic(FragData f_in, bool undistort)
{
    vec2 pos = f_in.uv;
    vec2 pos1 = floor(pos - 0.5) + 0.5;
    vec2 f = pos - pos1;

    vec4 rowtaps = weight4(f.x);
    vec4 coltaps = weight4(f.y);

    vec2 uv1 = pos1 * base_dimension_i;
    vec2 uv0 = uv1 - base_dimension_i;
    vec2 uv2 = uv1 + base_dimension_i;
    vec2 uv3 = uv2 + base_dimension_i;

    if (undistort) {
        vec4 xpos = vec4(uv0.x, uv1.x, uv2.x, uv3.x);
        return undistort_line(xpos, uv0.y, rowtaps) * coltaps.x +
               undistort_line(xpos, uv1.y, rowtaps) * coltaps.y +
               undistort_line(xpos, uv2.y, rowtaps) * coltaps.z +
               undistort_line(xpos, uv3.y, rowtaps) * coltaps.w;
    }

    float u_weight_sum = rowtaps.y + rowtaps.z;
    float u_middle_offset = rowtaps.z * base_dimension_i.x / u_weight_sum;
    float u_middle = uv1.x + u_middle_offset;

    float v_weight_sum = coltaps.y + coltaps.z;
    float v_middle_offset = coltaps.z * base_dimension_i.y / v_weight_sum;
    float v_middle = uv1.y + v_middle_offset;

    ivec2 coord_top_left = ivec2(max(uv0 * base_dimension, 0.5));
    ivec2 coord_bottom_right = ivec2(min(uv3 * base_dimension, base_dimension - 0.5));

    vec4 top = obs_load_2d(image, ivec3(coord_top_left, 0)) * rowtaps.x;
    top += texture(image, vec2(u_middle, uv0.y)) * u_weight_sum;
    top += obs_load_2d(image, ivec3(coord_bottom_right.x, coord_top_left.y, 0)) * rowtaps.w;
    vec4 total = top * coltaps.x;

    vec4 middle = texture(image, vec2(uv0.x, v_middle)) * rowtaps.x;
    middle += texture(image, vec2(u_middle, v_middle)) * u_weight_sum;
    middle += texture(image, vec2(uv3.x, v_middle)) * rowtaps.w;
    total += middle * v_weight_sum;

    vec4 bottom = obs_load_2d(image, ivec3(coord_top_left.x, coord_bottom_right.y, 0)) * rowtaps.x;
    bottom += texture(image, vec2(u_middle, uv3.y)) * u_weight_sum;
    bottom += obs_load_2d(image, ivec3(coord_bottom_right, 0)) * rowtaps.w;
    total += bottom * coltaps.w;

    return total;
}

vec4 PSDrawBicubicRGBA(FragData f_in, bool undistort)
{
    return DrawBicubic(f_in, undistort);
}

vec4 _main_wrap(FragData f_in)
{
    return PSDrawBicubicRGBA(f_in,true);
}

void main(void)
{
    FragData f_in;
    f_in.uv = _vertex_shader_attrib0;

    _pixel_shader_attrib0 = _main_wrap(f_in);
}

info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform vec2 base_dimension;
uniform mat4x4 ViewProj;

in vec4 _input_attrib0;
in vec2 _input_attrib1;

out vec2 _vertex_shader_attrib0;

out gl_PerVertex {
    vec4 gl_Position;
};

struct VertOut {
    vec2 uv;
    vec4 pos;
};

struct VertData {
    vec4 pos;
    vec2 uv;
};

VertOut VSDefault(VertData v_in)
{
    VertOut vert_out;
    vert_out.uv = v_in.uv * base_dimension;
    vert_out.pos = ((vec4(v_in.pos.xyz, 1.0)) * (ViewProj));
    return vert_out;
}

VertOut _main_wrap(VertData v_in)
{
    return VSDefault(v_in);
}

void main(void)
{
    VertData v_in;
    VertOut outputval;

    v_in.pos = _input_attrib0;
    v_in.uv = _input_attrib1;

    outputval = _main_wrap(v_in);

    _vertex_shader_attrib0 = outputval.uv;
    gl_Position = outputval.pos;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform float multiplier;
uniform vec2 base_dimension_i;
uniform vec2 base_dimension;
uniform sampler2D image;
uniform float undistort_factor;

in vec2 _vertex_shader_attrib0;

out vec4 _pixel_shader_attrib0;

struct FragData {
    vec2 uv;
};

vec4 weight4(float x)
{
     
    return vec4(
        ((-0.75 * x + 1.5) * x - 0.75) * x,
        (1.25 * x - 2.25) * x * x + 1.0,
        ((-1.25 * x + 1.5) * x + 0.75) * x,
        (0.75 * x - 0.75) * x * x);
}

float AspectUndistortX(float x, float a)
{
     
    return (1.0 - a) * (x * x * x * x * x) + a * x;
}

float AspectUndistortU(float u)
{
     
    return AspectUndistortX((u - 0.5) * 2.0, undistort_factor) * 0.5 + 0.5;
}

vec2 undistort_coord(float xpos, float ypos)
{
    return vec2(AspectUndistortU(xpos), ypos);
}

vec4 undistort_pixel(float xpos, float ypos)
{
    return texture(image, undistort_coord(xpos, ypos));
}

vec4 undistort_line(vec4 xpos, float ypos, vec4 rowtaps)
{
    return undistort_pixel(xpos.x, ypos) * rowtaps.x +
           undistort_pixel(xpos.y, ypos) * rowtaps.y +
           undistort_pixel(xpos.z, ypos) * rowtaps.z +
           undistort_pixel(xpos.w, ypos) * rowtaps.w;
}

vec4 DrawBicubic(FragData f_in, bool undistort)
{
    vec2 pos = f_in.uv;
    vec2 pos1 = floor(pos - 0.5) + 0.5;
    vec2 f = pos - pos1;

    vec4 rowtaps = weight4(f.x);
    vec4 coltaps = weight4(f.y);

    vec2 uv1 = pos1 * base_dimension_i;
    vec2 uv0 = uv1 - base_dimension_i;
    vec2 uv2 = uv1 + base_dimension_i;
    vec2 uv3 = uv2 + base_dimension_i;

    if (undistort) {
        vec4 xpos = vec4(uv0.x, uv1.x, uv2.x, uv3.x);
        return undistort_line(xpos, uv0.y, rowtaps) * coltaps.x +
               undistort_line(xpos, uv1.y, rowtaps) * coltaps.y +
               undistort_line(xpos, uv2.y, rowtaps) * coltaps.z +
               undistort_line(xpos, uv3.y, rowtaps) * coltaps.w;
    }

    float u_weight_sum = rowtaps.y + rowtaps.z;
    float u_middle_offset = rowtaps.z * base_dimension_i.x / u_weight_sum;
    float u_middle = uv1.x + u_middle_offset;

    float v_weight_sum = coltaps.y + coltaps.z;
    float v_middle_offset = coltaps.z * base_dimension_i.y / v_weight_sum;
    float v_middle = uv1.y + v_middle_offset;

    ivec2 coord_top_left = ivec2(max(uv0 * base_dimension, 0.5));
    ivec2 coord_bottom_right = ivec2(min(uv3 * base_dimension, base_dimension - 0.5));

    vec4 top = obs_load_2d(image, ivec3(coord_top_left, 0)) * rowtaps.x;
    top += texture(image, vec2(u_middle, uv0.y)) * u_weight_sum;
    top += obs_load_2d(image, ivec3(coord_bottom_right.x, coord_top_left.y, 0)) * rowtaps.w;
    vec4 total = top * coltaps.x;

    vec4 middle = texture(image, vec2(uv0.x, v_middle)) * rowtaps.x;
    middle += texture(image, vec2(u_middle, v_middle)) * u_weight_sum;
    middle += texture(image, vec2(uv3.x, v_middle)) * rowtaps.w;
    total += middle * v_weight_sum;

    vec4 bottom = obs_load_2d(image, ivec3(coord_top_left.x, coord_bottom_right.y, 0)) * rowtaps.x;
    bottom += texture(image, vec2(u_middle, uv3.y)) * u_weight_sum;
    bottom += obs_load_2d(image, ivec3(coord_bottom_right, 0)) * rowtaps.w;
    total += bottom * coltaps.w;

    return total;
}

vec4 PSDrawBicubicRGBAMultiply(FragData f_in, bool undistort)
{
    vec4 rgba = DrawBicubic(f_in, undistort);
    rgba.rgb *= multiplier;
    return rgba;
}

vec4 _main_wrap(FragData f_in)
{
    return PSDrawBicubicRGBAMultiply(f_in,true);
}

void main(void)
{
    FragData f_in;
    f_in.uv = _vertex_shader_attrib0;

    _pixel_shader_attrib0 = _main_wrap(f_in);
}

info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform vec2 base_dimension;
uniform mat4x4 ViewProj;

in vec4 _input_attrib0;
in vec2 _input_attrib1;

out vec2 _vertex_shader_attrib0;

out gl_PerVertex {
    vec4 gl_Position;
};

struct VertOut {
    vec2 uv;
    vec4 pos;
};

struct VertData {
    vec4 pos;
    vec2 uv;
};

VertOut VSDefault(VertData v_in)
{
    VertOut vert_out;
    vert_out.uv = v_in.uv * base_dimension;
    vert_out.pos = ((vec4(v_in.pos.xyz, 1.0)) * (ViewProj));
    return vert_out;
}

VertOut _main_wrap(VertData v_in)
{
    return VSDefault(v_in);
}

void main(void)
{
    VertData v_in;
    VertOut outputval;

    v_in.pos = _input_attrib0;
    v_in.uv = _input_attrib1;

    outputval = _main_wrap(v_in);

    _vertex_shader_attrib0 = outputval.uv;
    gl_Position = outputval.pos;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform vec2 base_dimension_i;
uniform vec2 base_dimension;
uniform sampler2D image;
uniform float undistort_factor;

in vec2 _vertex_shader_attrib0;

out vec4 _pixel_shader_attrib0;

struct FragData {
    vec2 uv;
};

vec4 weight4(float x)
{
     
    return vec4(
        ((-0.75 * x + 1.5) * x - 0.75) * x,
        (1.25 * x - 2.25) * x * x + 1.0,
        ((-1.25 * x + 1.5) * x + 0.75) * x,
        (0.75 * x - 0.75) * x * x);
}

float AspectUndistortX(float x, float a)
{
     
    return (1.0 - a) * (x * x * x * x * x) + a * x;
}

float AspectUndistortU(float u)
{
     
    return AspectUndistortX((u - 0.5) * 2.0, undistort_factor) * 0.5 + 0.5;
}

vec2 undistort_coord(float xpos, float ypos)
{
    return vec2(AspectUndistortU(xpos), ypos);
}

vec4 undistort_pixel(float xpos, float ypos)
{
    return texture(image, undistort_coord(xpos, ypos));
}

vec4 undistort_line(vec4 xpos, float ypos, vec4 rowtaps)
{
    return undistort_pixel(xpos.x, ypos) * rowtaps.x +
           undistort_pixel(xpos.y, ypos) * rowtaps.y +
           undistort_pixel(xpos.z, ypos) * rowtaps.z +
           undistort_pixel(xpos.w, ypos) * rowtaps.w;
}

vec4 DrawBicubic(FragData f_in, bool undistort)
{
    vec2 pos = f_in.uv;
    vec2 pos1 = floor(pos - 0.5) + 0.5;
    vec2 f = pos - pos1;

    vec4 rowtaps = weight4(f.x);
    vec4 coltaps = weight4(f.y);

    vec2 uv1 = pos1 * base_dimension_i;
    vec2 uv0 = uv1 - base_dimension_i;
    vec2 uv2 = uv1 + base_dimension_i;
    vec2 uv3 = uv2 + base_dimension_i;

    if (undistort) {
        vec4 xpos = vec4(uv0.x, uv1.x, uv2.x, uv3.x);
        return undistort_line(xpos, uv0.y, rowtaps) * coltaps.x +
               undistort_line(xpos, uv1.y, rowtaps) * coltaps.y +
               undistort_line(xpos, uv2.y, rowtaps) * coltaps.z +
               undistort_line(xpos, uv3.y, rowtaps) * coltaps.w;
    }

    float u_weight_sum = rowtaps.y + rowtaps.z;
    float u_middle_offset = rowtaps.z * base_dimension_i.x / u_weight_sum;
    float u_middle = uv1.x + u_middle_offset;

    float v_weight_sum = coltaps.y + coltaps.z;
    float v_middle_offset = coltaps.z * base_dimension_i.y / v_weight_sum;
    float v_middle = uv1.y + v_middle_offset;

    ivec2 coord_top_left = ivec2(max(uv0 * base_dimension, 0.5));
    ivec2 coord_bottom_right = ivec2(min(uv3 * base_dimension, base_dimension - 0.5));

    vec4 top = obs_load_2d(image, ivec3(coord_top_left, 0)) * rowtaps.x;
    top += texture(image, vec2(u_middle, uv0.y)) * u_weight_sum;
    top += obs_load_2d(image, ivec3(coord_bottom_right.x, coord_top_left.y, 0)) * rowtaps.w;
    vec4 total = top * coltaps.x;

    vec4 middle = texture(image, vec2(uv0.x, v_middle)) * rowtaps.x;
    middle += texture(image, vec2(u_middle, v_middle)) * u_weight_sum;
    middle += texture(image, vec2(uv3.x, v_middle)) * rowtaps.w;
    total += middle * v_weight_sum;

    vec4 bottom = obs_load_2d(image, ivec3(coord_top_left.x, coord_bottom_right.y, 0)) * rowtaps.x;
    bottom += texture(image, vec2(u_middle, uv3.y)) * u_weight_sum;
    bottom += obs_load_2d(image, ivec3(coord_bottom_right, 0)) * rowtaps.w;
    total += bottom * coltaps.w;

    return total;
}

vec3 rec709_to_rec2020(vec3 v)
{
    float r = dot(v, vec3(0.62740389593469903, 0.32928303837788370, 0.043313065687417225));
    float g = dot(v, vec3(0.069097289358232075, 0.91954039507545871, 0.011362315566309178));
    float b = dot(v, vec3(0.016391438875150280, 0.088013307877225749, 0.89559525324762401));
    return vec3(r, g, b);
}

float srgb_nonlinear_to_linear_channel(float u)
{
    return (u <= 0.04045) ? (u / 12.92) : pow((u + 0.055) / 1.055, 2.4);
}

vec3 srgb_nonlinear_to_linear(vec3 v)
{
    return vec3(srgb_nonlinear_to_linear_channel(v.r), srgb_nonlinear_to_linear_channel(v.g), srgb_nonlinear_to_linear_channel(v.b));
}

vec3 reinhard(vec3 rgb)
{
    rgb /= rgb + vec3(1., 1., 1.);
    rgb =
info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform vec2 base_dimension;
uniform mat4x4 ViewProj;

in vec4 _input_attrib0;
in vec2 _input_attrib1;

out vec2 _vertex_shader_attrib0;

out gl_PerVertex {
    vec4 gl_Position;
};

struct VertOut {
    vec2 uv;
    vec4 pos;
};

struct VertData {
    vec4 pos;
    vec2 uv;
};

VertOut VSDefault(VertData v_in)
{
    VertOut vert_out;
    vert_out.uv = v_in.uv * base_dimension;
    vert_out.pos = ((vec4(v_in.pos.xyz, 1.0)) * (ViewProj));
    return vert_out;
}

VertOut _main_wrap(VertData v_in)
{
    return VSDefault(v_in);
}

void main(void)
{
    VertData v_in;
    VertOut outputval;

    v_in.pos = _input_attrib0;
    v_in.uv = _input_attrib1;

    outputval = _main_wrap(v_in);

    _vertex_shader_attrib0 = outputval.uv;
    gl_Position = outputval.pos;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform float multiplier;
uniform vec2 base_dimension_i;
uniform vec2 base_dimension;
uniform sampler2D image;
uniform float undistort_factor;

in vec2 _vertex_shader_attrib0;

out vec4 _pixel_shader_attrib0;

struct FragData {
    vec2 uv;
};

vec4 weight4(float x)
{
     
    return vec4(
        ((-0.75 * x + 1.5) * x - 0.75) * x,
        (1.25 * x - 2.25) * x * x + 1.0,
        ((-1.25 * x + 1.5) * x + 0.75) * x,
        (0.75 * x - 0.75) * x * x);
}

float AspectUndistortX(float x, float a)
{
     
    return (1.0 - a) * (x * x * x * x * x) + a * x;
}

float AspectUndistortU(float u)
{
     
    return AspectUndistortX((u - 0.5) * 2.0, undistort_factor) * 0.5 + 0.5;
}

vec2 undistort_coord(float xpos, float ypos)
{
    return vec2(AspectUndistortU(xpos), ypos);
}

vec4 undistort_pixel(float xpos, float ypos)
{
    return texture(image, undistort_coord(xpos, ypos));
}

vec4 undistort_line(vec4 xpos, float ypos, vec4 rowtaps)
{
    return undistort_pixel(xpos.x, ypos) * rowtaps.x +
           undistort_pixel(xpos.y, ypos) * rowtaps.y +
           undistort_pixel(xpos.z, ypos) * rowtaps.z +
           undistort_pixel(xpos.w, ypos) * rowtaps.w;
}

vec4 DrawBicubic(FragData f_in, bool undistort)
{
    vec2 pos = f_in.uv;
    vec2 pos1 = floor(pos - 0.5) + 0.5;
    vec2 f = pos - pos1;

    vec4 rowtaps = weight4(f.x);
    vec4 coltaps = weight4(f.y);

    vec2 uv1 = pos1 * base_dimension_i;
    vec2 uv0 = uv1 - base_dimension_i;
    vec2 uv2 = uv1 + base_dimension_i;
    vec2 uv3 = uv2 + base_dimension_i;

    if (undistort) {
        vec4 xpos = vec4(uv0.x, uv1.x, uv2.x, uv3.x);
        return undistort_line(xpos, uv0.y, rowtaps) * coltaps.x +
               undistort_line(xpos, uv1.y, rowtaps) * coltaps.y +
               undistort_line(xpos, uv2.y, rowtaps) * coltaps.z +
               undistort_line(xpos, uv3.y, rowtaps) * coltaps.w;
    }

    float u_weight_sum = rowtaps.y + rowtaps.z;
    float u_middle_offset = rowtaps.z * base_dimension_i.x / u_weight_sum;
    float u_middle = uv1.x + u_middle_offset;

    float v_weight_sum = coltaps.y + coltaps.z;
    float v_middle_offset = coltaps.z * base_dimension_i.y / v_weight_sum;
    float v_middle = uv1.y + v_middle_offset;

    ivec2 coord_top_left = ivec2(max(uv0 * base_dimension, 0.5));
    ivec2 coord_bottom_right = ivec2(min(uv3 * base_dimension, base_dimension - 0.5));

    vec4 top = obs_load_2d(image, ivec3(coord_top_left, 0)) * rowtaps.x;
    top += texture(image, vec2(u_middle, uv0.y)) * u_weight_sum;
    top += obs_load_2d(image, ivec3(coord_bottom_right.x, coord_top_left.y, 0)) * rowtaps.w;
    vec4 total = top * coltaps.x;

    vec4 middle = texture(image, vec2(uv0.x, v_middle)) * rowtaps.x;
    middle += texture(image, vec2(u_middle, v_middle)) * u_weight_sum;
    middle += texture(image, vec2(uv3.x, v_middle)) * rowtaps.w;
    total += middle * v_weight_sum;

    vec4 bottom = obs_load_2d(image, ivec3(coord_top_left.x, coord_bottom_right.y, 0)) * rowtaps.x;
    bottom += texture(image, vec2(u_middle, uv3.y)) * u_weight_sum;
    bottom += obs_load_2d(image, ivec3(coord_bottom_right, 0)) * rowtaps.w;
    total += bottom * coltaps.w;

    return total;
}

vec3 rec709_to_rec2020(vec3 v)
{
    float r = dot(v, vec3(0.62740389593469903, 0.32928303837788370, 0.043313065687417225));
    float g = dot(v, vec3(0.069097289358232075, 0.91954039507545871, 0.011362315566309178));
    float b = dot(v, vec3(0.016391438875150280, 0.088013307877225749, 0.89559525324762401));
    return vec3(r, g, b);
}

float srgb_nonlinear_to_linear_channel(float u)
{
    return (u <= 0.04045) ? (u / 12.92) : pow((u + 0.055) / 1.055, 2.4);
}

vec3 srgb_nonlinear_to_linear(vec3 v)
{
    return vec3(srgb_nonlinear_to_linear_channel(v.r), srgb_nonlinear_to_linear_channel(v.g), srgb_nonlinear_to_linear_channel(v.b));
}

vec3 reinhard(vec3 rgb)
{
    rgb /= rgb
info: ======funcs =======
info: fname:srgb_linear_to_nonlinear_channel rtype:float mapping:(null) content:{
    return (u <= 0.0031308) ? (12.92 * u) : ((1.055 * pow(u, 1. / 2.4)) - 0.055);
}
info: fname:srgb_linear_to_nonlinear rtype:float3 mapping:(null) content:{
    return float3(srgb_linear_to_nonlinear_channel(v.r), srgb_linear_to_nonlinear_channel(v.g), srgb_linear_to_nonlinear_channel(v.b));
}
info: fname:srgb_nonlinear_to_linear_channel rtype:float mapping:(null) content:{
    return (u <= 0.04045) ? (u / 12.92) : pow((u + 0.055) / 1.055, 2.4);
}
info: fname:srgb_nonlinear_to_linear rtype:float3 mapping:(null) content:{
    return float3(srgb_nonlinear_to_linear_channel(v.r), srgb_nonlinear_to_linear_channel(v.g), srgb_nonlinear_to_linear_channel(v.b));
}
info: fname:rec709_to_rec2020 rtype:float3 mapping:(null) content:{
    float r = dot(v, float3(0.62740389593469903, 0.32928303837788370, 0.043313065687417225));
    float g = dot(v, float3(0.069097289358232075, 0.91954039507545871, 0.011362315566309178));
    float b = dot(v, float3(0.016391438875150280, 0.088013307877225749, 0.89559525324762401));
    return float3(r, g, b);
}
info: fname:d65p3_to_rec709 rtype:float3 mapping:(null) content:{
    float r = dot(v, float3(1.2249401762805598, -0.22494017628055996, 0.));
    float g = dot(v, float3(-0.042056954709688163, 1.0420569547096881, 0.));
    float b = dot(v, float3(-0.019637554590334432, -0.078636045550631889, 1.0982736001409663));
    return float3(r, g, b);
}
info: fname:rec2020_to_rec709 rtype:float3 mapping:(null) content:{
    float r = dot(v, float3(1.6604910021084345, -0.58764113878854951, -0.072849863319884883));
    float g = dot(v, float3(-0.12455047452159074, 1.1328998971259603, -0.0083494226043694768));
    float b = dot(v, float3(-0.018150763354905303, -0.10057889800800739, 1.1187296613629127));
    return float3(r, g, b);
}
info: fname:reinhard rtype:float3 mapping:(null) content:{
    rgb /= rgb + float3(1., 1., 1.);
    rgb = pow(rgb, float3(1. / 2.4, 1. / 2.4, 1. / 2.4));
    rgb = srgb_nonlinear_to_linear(rgb);
    return rgb;
}
info: fname:linear_to_st2084_channel rtype:float mapping:(null) content:{
    float c = pow(abs(x), 0.1593017578);
    return pow((0.8359375 + 18.8515625 * c) / (1. + 18.6875 * c), 78.84375);
}
info: fname:linear_to_st2084 rtype:float3 mapping:(null) content:{
    return float3(linear_to_st2084_channel(rgb.r), linear_to_st2084_channel(rgb.g), linear_to_st2084_channel(rgb.b));
}
info: fname:st2084_to_linear_channel rtype:float mapping:(null) content:{
    float c = pow(abs(u), 1. / 78.84375);
    return pow(abs(max(c - 0.8359375, 0.) / (18.8515625 - 18.6875 * c)), 1. / 0.1593017578);
}
info: fname:st2084_to_linear rtype:float3 mapping:(null) content:{
    return float3(st2084_to_linear_channel(rgb.r), st2084_to_linear_channel(rgb.g), st2084_to_linear_channel(rgb.b));
}
info: fname:eetf_0_Lmax rtype:float mapping:(null) content:{
    float Lw_pq = linear_to_st2084_channel(Lw / 10000.);
    float E1 = saturate(maxRGB1_pq / Lw_pq);
    float maxLum = linear_to_st2084_channel(Lmax / 10000.) / Lw_pq;
    float KS = (1.5 * maxLum) - 0.5;
    float E2 = E1;
    if (E1 > KS)
    {
        float T = (E1 - KS) / (1. - KS);
        float Tsquared = T * T;
        float Tcubed = Tsquared * T;
        float P = (2. * Tcubed - 3. * Tsquared + 1.) * KS + (Tcubed - 2. * Tsquared + T) * (1. - KS) + (-2. * Tcubed + 3. * Tsquared) * maxLum;
        E2 = P;
    }
    float E3 = E2;
    float E4 = E3 * Lw_pq;
    return E4;
}
info: fname:maxRGB_eetf_internal rtype:float3 mapping:(null) content:{
    float maxRGB2_pq = eetf_0_Lmax(maxRGB1_pq, Lw, Lmax);
    float maxRGB2_linear = st2084_to_linear_channel(maxRGB2_pq);

     
    maxRGB1_linear = max(6.10352e-5, maxRGB1_linear);

    rgb_linear *= maxRGB2_linear / maxRGB1_linear;
    return rgb_linear;
}
info: fname:maxRGB_eetf_pq_to_linear rtype:float3 mapping:(null) content:{
    float3 rgb_linear = st2084_to_linear(rgb_pq);
    float maxRGB1_linear = max(max(rgb_linear.r, rgb_linear.g), rgb_linear.b);
    float maxRGB1_pq = max(max(rgb_pq.r, rgb_pq.g), rgb_pq.b);
    return maxRGB_eetf_internal(rgb_linear, maxRGB1_linear, maxRGB1_pq, Lw, Lmax);
}
info: fname:maxRGB_eetf_linear_to_linear rtype:float3 mapping:(null) content:{
    float maxRGB1_linear = max(max(rgb_linear.r, rgb_linear.g), rgb_linear.b);
    float maxRGB1_pq = linear_to_st2084_channel(maxRGB1_linear);
    return maxRGB_eetf_internal(rgb_linear, maxRGB1_linear, maxRGB1_pq, Lw, Lmax);
}
info: fname:st2084_to_linear_eetf rtype:float3 mapping:(null) content:{
    return (Lw > Lmax) ? maxRGB_eetf_pq_to_linear(rgb, Lw, Lmax) : st2084_to_linear(rgb);
}
info: fname:linear_to_hlg_channel rtype:float mapping:(null) content:{
    float ln2_i = 1. / log(2.);
    float m = 0.17883277 / ln2_i;
    return (u <= (1. / 12.)) ? sqrt(3. * u) : ((log2((12. * u) - 0.28466892) * m) + 0.55991073);
}
info: fname:linear_to_hlg rtype:float3 mapping:(null) content:{
    rgb = saturate(rgb);

    if (Lw > 1000.)
    {
        rgb = maxRGB_eetf_linear_to_linear(rgb, Lw, 1000.);
        rgb *= 10000. / Lw;
    }
    else
    {
        rgb *= 10.;
    }

    float Yd = dot(rgb, float3(0.2627, 0.678, 0.0593));

     
    Yd = max(6.10352e-5, Yd);

    rgb *= pow(Yd, -1. / 6.);
    return float3(linear_to_hlg_channel(rgb.r), linear_to_hlg_channel(rgb.g), linear_to_hlg_channel(rgb.b));
}
info: fname:hlg_to_linear_channel rtype:float mapping:(null) content:{
    float ln2_i = 1. / log(2.);
    float m = ln2_i / 0.17883277;
    float a = -ln2_i * 0.55991073 / 0.17883277;
    return (u <= 0.5) ? ((u * u) / 3.) : ((exp2(u * m + a) + 0.28466892) / 12.);
}
info: fname:hlg_to_linear rtype:float3 mapping:(null) content:{
    float3 rgb = float3(hlg_to_linear_channel(v.r), hlg_to_linear_channel(v.g), hlg_to_linear_channel(v.b));
    float Ys = dot(rgb, float3(0.2627, 0.678, 0.0593));
    rgb *= pow(Ys, exponent);
    return rgb;
}
info: fname:VSDefault rtype:VertOut mapping:(null) content:{
    VertOut vert_out;
    vert_out.uv = v_in.uv * base_dimension;
    vert_out.pos = mul(float4(v_in.pos.xyz, 1.0), ViewProj);
    return vert_out;
}
info: fname:weight4 rtype:float4 mapping:(null) content:{
     
    return float4(
        ((-0.75 * x + 1.5) * x - 0.75) * x,
        (1.25 * x - 2.25) * x * x + 1.0,
        ((-1.25 * x + 1.5) * x + 0.75) * x,
        (0.75 * x - 0.75) * x * x);
}
info: fname:AspectUndistortX rtype:float mapping:(null) content:{
     
    return (1.0 - a) * (x * x * x * x * x) + a * x;
}
info: fname:AspectUndistortU rtype:float mapping:(null) content:{
     
    return AspectUndistortX((u - 0.5) * 2.0, undistort_factor) * 0.5 + 0.5;
}
info: fname:undistort_coord rtype:float2 mapping:(null) content:{
    return float2(AspectUndistortU(xpos), ypos);
}
info: fname:undistort_pixel rtype:float4 mapping:(null) content:{
    return image.Sample(textureSampler, undistort_coord(xpos, ypos));
}
info: fname:undistort_line rtype:float4 mapping:(null) content:{
    return undistort_pixel(xpos.x, ypos) * rowtaps.x +
           undistort_pixel(xpos.y, ypos) * rowtaps.y +
           undistort_pixel(xpos.z, ypos) * rowtaps.z +
           undistort_pixel(xpos.w, ypos) * rowtaps.w;
}
info: fname:DrawBicubic rtype:float4 mapping:(null) content:{
    float2 pos = f_in.uv;
    float2 pos1 = floor(pos - 0.5) + 0.5;
    float2 f = pos - pos1;

    float4 rowtaps = weight4(f.x);
    float4 coltaps = weight4(f.y);

    float2 uv1 = pos1 * base_dimension_i;
    float2 uv0 = uv1 - base_dimension_i;
    float2 uv2 = uv1 + base_dimension_i;
    float2 uv3 = uv2 + base_dimension_i;

    if (undistort) {
        float4 xpos = float4(uv0.x, uv1.x, uv2.x, uv3.x);
        return undistort_line(xpos, uv0.y, rowtaps) * coltaps.x +
               undistort_line(xpos, uv1.y, rowtaps) * coltaps.y +
               undistort_line(xpos, uv2.y, rowtaps) * coltaps.z +
               undistort_line(xpos, uv3.y, rowtaps) * coltaps.w;
    }

    float u_weight_sum = rowtaps.y + rowtaps.z;
    float u_middle_offset = rowtaps.z * base_dimension_i.x / u_weight_sum;
    float u_middle = uv1.x + u_middle_offset;

    float v_weight_sum = coltaps.y + coltaps.z;
    float v_middle_offset = coltaps.z * base_dimension_i.y / v_weight_sum;
    float v_middle = uv1.y + v_middle_offset;

    int2 coord_top_left = int2(max(uv0 * base_dimension, 0.5));
    int2 coord_bottom_right = int2(min(uv3 * base_dimension, base_dimension - 0.5));

    float4 top = image.Load(int3(coord_top_left, 0)) * rowtaps.x;
    top += image.Sample(textureSampler, float2(u_middle, uv0.y)) * u_weight_sum;
    top += image.Load(int3(coord_bottom_right.x, coord_top_left.y, 0)) * rowtaps.w;
    float4 total = top * coltaps.x;

    float4 middle = image.Sample(textureSampler, float2(uv0.x, v_middle)) * rowtaps.x;
    middle += image.Sample(textureSampler, float2(u_middle, v_middle)) * u_weight_sum;
    middle += image.Sample(textureSampler, float2(uv3.x, v_middle)) * rowtaps.w;
    total += middle * v_weight_sum;

    float4 bottom = image.Load(int3(coord_top_left.x, coord_bottom_right.y, 0)) * rowtaps.x;
    bottom += image.Sample(textureSampler, float2(u_middle, uv3.y)) * u_weight_sum;
    bottom += image.Load(int3(coord_bottom_right, 0)) * rowtaps.w;
    total += bottom * coltaps.w;

    return total;
}
info: fname:PSDrawBicubicRGBA rtype:float4 mapping:TARGET content:{
    return DrawBicubic(f_in, undistort);
}
info: fname:PSDrawBicubicRGBAMultiply rtype:float4 mapping:TARGET content:{
    float4 rgba = DrawBicubic(f_in, undistort);
    rgba.rgb *= multiplier;
    return rgba;
}
info: fname:PSDrawBicubicRGBATonemap rtype:float4 mapping:TARGET content:{
    float4 rgba = DrawBicubic(f_in, undistort);
    rgba.rgb = rec709_to_rec2020(rgba.rgb);
    rgba.rgb = reinhard(rgba.rgb);
    rgba.rgb = rec2020_to_rec709(rgba.rgb);
    return rgba;
}
info: fname:PSDrawBicubicRGBAMultiplyTonemap rtype:float4 mapping:TARGET content:{
    float4 rgba = DrawBicubic(f_in, undistort);
    rgba.rgb *= multiplier;
    rgba.rgb = rec709_to_rec2020(rgba.rgb);
    rgba.rgb = reinhard(rgba.rgb);
    rgba.rgb = rec2020_to_rec709(rgba.rgb);
    return rgba;
}
info: fname:PSDrawBicubicRGBADivide rtype:float4 mapping:TARGET content:{
    float4 rgba = DrawBicubic(f_in, false);
    rgba.rgb *= max(1. / rgba.a, 0.);
    return rgba;
}
info: ======params =======
info: fname:ViewProj type:float4x4
info: fname:image type:texture2d
info: fname:base_dimension type:float2
info: fname:base_dimension_i type:float2
info: fname:undistort_factor type:float
info: fname:multiplier type:float
info: ======structs =======
info: fname:VertData
info: fname:VertOut
info: fname:FragData
info: ======samplers =======
info: fname:textureSampler
info: ======techniques =======
info: fname:Draw
info: fname:DrawMultiply
info: fname:DrawTonemap
info: fname:DrawMultiplyTonemap
info: fname:DrawAlphaDivide
info: fname:DrawUndistort
info: fname:DrawUndistortMultiply
info: fname:DrawUndistortTonemap
info: fname:DrawUndistortMultiplyTonemap
info: ======files =======
info: ======tokens =======
info: ======techniques =======
info: tname:Draw
info: tname:(null)
info: tname:DrawMultiply
info: tname:(null)
info: tname:DrawTonemap
info: tname:(null)
info: tname:DrawMultiplyTonemap
info: tname:(null)
info: tname:DrawAlphaDivide
info: tname:(null)
info: tname:DrawUndistort
info: tname:(null)
info: tname:DrawUndistortMultiply
info: tname:(null)
info: tname:DrawUndistortTonemap
info: tname:(null)
info: tname:DrawUndistortMultiplyTonemap
info: tname:(null)
info: ======params =======
info: tname:ViewProj
info: tname:image
info: tname:base_dimension
info: tname:base_dimension_i
info: tname:undistort_factor
info: tname:multiplier
info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform vec2 base_dimension;
uniform mat4x4 ViewProj;

in vec4 _input_attrib0;
in vec2 _input_attrib1;

out vec2 _vertex_shader_attrib0;

out gl_PerVertex {
    vec4 gl_Position;
};

struct VertOut {
    vec2 uv;
    vec4 pos;
};

struct VertData {
    vec4 pos;
    vec2 uv;
};

VertOut VSDefault(VertData v_in)
{
    VertOut vert_out;
    vert_out.uv  = v_in.uv * base_dimension;
    vert_out.pos = ((vec4(v_in.pos.xyz, 1.0)) * (ViewProj));

    return vert_out;
}

VertOut _main_wrap(VertData v_in)
{
    return VSDefault(v_in);
}

void main(void)
{
    VertData v_in;
    VertOut outputval;

    v_in.pos = _input_attrib0;
    v_in.uv = _input_attrib1;

    outputval = _main_wrap(v_in);

    _vertex_shader_attrib0 = outputval.uv;
    gl_Position = outputval.pos;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform vec2 base_dimension_i;
uniform vec2 base_dimension;
uniform sampler2D image;
uniform float undistort_factor;

in vec2 _vertex_shader_attrib0;

out vec4 _pixel_shader_attrib0;

struct FragData {
    vec2 uv;
};

float weight(float x)
{
    float x_pi = x * 3.141592654;
    return 3.0 * sin(x_pi) * sin(x_pi * (1.0 / 3.0)) / (x_pi * x_pi);
}

void weight6(float f_neg, out vec3 tap012, out vec3 tap345)
{
    tap012 = vec3(
        weight(f_neg - 2.0),
        weight(f_neg - 1.0),
        min(1.0, weight(f_neg)));
    tap345 = vec3(
        weight(f_neg + 1.0),
        weight(f_neg + 2.0),
        weight(f_neg + 3.0));

     
    float sum = tap012.x + tap012.y + tap012.z + tap345.x + tap345.y + tap345.z;
    float sum_i = 1.0 / sum;
    tap012 = tap012 * sum_i;
    tap345 = tap345 * sum_i;
}

float AspectUndistortX(float x, float a)
{
     
    return (1.0 - a) * (x * x * x * x * x) + a * x;
}

float AspectUndistortU(float u)
{
     
    return AspectUndistortX((u - 0.5) * 2.0, undistort_factor) * 0.5 + 0.5;
}

vec2 undistort_coord(float xpos, float ypos)
{
    return vec2(AspectUndistortU(xpos), ypos);
}

vec4 undistort_pixel(float xpos, float ypos)
{
    return texture(image, undistort_coord(xpos, ypos));
}

vec4 undistort_line(vec3 xpos012, vec3 xpos345, float ypos, vec3 rowtap012, vec3 rowtap345)
{
    return
        undistort_pixel(xpos012.x, ypos) * rowtap012.x +
        undistort_pixel(xpos012.y, ypos) * rowtap012.y +
        undistort_pixel(xpos012.z, ypos) * rowtap012.z +
        undistort_pixel(xpos345.x, ypos) * rowtap345.x +
        undistort_pixel(xpos345.y, ypos) * rowtap345.y +
        undistort_pixel(xpos345.z, ypos) * rowtap345.z;
}

vec4 DrawLanczos(FragData f_in, bool undistort)
{
    vec2 pos = f_in.uv;
    vec2 pos2 = floor(pos - 0.5) + 0.5;
    vec2 f_neg = pos2 - pos;

    vec3 rowtap012, rowtap345;
    weight6(f_neg.x, rowtap012, rowtap345);

    vec3 coltap012, coltap345;
    weight6(f_neg.y, coltap012, coltap345);

    vec2 uv2 = pos2 * base_dimension_i;
    vec2 uv1 = uv2 - base_dimension_i;
    vec2 uv0 = uv1 - base_dimension_i;
    vec2 uv3 = uv2 + base_dimension_i;
    vec2 uv4 = uv3 + base_dimension_i;
    vec2 uv5 = uv4 + base_dimension_i;

    if (undistort) {
        vec3 xpos012 = vec3(uv0.x, uv1.x, uv2.x);
        vec3 xpos345 = vec3(uv3.x, uv4.x, uv5.x);
        return undistort_line(xpos012, xpos345, uv0.y, rowtap012, rowtap345) * coltap012.x +
               undistort_line(xpos012, xpos345, uv1.y, rowtap012, rowtap345) * coltap012.y +
               undistort_line(xpos012, xpos345, uv2.y, rowtap012, rowtap345) * coltap012.z +
               undistort_line(xpos012, xpos345, uv3.y, rowtap012, rowtap345) * coltap345.x +
               undistort_line(xpos012, xpos345, uv4.y, rowtap012, rowtap345) * coltap345.y +
               undistort_line(xpos012, xpos345, uv5.y, rowtap012, rowtap345) * coltap345.z;
    }

    float u_weight_sum = rowtap012.z + rowtap345.x;
    float u_middle_offset = rowtap345.x * base_dimension_i.x / u_weight_sum;
    float u_middle = uv2.x + u_middle_offset;

    float v_weight_sum = coltap012.z + coltap345.x;
    float v_middle_offset = coltap345.x * base_dimension_i.y / v_weight_sum;
    float v_middle = uv2.y + v_middle_offset;

    vec2 coord_limit = base_dimension - 0.5;
    vec2 coord0_f = max(uv0 * base_dimension, 0.5);
    vec2 coord1_f = max(uv1 * base_dimension, 0.5);
    vec2 coord4_f = min(uv4 * base_dimension, coord_limit);
    vec2 coord5_f = min(uv5 * base_dimension, coord_limit);

    ivec2 coord0 = ivec2(coord0_f);
    ivec2 coord1 = ivec2(coord1_f);
    ivec2 coord4 = ivec2(coord4_f);
    ivec2 coord5 = ivec2(coord5_f);

    vec4 row0 = obs_load_2d(image, ivec3(coord0, 0)) * rowtap012.x;
    row0 += obs_load_2d(image, ivec3(coord1.x, coord0.y, 0)) * rowtap012.y;
    row0 += texture(image, vec2(u_middle, uv0.y)) * u_weight_sum;
    row0 += obs_load_2d(image, ivec3(coord4.x,
info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform vec2 base_dimension;
uniform mat4x4 ViewProj;

in vec4 _input_attrib0;
in vec2 _input_attrib1;

out vec2 _vertex_shader_attrib0;

out gl_PerVertex {
    vec4 gl_Position;
};

struct VertOut {
    vec2 uv;
    vec4 pos;
};

struct VertData {
    vec4 pos;
    vec2 uv;
};

VertOut VSDefault(VertData v_in)
{
    VertOut vert_out;
    vert_out.uv  = v_in.uv * base_dimension;
    vert_out.pos = ((vec4(v_in.pos.xyz, 1.0)) * (ViewProj));

    return vert_out;
}

VertOut _main_wrap(VertData v_in)
{
    return VSDefault(v_in);
}

void main(void)
{
    VertData v_in;
    VertOut outputval;

    v_in.pos = _input_attrib0;
    v_in.uv = _input_attrib1;

    outputval = _main_wrap(v_in);

    _vertex_shader_attrib0 = outputval.uv;
    gl_Position = outputval.pos;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform float multiplier;
uniform vec2 base_dimension_i;
uniform vec2 base_dimension;
uniform sampler2D image;
uniform float undistort_factor;

in vec2 _vertex_shader_attrib0;

out vec4 _pixel_shader_attrib0;

struct FragData {
    vec2 uv;
};

float weight(float x)
{
    float x_pi = x * 3.141592654;
    return 3.0 * sin(x_pi) * sin(x_pi * (1.0 / 3.0)) / (x_pi * x_pi);
}

void weight6(float f_neg, out vec3 tap012, out vec3 tap345)
{
    tap012 = vec3(
        weight(f_neg - 2.0),
        weight(f_neg - 1.0),
        min(1.0, weight(f_neg)));
    tap345 = vec3(
        weight(f_neg + 1.0),
        weight(f_neg + 2.0),
        weight(f_neg + 3.0));

     
    float sum = tap012.x + tap012.y + tap012.z + tap345.x + tap345.y + tap345.z;
    float sum_i = 1.0 / sum;
    tap012 = tap012 * sum_i;
    tap345 = tap345 * sum_i;
}

float AspectUndistortX(float x, float a)
{
     
    return (1.0 - a) * (x * x * x * x * x) + a * x;
}

float AspectUndistortU(float u)
{
     
    return AspectUndistortX((u - 0.5) * 2.0, undistort_factor) * 0.5 + 0.5;
}

vec2 undistort_coord(float xpos, float ypos)
{
    return vec2(AspectUndistortU(xpos), ypos);
}

vec4 undistort_pixel(float xpos, float ypos)
{
    return texture(image, undistort_coord(xpos, ypos));
}

vec4 undistort_line(vec3 xpos012, vec3 xpos345, float ypos, vec3 rowtap012, vec3 rowtap345)
{
    return
        undistort_pixel(xpos012.x, ypos) * rowtap012.x +
        undistort_pixel(xpos012.y, ypos) * rowtap012.y +
        undistort_pixel(xpos012.z, ypos) * rowtap012.z +
        undistort_pixel(xpos345.x, ypos) * rowtap345.x +
        undistort_pixel(xpos345.y, ypos) * rowtap345.y +
        undistort_pixel(xpos345.z, ypos) * rowtap345.z;
}

vec4 DrawLanczos(FragData f_in, bool undistort)
{
    vec2 pos = f_in.uv;
    vec2 pos2 = floor(pos - 0.5) + 0.5;
    vec2 f_neg = pos2 - pos;

    vec3 rowtap012, rowtap345;
    weight6(f_neg.x, rowtap012, rowtap345);

    vec3 coltap012, coltap345;
    weight6(f_neg.y, coltap012, coltap345);

    vec2 uv2 = pos2 * base_dimension_i;
    vec2 uv1 = uv2 - base_dimension_i;
    vec2 uv0 = uv1 - base_dimension_i;
    vec2 uv3 = uv2 + base_dimension_i;
    vec2 uv4 = uv3 + base_dimension_i;
    vec2 uv5 = uv4 + base_dimension_i;

    if (undistort) {
        vec3 xpos012 = vec3(uv0.x, uv1.x, uv2.x);
        vec3 xpos345 = vec3(uv3.x, uv4.x, uv5.x);
        return undistort_line(xpos012, xpos345, uv0.y, rowtap012, rowtap345) * coltap012.x +
               undistort_line(xpos012, xpos345, uv1.y, rowtap012, rowtap345) * coltap012.y +
               undistort_line(xpos012, xpos345, uv2.y, rowtap012, rowtap345) * coltap012.z +
               undistort_line(xpos012, xpos345, uv3.y, rowtap012, rowtap345) * coltap345.x +
               undistort_line(xpos012, xpos345, uv4.y, rowtap012, rowtap345) * coltap345.y +
               undistort_line(xpos012, xpos345, uv5.y, rowtap012, rowtap345) * coltap345.z;
    }

    float u_weight_sum = rowtap012.z + rowtap345.x;
    float u_middle_offset = rowtap345.x * base_dimension_i.x / u_weight_sum;
    float u_middle = uv2.x + u_middle_offset;

    float v_weight_sum = coltap012.z + coltap345.x;
    float v_middle_offset = coltap345.x * base_dimension_i.y / v_weight_sum;
    float v_middle = uv2.y + v_middle_offset;

    vec2 coord_limit = base_dimension - 0.5;
    vec2 coord0_f = max(uv0 * base_dimension, 0.5);
    vec2 coord1_f = max(uv1 * base_dimension, 0.5);
    vec2 coord4_f = min(uv4 * base_dimension, coord_limit);
    vec2 coord5_f = min(uv5 * base_dimension, coord_limit);

    ivec2 coord0 = ivec2(coord0_f);
    ivec2 coord1 = ivec2(coord1_f);
    ivec2 coord4 = ivec2(coord4_f);
    ivec2 coord5 = ivec2(coord5_f);

    vec4 row0 = obs_load_2d(image, ivec3(coord0, 0)) * rowtap012.x;
    row0 += obs_load_2d(image, ivec3(coord1.x, coord0.y, 0)) * rowtap012.y;
    row0 += texture(image, vec2(u_middle, uv0.y)) * u_weight_sum;
    row0 += obs_load
info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform vec2 base_dimension;
uniform mat4x4 ViewProj;

in vec4 _input_attrib0;
in vec2 _input_attrib1;

out vec2 _vertex_shader_attrib0;

out gl_PerVertex {
    vec4 gl_Position;
};

struct VertOut {
    vec2 uv;
    vec4 pos;
};

struct VertData {
    vec4 pos;
    vec2 uv;
};

VertOut VSDefault(VertData v_in)
{
    VertOut vert_out;
    vert_out.uv  = v_in.uv * base_dimension;
    vert_out.pos = ((vec4(v_in.pos.xyz, 1.0)) * (ViewProj));

    return vert_out;
}

VertOut _main_wrap(VertData v_in)
{
    return VSDefault(v_in);
}

void main(void)
{
    VertData v_in;
    VertOut outputval;

    v_in.pos = _input_attrib0;
    v_in.uv = _input_attrib1;

    outputval = _main_wrap(v_in);

    _vertex_shader_attrib0 = outputval.uv;
    gl_Position = outputval.pos;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform vec2 base_dimension_i;
uniform vec2 base_dimension;
uniform sampler2D image;
uniform float undistort_factor;

in vec2 _vertex_shader_attrib0;

out vec4 _pixel_shader_attrib0;

struct FragData {
    vec2 uv;
};

float weight(float x)
{
    float x_pi = x * 3.141592654;
    return 3.0 * sin(x_pi) * sin(x_pi * (1.0 / 3.0)) / (x_pi * x_pi);
}

void weight6(float f_neg, out vec3 tap012, out vec3 tap345)
{
    tap012 = vec3(
        weight(f_neg - 2.0),
        weight(f_neg - 1.0),
        min(1.0, weight(f_neg)));
    tap345 = vec3(
        weight(f_neg + 1.0),
        weight(f_neg + 2.0),
        weight(f_neg + 3.0));

     
    float sum = tap012.x + tap012.y + tap012.z + tap345.x + tap345.y + tap345.z;
    float sum_i = 1.0 / sum;
    tap012 = tap012 * sum_i;
    tap345 = tap345 * sum_i;
}

float AspectUndistortX(float x, float a)
{
     
    return (1.0 - a) * (x * x * x * x * x) + a * x;
}

float AspectUndistortU(float u)
{
     
    return AspectUndistortX((u - 0.5) * 2.0, undistort_factor) * 0.5 + 0.5;
}

vec2 undistort_coord(float xpos, float ypos)
{
    return vec2(AspectUndistortU(xpos), ypos);
}

vec4 undistort_pixel(float xpos, float ypos)
{
    return texture(image, undistort_coord(xpos, ypos));
}

vec4 undistort_line(vec3 xpos012, vec3 xpos345, float ypos, vec3 rowtap012, vec3 rowtap345)
{
    return
        undistort_pixel(xpos012.x, ypos) * rowtap012.x +
        undistort_pixel(xpos012.y, ypos) * rowtap012.y +
        undistort_pixel(xpos012.z, ypos) * rowtap012.z +
        undistort_pixel(xpos345.x, ypos) * rowtap345.x +
        undistort_pixel(xpos345.y, ypos) * rowtap345.y +
        undistort_pixel(xpos345.z, ypos) * rowtap345.z;
}

vec4 DrawLanczos(FragData f_in, bool undistort)
{
    vec2 pos = f_in.uv;
    vec2 pos2 = floor(pos - 0.5) + 0.5;
    vec2 f_neg = pos2 - pos;

    vec3 rowtap012, rowtap345;
    weight6(f_neg.x, rowtap012, rowtap345);

    vec3 coltap012, coltap345;
    weight6(f_neg.y, coltap012, coltap345);

    vec2 uv2 = pos2 * base_dimension_i;
    vec2 uv1 = uv2 - base_dimension_i;
    vec2 uv0 = uv1 - base_dimension_i;
    vec2 uv3 = uv2 + base_dimension_i;
    vec2 uv4 = uv3 + base_dimension_i;
    vec2 uv5 = uv4 + base_dimension_i;

    if (undistort) {
        vec3 xpos012 = vec3(uv0.x, uv1.x, uv2.x);
        vec3 xpos345 = vec3(uv3.x, uv4.x, uv5.x);
        return undistort_line(xpos012, xpos345, uv0.y, rowtap012, rowtap345) * coltap012.x +
               undistort_line(xpos012, xpos345, uv1.y, rowtap012, rowtap345) * coltap012.y +
               undistort_line(xpos012, xpos345, uv2.y, rowtap012, rowtap345) * coltap012.z +
               undistort_line(xpos012, xpos345, uv3.y, rowtap012, rowtap345) * coltap345.x +
               undistort_line(xpos012, xpos345, uv4.y, rowtap012, rowtap345) * coltap345.y +
               undistort_line(xpos012, xpos345, uv5.y, rowtap012, rowtap345) * coltap345.z;
    }

    float u_weight_sum = rowtap012.z + rowtap345.x;
    float u_middle_offset = rowtap345.x * base_dimension_i.x / u_weight_sum;
    float u_middle = uv2.x + u_middle_offset;

    float v_weight_sum = coltap012.z + coltap345.x;
    float v_middle_offset = coltap345.x * base_dimension_i.y / v_weight_sum;
    float v_middle = uv2.y + v_middle_offset;

    vec2 coord_limit = base_dimension - 0.5;
    vec2 coord0_f = max(uv0 * base_dimension, 0.5);
    vec2 coord1_f = max(uv1 * base_dimension, 0.5);
    vec2 coord4_f = min(uv4 * base_dimension, coord_limit);
    vec2 coord5_f = min(uv5 * base_dimension, coord_limit);

    ivec2 coord0 = ivec2(coord0_f);
    ivec2 coord1 = ivec2(coord1_f);
    ivec2 coord4 = ivec2(coord4_f);
    ivec2 coord5 = ivec2(coord5_f);

    vec4 row0 = obs_load_2d(image, ivec3(coord0, 0)) * rowtap012.x;
    row0 += obs_load_2d(image, ivec3(coord1.x, coord0.y, 0)) * rowtap012.y;
    row0 += texture(image, vec2(u_middle, uv0.y)) * u_weight_sum;
    row0 += obs_load_2d(image, ivec3(coord4.x,
info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform vec2 base_dimension;
uniform mat4x4 ViewProj;

in vec4 _input_attrib0;
in vec2 _input_attrib1;

out vec2 _vertex_shader_attrib0;

out gl_PerVertex {
    vec4 gl_Position;
};

struct VertOut {
    vec2 uv;
    vec4 pos;
};

struct VertData {
    vec4 pos;
    vec2 uv;
};

VertOut VSDefault(VertData v_in)
{
    VertOut vert_out;
    vert_out.uv  = v_in.uv * base_dimension;
    vert_out.pos = ((vec4(v_in.pos.xyz, 1.0)) * (ViewProj));

    return vert_out;
}

VertOut _main_wrap(VertData v_in)
{
    return VSDefault(v_in);
}

void main(void)
{
    VertData v_in;
    VertOut outputval;

    v_in.pos = _input_attrib0;
    v_in.uv = _input_attrib1;

    outputval = _main_wrap(v_in);

    _vertex_shader_attrib0 = outputval.uv;
    gl_Position = outputval.pos;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform float multiplier;
uniform vec2 base_dimension_i;
uniform vec2 base_dimension;
uniform sampler2D image;
uniform float undistort_factor;

in vec2 _vertex_shader_attrib0;

out vec4 _pixel_shader_attrib0;

struct FragData {
    vec2 uv;
};

float weight(float x)
{
    float x_pi = x * 3.141592654;
    return 3.0 * sin(x_pi) * sin(x_pi * (1.0 / 3.0)) / (x_pi * x_pi);
}

void weight6(float f_neg, out vec3 tap012, out vec3 tap345)
{
    tap012 = vec3(
        weight(f_neg - 2.0),
        weight(f_neg - 1.0),
        min(1.0, weight(f_neg)));
    tap345 = vec3(
        weight(f_neg + 1.0),
        weight(f_neg + 2.0),
        weight(f_neg + 3.0));

     
    float sum = tap012.x + tap012.y + tap012.z + tap345.x + tap345.y + tap345.z;
    float sum_i = 1.0 / sum;
    tap012 = tap012 * sum_i;
    tap345 = tap345 * sum_i;
}

float AspectUndistortX(float x, float a)
{
     
    return (1.0 - a) * (x * x * x * x * x) + a * x;
}

float AspectUndistortU(float u)
{
     
    return AspectUndistortX((u - 0.5) * 2.0, undistort_factor) * 0.5 + 0.5;
}

vec2 undistort_coord(float xpos, float ypos)
{
    return vec2(AspectUndistortU(xpos), ypos);
}

vec4 undistort_pixel(float xpos, float ypos)
{
    return texture(image, undistort_coord(xpos, ypos));
}

vec4 undistort_line(vec3 xpos012, vec3 xpos345, float ypos, vec3 rowtap012, vec3 rowtap345)
{
    return
        undistort_pixel(xpos012.x, ypos) * rowtap012.x +
        undistort_pixel(xpos012.y, ypos) * rowtap012.y +
        undistort_pixel(xpos012.z, ypos) * rowtap012.z +
        undistort_pixel(xpos345.x, ypos) * rowtap345.x +
        undistort_pixel(xpos345.y, ypos) * rowtap345.y +
        undistort_pixel(xpos345.z, ypos) * rowtap345.z;
}

vec4 DrawLanczos(FragData f_in, bool undistort)
{
    vec2 pos = f_in.uv;
    vec2 pos2 = floor(pos - 0.5) + 0.5;
    vec2 f_neg = pos2 - pos;

    vec3 rowtap012, rowtap345;
    weight6(f_neg.x, rowtap012, rowtap345);

    vec3 coltap012, coltap345;
    weight6(f_neg.y, coltap012, coltap345);

    vec2 uv2 = pos2 * base_dimension_i;
    vec2 uv1 = uv2 - base_dimension_i;
    vec2 uv0 = uv1 - base_dimension_i;
    vec2 uv3 = uv2 + base_dimension_i;
    vec2 uv4 = uv3 + base_dimension_i;
    vec2 uv5 = uv4 + base_dimension_i;

    if (undistort) {
        vec3 xpos012 = vec3(uv0.x, uv1.x, uv2.x);
        vec3 xpos345 = vec3(uv3.x, uv4.x, uv5.x);
        return undistort_line(xpos012, xpos345, uv0.y, rowtap012, rowtap345) * coltap012.x +
               undistort_line(xpos012, xpos345, uv1.y, rowtap012, rowtap345) * coltap012.y +
               undistort_line(xpos012, xpos345, uv2.y, rowtap012, rowtap345) * coltap012.z +
               undistort_line(xpos012, xpos345, uv3.y, rowtap012, rowtap345) * coltap345.x +
               undistort_line(xpos012, xpos345, uv4.y, rowtap012, rowtap345) * coltap345.y +
               undistort_line(xpos012, xpos345, uv5.y, rowtap012, rowtap345) * coltap345.z;
    }

    float u_weight_sum = rowtap012.z + rowtap345.x;
    float u_middle_offset = rowtap345.x * base_dimension_i.x / u_weight_sum;
    float u_middle = uv2.x + u_middle_offset;

    float v_weight_sum = coltap012.z + coltap345.x;
    float v_middle_offset = coltap345.x * base_dimension_i.y / v_weight_sum;
    float v_middle = uv2.y + v_middle_offset;

    vec2 coord_limit = base_dimension - 0.5;
    vec2 coord0_f = max(uv0 * base_dimension, 0.5);
    vec2 coord1_f = max(uv1 * base_dimension, 0.5);
    vec2 coord4_f = min(uv4 * base_dimension, coord_limit);
    vec2 coord5_f = min(uv5 * base_dimension, coord_limit);

    ivec2 coord0 = ivec2(coord0_f);
    ivec2 coord1 = ivec2(coord1_f);
    ivec2 coord4 = ivec2(coord4_f);
    ivec2 coord5 = ivec2(coord5_f);

    vec4 row0 = obs_load_2d(image, ivec3(coord0, 0)) * rowtap012.x;
    row0 += obs_load_2d(image, ivec3(coord1.x, coord0.y, 0)) * rowtap012.y;
    row0 += texture(image, vec2(u_middle, uv0.y)) * u_weight_sum;
    row0 += obs_load
info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform vec2 base_dimension;
uniform mat4x4 ViewProj;

in vec4 _input_attrib0;
in vec2 _input_attrib1;

out vec2 _vertex_shader_attrib0;

out gl_PerVertex {
    vec4 gl_Position;
};

struct VertOut {
    vec2 uv;
    vec4 pos;
};

struct VertData {
    vec4 pos;
    vec2 uv;
};

VertOut VSDefault(VertData v_in)
{
    VertOut vert_out;
    vert_out.uv  = v_in.uv * base_dimension;
    vert_out.pos = ((vec4(v_in.pos.xyz, 1.0)) * (ViewProj));

    return vert_out;
}

VertOut _main_wrap(VertData v_in)
{
    return VSDefault(v_in);
}

void main(void)
{
    VertData v_in;
    VertOut outputval;

    v_in.pos = _input_attrib0;
    v_in.uv = _input_attrib1;

    outputval = _main_wrap(v_in);

    _vertex_shader_attrib0 = outputval.uv;
    gl_Position = outputval.pos;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform vec2 base_dimension_i;
uniform vec2 base_dimension;
uniform sampler2D image;
uniform float undistort_factor;

in vec2 _vertex_shader_attrib0;

out vec4 _pixel_shader_attrib0;

struct FragData {
    vec2 uv;
};

float weight(float x)
{
    float x_pi = x * 3.141592654;
    return 3.0 * sin(x_pi) * sin(x_pi * (1.0 / 3.0)) / (x_pi * x_pi);
}

void weight6(float f_neg, out vec3 tap012, out vec3 tap345)
{
    tap012 = vec3(
        weight(f_neg - 2.0),
        weight(f_neg - 1.0),
        min(1.0, weight(f_neg)));
    tap345 = vec3(
        weight(f_neg + 1.0),
        weight(f_neg + 2.0),
        weight(f_neg + 3.0));

     
    float sum = tap012.x + tap012.y + tap012.z + tap345.x + tap345.y + tap345.z;
    float sum_i = 1.0 / sum;
    tap012 = tap012 * sum_i;
    tap345 = tap345 * sum_i;
}

float AspectUndistortX(float x, float a)
{
     
    return (1.0 - a) * (x * x * x * x * x) + a * x;
}

float AspectUndistortU(float u)
{
     
    return AspectUndistortX((u - 0.5) * 2.0, undistort_factor) * 0.5 + 0.5;
}

vec2 undistort_coord(float xpos, float ypos)
{
    return vec2(AspectUndistortU(xpos), ypos);
}

vec4 undistort_pixel(float xpos, float ypos)
{
    return texture(image, undistort_coord(xpos, ypos));
}

vec4 undistort_line(vec3 xpos012, vec3 xpos345, float ypos, vec3 rowtap012, vec3 rowtap345)
{
    return
        undistort_pixel(xpos012.x, ypos) * rowtap012.x +
        undistort_pixel(xpos012.y, ypos) * rowtap012.y +
        undistort_pixel(xpos012.z, ypos) * rowtap012.z +
        undistort_pixel(xpos345.x, ypos) * rowtap345.x +
        undistort_pixel(xpos345.y, ypos) * rowtap345.y +
        undistort_pixel(xpos345.z, ypos) * rowtap345.z;
}

vec4 DrawLanczos(FragData f_in, bool undistort)
{
    vec2 pos = f_in.uv;
    vec2 pos2 = floor(pos - 0.5) + 0.5;
    vec2 f_neg = pos2 - pos;

    vec3 rowtap012, rowtap345;
    weight6(f_neg.x, rowtap012, rowtap345);

    vec3 coltap012, coltap345;
    weight6(f_neg.y, coltap012, coltap345);

    vec2 uv2 = pos2 * base_dimension_i;
    vec2 uv1 = uv2 - base_dimension_i;
    vec2 uv0 = uv1 - base_dimension_i;
    vec2 uv3 = uv2 + base_dimension_i;
    vec2 uv4 = uv3 + base_dimension_i;
    vec2 uv5 = uv4 + base_dimension_i;

    if (undistort) {
        vec3 xpos012 = vec3(uv0.x, uv1.x, uv2.x);
        vec3 xpos345 = vec3(uv3.x, uv4.x, uv5.x);
        return undistort_line(xpos012, xpos345, uv0.y, rowtap012, rowtap345) * coltap012.x +
               undistort_line(xpos012, xpos345, uv1.y, rowtap012, rowtap345) * coltap012.y +
               undistort_line(xpos012, xpos345, uv2.y, rowtap012, rowtap345) * coltap012.z +
               undistort_line(xpos012, xpos345, uv3.y, rowtap012, rowtap345) * coltap345.x +
               undistort_line(xpos012, xpos345, uv4.y, rowtap012, rowtap345) * coltap345.y +
               undistort_line(xpos012, xpos345, uv5.y, rowtap012, rowtap345) * coltap345.z;
    }

    float u_weight_sum = rowtap012.z + rowtap345.x;
    float u_middle_offset = rowtap345.x * base_dimension_i.x / u_weight_sum;
    float u_middle = uv2.x + u_middle_offset;

    float v_weight_sum = coltap012.z + coltap345.x;
    float v_middle_offset = coltap345.x * base_dimension_i.y / v_weight_sum;
    float v_middle = uv2.y + v_middle_offset;

    vec2 coord_limit = base_dimension - 0.5;
    vec2 coord0_f = max(uv0 * base_dimension, 0.5);
    vec2 coord1_f = max(uv1 * base_dimension, 0.5);
    vec2 coord4_f = min(uv4 * base_dimension, coord_limit);
    vec2 coord5_f = min(uv5 * base_dimension, coord_limit);

    ivec2 coord0 = ivec2(coord0_f);
    ivec2 coord1 = ivec2(coord1_f);
    ivec2 coord4 = ivec2(coord4_f);
    ivec2 coord5 = ivec2(coord5_f);

    vec4 row0 = obs_load_2d(image, ivec3(coord0, 0)) * rowtap012.x;
    row0 += obs_load_2d(image, ivec3(coord1.x, coord0.y, 0)) * rowtap012.y;
    row0 += texture(image, vec2(u_middle, uv0.y)) * u_weight_sum;
    row0 += obs_load_2d(image, ivec3(coord4.x,
info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform vec2 base_dimension;
uniform mat4x4 ViewProj;

in vec4 _input_attrib0;
in vec2 _input_attrib1;

out vec2 _vertex_shader_attrib0;

out gl_PerVertex {
    vec4 gl_Position;
};

struct VertOut {
    vec2 uv;
    vec4 pos;
};

struct VertData {
    vec4 pos;
    vec2 uv;
};

VertOut VSDefault(VertData v_in)
{
    VertOut vert_out;
    vert_out.uv  = v_in.uv * base_dimension;
    vert_out.pos = ((vec4(v_in.pos.xyz, 1.0)) * (ViewProj));

    return vert_out;
}

VertOut _main_wrap(VertData v_in)
{
    return VSDefault(v_in);
}

void main(void)
{
    VertData v_in;
    VertOut outputval;

    v_in.pos = _input_attrib0;
    v_in.uv = _input_attrib1;

    outputval = _main_wrap(v_in);

    _vertex_shader_attrib0 = outputval.uv;
    gl_Position = outputval.pos;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform vec2 base_dimension_i;
uniform vec2 base_dimension;
uniform sampler2D image;
uniform float undistort_factor;

in vec2 _vertex_shader_attrib0;

out vec4 _pixel_shader_attrib0;

struct FragData {
    vec2 uv;
};

float weight(float x)
{
    float x_pi = x * 3.141592654;
    return 3.0 * sin(x_pi) * sin(x_pi * (1.0 / 3.0)) / (x_pi * x_pi);
}

void weight6(float f_neg, out vec3 tap012, out vec3 tap345)
{
    tap012 = vec3(
        weight(f_neg - 2.0),
        weight(f_neg - 1.0),
        min(1.0, weight(f_neg)));
    tap345 = vec3(
        weight(f_neg + 1.0),
        weight(f_neg + 2.0),
        weight(f_neg + 3.0));

     
    float sum = tap012.x + tap012.y + tap012.z + tap345.x + tap345.y + tap345.z;
    float sum_i = 1.0 / sum;
    tap012 = tap012 * sum_i;
    tap345 = tap345 * sum_i;
}

float AspectUndistortX(float x, float a)
{
     
    return (1.0 - a) * (x * x * x * x * x) + a * x;
}

float AspectUndistortU(float u)
{
     
    return AspectUndistortX((u - 0.5) * 2.0, undistort_factor) * 0.5 + 0.5;
}

vec2 undistort_coord(float xpos, float ypos)
{
    return vec2(AspectUndistortU(xpos), ypos);
}

vec4 undistort_pixel(float xpos, float ypos)
{
    return texture(image, undistort_coord(xpos, ypos));
}

vec4 undistort_line(vec3 xpos012, vec3 xpos345, float ypos, vec3 rowtap012, vec3 rowtap345)
{
    return
        undistort_pixel(xpos012.x, ypos) * rowtap012.x +
        undistort_pixel(xpos012.y, ypos) * rowtap012.y +
        undistort_pixel(xpos012.z, ypos) * rowtap012.z +
        undistort_pixel(xpos345.x, ypos) * rowtap345.x +
        undistort_pixel(xpos345.y, ypos) * rowtap345.y +
        undistort_pixel(xpos345.z, ypos) * rowtap345.z;
}

vec4 DrawLanczos(FragData f_in, bool undistort)
{
    vec2 pos = f_in.uv;
    vec2 pos2 = floor(pos - 0.5) + 0.5;
    vec2 f_neg = pos2 - pos;

    vec3 rowtap012, rowtap345;
    weight6(f_neg.x, rowtap012, rowtap345);

    vec3 coltap012, coltap345;
    weight6(f_neg.y, coltap012, coltap345);

    vec2 uv2 = pos2 * base_dimension_i;
    vec2 uv1 = uv2 - base_dimension_i;
    vec2 uv0 = uv1 - base_dimension_i;
    vec2 uv3 = uv2 + base_dimension_i;
    vec2 uv4 = uv3 + base_dimension_i;
    vec2 uv5 = uv4 + base_dimension_i;

    if (undistort) {
        vec3 xpos012 = vec3(uv0.x, uv1.x, uv2.x);
        vec3 xpos345 = vec3(uv3.x, uv4.x, uv5.x);
        return undistort_line(xpos012, xpos345, uv0.y, rowtap012, rowtap345) * coltap012.x +
               undistort_line(xpos012, xpos345, uv1.y, rowtap012, rowtap345) * coltap012.y +
               undistort_line(xpos012, xpos345, uv2.y, rowtap012, rowtap345) * coltap012.z +
               undistort_line(xpos012, xpos345, uv3.y, rowtap012, rowtap345) * coltap345.x +
               undistort_line(xpos012, xpos345, uv4.y, rowtap012, rowtap345) * coltap345.y +
               undistort_line(xpos012, xpos345, uv5.y, rowtap012, rowtap345) * coltap345.z;
    }

    float u_weight_sum = rowtap012.z + rowtap345.x;
    float u_middle_offset = rowtap345.x * base_dimension_i.x / u_weight_sum;
    float u_middle = uv2.x + u_middle_offset;

    float v_weight_sum = coltap012.z + coltap345.x;
    float v_middle_offset = coltap345.x * base_dimension_i.y / v_weight_sum;
    float v_middle = uv2.y + v_middle_offset;

    vec2 coord_limit = base_dimension - 0.5;
    vec2 coord0_f = max(uv0 * base_dimension, 0.5);
    vec2 coord1_f = max(uv1 * base_dimension, 0.5);
    vec2 coord4_f = min(uv4 * base_dimension, coord_limit);
    vec2 coord5_f = min(uv5 * base_dimension, coord_limit);

    ivec2 coord0 = ivec2(coord0_f);
    ivec2 coord1 = ivec2(coord1_f);
    ivec2 coord4 = ivec2(coord4_f);
    ivec2 coord5 = ivec2(coord5_f);

    vec4 row0 = obs_load_2d(image, ivec3(coord0, 0)) * rowtap012.x;
    row0 += obs_load_2d(image, ivec3(coord1.x, coord0.y, 0)) * rowtap012.y;
    row0 += texture(image, vec2(u_middle, uv0.y)) * u_weight_sum;
    row0 += obs_load_2d(image, ivec3(coord4.x,
info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform vec2 base_dimension;
uniform mat4x4 ViewProj;

in vec4 _input_attrib0;
in vec2 _input_attrib1;

out vec2 _vertex_shader_attrib0;

out gl_PerVertex {
    vec4 gl_Position;
};

struct VertOut {
    vec2 uv;
    vec4 pos;
};

struct VertData {
    vec4 pos;
    vec2 uv;
};

VertOut VSDefault(VertData v_in)
{
    VertOut vert_out;
    vert_out.uv  = v_in.uv * base_dimension;
    vert_out.pos = ((vec4(v_in.pos.xyz, 1.0)) * (ViewProj));

    return vert_out;
}

VertOut _main_wrap(VertData v_in)
{
    return VSDefault(v_in);
}

void main(void)
{
    VertData v_in;
    VertOut outputval;

    v_in.pos = _input_attrib0;
    v_in.uv = _input_attrib1;

    outputval = _main_wrap(v_in);

    _vertex_shader_attrib0 = outputval.uv;
    gl_Position = outputval.pos;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform float multiplier;
uniform vec2 base_dimension_i;
uniform vec2 base_dimension;
uniform sampler2D image;
uniform float undistort_factor;

in vec2 _vertex_shader_attrib0;

out vec4 _pixel_shader_attrib0;

struct FragData {
    vec2 uv;
};

float weight(float x)
{
    float x_pi = x * 3.141592654;
    return 3.0 * sin(x_pi) * sin(x_pi * (1.0 / 3.0)) / (x_pi * x_pi);
}

void weight6(float f_neg, out vec3 tap012, out vec3 tap345)
{
    tap012 = vec3(
        weight(f_neg - 2.0),
        weight(f_neg - 1.0),
        min(1.0, weight(f_neg)));
    tap345 = vec3(
        weight(f_neg + 1.0),
        weight(f_neg + 2.0),
        weight(f_neg + 3.0));

     
    float sum = tap012.x + tap012.y + tap012.z + tap345.x + tap345.y + tap345.z;
    float sum_i = 1.0 / sum;
    tap012 = tap012 * sum_i;
    tap345 = tap345 * sum_i;
}

float AspectUndistortX(float x, float a)
{
     
    return (1.0 - a) * (x * x * x * x * x) + a * x;
}

float AspectUndistortU(float u)
{
     
    return AspectUndistortX((u - 0.5) * 2.0, undistort_factor) * 0.5 + 0.5;
}

vec2 undistort_coord(float xpos, float ypos)
{
    return vec2(AspectUndistortU(xpos), ypos);
}

vec4 undistort_pixel(float xpos, float ypos)
{
    return texture(image, undistort_coord(xpos, ypos));
}

vec4 undistort_line(vec3 xpos012, vec3 xpos345, float ypos, vec3 rowtap012, vec3 rowtap345)
{
    return
        undistort_pixel(xpos012.x, ypos) * rowtap012.x +
        undistort_pixel(xpos012.y, ypos) * rowtap012.y +
        undistort_pixel(xpos012.z, ypos) * rowtap012.z +
        undistort_pixel(xpos345.x, ypos) * rowtap345.x +
        undistort_pixel(xpos345.y, ypos) * rowtap345.y +
        undistort_pixel(xpos345.z, ypos) * rowtap345.z;
}

vec4 DrawLanczos(FragData f_in, bool undistort)
{
    vec2 pos = f_in.uv;
    vec2 pos2 = floor(pos - 0.5) + 0.5;
    vec2 f_neg = pos2 - pos;

    vec3 rowtap012, rowtap345;
    weight6(f_neg.x, rowtap012, rowtap345);

    vec3 coltap012, coltap345;
    weight6(f_neg.y, coltap012, coltap345);

    vec2 uv2 = pos2 * base_dimension_i;
    vec2 uv1 = uv2 - base_dimension_i;
    vec2 uv0 = uv1 - base_dimension_i;
    vec2 uv3 = uv2 + base_dimension_i;
    vec2 uv4 = uv3 + base_dimension_i;
    vec2 uv5 = uv4 + base_dimension_i;

    if (undistort) {
        vec3 xpos012 = vec3(uv0.x, uv1.x, uv2.x);
        vec3 xpos345 = vec3(uv3.x, uv4.x, uv5.x);
        return undistort_line(xpos012, xpos345, uv0.y, rowtap012, rowtap345) * coltap012.x +
               undistort_line(xpos012, xpos345, uv1.y, rowtap012, rowtap345) * coltap012.y +
               undistort_line(xpos012, xpos345, uv2.y, rowtap012, rowtap345) * coltap012.z +
               undistort_line(xpos012, xpos345, uv3.y, rowtap012, rowtap345) * coltap345.x +
               undistort_line(xpos012, xpos345, uv4.y, rowtap012, rowtap345) * coltap345.y +
               undistort_line(xpos012, xpos345, uv5.y, rowtap012, rowtap345) * coltap345.z;
    }

    float u_weight_sum = rowtap012.z + rowtap345.x;
    float u_middle_offset = rowtap345.x * base_dimension_i.x / u_weight_sum;
    float u_middle = uv2.x + u_middle_offset;

    float v_weight_sum = coltap012.z + coltap345.x;
    float v_middle_offset = coltap345.x * base_dimension_i.y / v_weight_sum;
    float v_middle = uv2.y + v_middle_offset;

    vec2 coord_limit = base_dimension - 0.5;
    vec2 coord0_f = max(uv0 * base_dimension, 0.5);
    vec2 coord1_f = max(uv1 * base_dimension, 0.5);
    vec2 coord4_f = min(uv4 * base_dimension, coord_limit);
    vec2 coord5_f = min(uv5 * base_dimension, coord_limit);

    ivec2 coord0 = ivec2(coord0_f);
    ivec2 coord1 = ivec2(coord1_f);
    ivec2 coord4 = ivec2(coord4_f);
    ivec2 coord5 = ivec2(coord5_f);

    vec4 row0 = obs_load_2d(image, ivec3(coord0, 0)) * rowtap012.x;
    row0 += obs_load_2d(image, ivec3(coord1.x, coord0.y, 0)) * rowtap012.y;
    row0 += texture(image, vec2(u_middle, uv0.y)) * u_weight_sum;
    row0 += obs_load
info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform vec2 base_dimension;
uniform mat4x4 ViewProj;

in vec4 _input_attrib0;
in vec2 _input_attrib1;

out vec2 _vertex_shader_attrib0;

out gl_PerVertex {
    vec4 gl_Position;
};

struct VertOut {
    vec2 uv;
    vec4 pos;
};

struct VertData {
    vec4 pos;
    vec2 uv;
};

VertOut VSDefault(VertData v_in)
{
    VertOut vert_out;
    vert_out.uv  = v_in.uv * base_dimension;
    vert_out.pos = ((vec4(v_in.pos.xyz, 1.0)) * (ViewProj));

    return vert_out;
}

VertOut _main_wrap(VertData v_in)
{
    return VSDefault(v_in);
}

void main(void)
{
    VertData v_in;
    VertOut outputval;

    v_in.pos = _input_attrib0;
    v_in.uv = _input_attrib1;

    outputval = _main_wrap(v_in);

    _vertex_shader_attrib0 = outputval.uv;
    gl_Position = outputval.pos;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform vec2 base_dimension_i;
uniform vec2 base_dimension;
uniform sampler2D image;
uniform float undistort_factor;

in vec2 _vertex_shader_attrib0;

out vec4 _pixel_shader_attrib0;

struct FragData {
    vec2 uv;
};

float weight(float x)
{
    float x_pi = x * 3.141592654;
    return 3.0 * sin(x_pi) * sin(x_pi * (1.0 / 3.0)) / (x_pi * x_pi);
}

void weight6(float f_neg, out vec3 tap012, out vec3 tap345)
{
    tap012 = vec3(
        weight(f_neg - 2.0),
        weight(f_neg - 1.0),
        min(1.0, weight(f_neg)));
    tap345 = vec3(
        weight(f_neg + 1.0),
        weight(f_neg + 2.0),
        weight(f_neg + 3.0));

     
    float sum = tap012.x + tap012.y + tap012.z + tap345.x + tap345.y + tap345.z;
    float sum_i = 1.0 / sum;
    tap012 = tap012 * sum_i;
    tap345 = tap345 * sum_i;
}

float AspectUndistortX(float x, float a)
{
     
    return (1.0 - a) * (x * x * x * x * x) + a * x;
}

float AspectUndistortU(float u)
{
     
    return AspectUndistortX((u - 0.5) * 2.0, undistort_factor) * 0.5 + 0.5;
}

vec2 undistort_coord(float xpos, float ypos)
{
    return vec2(AspectUndistortU(xpos), ypos);
}

vec4 undistort_pixel(float xpos, float ypos)
{
    return texture(image, undistort_coord(xpos, ypos));
}

vec4 undistort_line(vec3 xpos012, vec3 xpos345, float ypos, vec3 rowtap012, vec3 rowtap345)
{
    return
        undistort_pixel(xpos012.x, ypos) * rowtap012.x +
        undistort_pixel(xpos012.y, ypos) * rowtap012.y +
        undistort_pixel(xpos012.z, ypos) * rowtap012.z +
        undistort_pixel(xpos345.x, ypos) * rowtap345.x +
        undistort_pixel(xpos345.y, ypos) * rowtap345.y +
        undistort_pixel(xpos345.z, ypos) * rowtap345.z;
}

vec4 DrawLanczos(FragData f_in, bool undistort)
{
    vec2 pos = f_in.uv;
    vec2 pos2 = floor(pos - 0.5) + 0.5;
    vec2 f_neg = pos2 - pos;

    vec3 rowtap012, rowtap345;
    weight6(f_neg.x, rowtap012, rowtap345);

    vec3 coltap012, coltap345;
    weight6(f_neg.y, coltap012, coltap345);

    vec2 uv2 = pos2 * base_dimension_i;
    vec2 uv1 = uv2 - base_dimension_i;
    vec2 uv0 = uv1 - base_dimension_i;
    vec2 uv3 = uv2 + base_dimension_i;
    vec2 uv4 = uv3 + base_dimension_i;
    vec2 uv5 = uv4 + base_dimension_i;

    if (undistort) {
        vec3 xpos012 = vec3(uv0.x, uv1.x, uv2.x);
        vec3 xpos345 = vec3(uv3.x, uv4.x, uv5.x);
        return undistort_line(xpos012, xpos345, uv0.y, rowtap012, rowtap345) * coltap012.x +
               undistort_line(xpos012, xpos345, uv1.y, rowtap012, rowtap345) * coltap012.y +
               undistort_line(xpos012, xpos345, uv2.y, rowtap012, rowtap345) * coltap012.z +
               undistort_line(xpos012, xpos345, uv3.y, rowtap012, rowtap345) * coltap345.x +
               undistort_line(xpos012, xpos345, uv4.y, rowtap012, rowtap345) * coltap345.y +
               undistort_line(xpos012, xpos345, uv5.y, rowtap012, rowtap345) * coltap345.z;
    }

    float u_weight_sum = rowtap012.z + rowtap345.x;
    float u_middle_offset = rowtap345.x * base_dimension_i.x / u_weight_sum;
    float u_middle = uv2.x + u_middle_offset;

    float v_weight_sum = coltap012.z + coltap345.x;
    float v_middle_offset = coltap345.x * base_dimension_i.y / v_weight_sum;
    float v_middle = uv2.y + v_middle_offset;

    vec2 coord_limit = base_dimension - 0.5;
    vec2 coord0_f = max(uv0 * base_dimension, 0.5);
    vec2 coord1_f = max(uv1 * base_dimension, 0.5);
    vec2 coord4_f = min(uv4 * base_dimension, coord_limit);
    vec2 coord5_f = min(uv5 * base_dimension, coord_limit);

    ivec2 coord0 = ivec2(coord0_f);
    ivec2 coord1 = ivec2(coord1_f);
    ivec2 coord4 = ivec2(coord4_f);
    ivec2 coord5 = ivec2(coord5_f);

    vec4 row0 = obs_load_2d(image, ivec3(coord0, 0)) * rowtap012.x;
    row0 += obs_load_2d(image, ivec3(coord1.x, coord0.y, 0)) * rowtap012.y;
    row0 += texture(image, vec2(u_middle, uv0.y)) * u_weight_sum;
    row0 += obs_load_2d(image, ivec3(coord4.x,
info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform vec2 base_dimension;
uniform mat4x4 ViewProj;

in vec4 _input_attrib0;
in vec2 _input_attrib1;

out vec2 _vertex_shader_attrib0;

out gl_PerVertex {
    vec4 gl_Position;
};

struct VertOut {
    vec2 uv;
    vec4 pos;
};

struct VertData {
    vec4 pos;
    vec2 uv;
};

VertOut VSDefault(VertData v_in)
{
    VertOut vert_out;
    vert_out.uv  = v_in.uv * base_dimension;
    vert_out.pos = ((vec4(v_in.pos.xyz, 1.0)) * (ViewProj));

    return vert_out;
}

VertOut _main_wrap(VertData v_in)
{
    return VSDefault(v_in);
}

void main(void)
{
    VertData v_in;
    VertOut outputval;

    v_in.pos = _input_attrib0;
    v_in.uv = _input_attrib1;

    outputval = _main_wrap(v_in);

    _vertex_shader_attrib0 = outputval.uv;
    gl_Position = outputval.pos;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform float multiplier;
uniform vec2 base_dimension_i;
uniform vec2 base_dimension;
uniform sampler2D image;
uniform float undistort_factor;

in vec2 _vertex_shader_attrib0;

out vec4 _pixel_shader_attrib0;

struct FragData {
    vec2 uv;
};

float weight(float x)
{
    float x_pi = x * 3.141592654;
    return 3.0 * sin(x_pi) * sin(x_pi * (1.0 / 3.0)) / (x_pi * x_pi);
}

void weight6(float f_neg, out vec3 tap012, out vec3 tap345)
{
    tap012 = vec3(
        weight(f_neg - 2.0),
        weight(f_neg - 1.0),
        min(1.0, weight(f_neg)));
    tap345 = vec3(
        weight(f_neg + 1.0),
        weight(f_neg + 2.0),
        weight(f_neg + 3.0));

     
    float sum = tap012.x + tap012.y + tap012.z + tap345.x + tap345.y + tap345.z;
    float sum_i = 1.0 / sum;
    tap012 = tap012 * sum_i;
    tap345 = tap345 * sum_i;
}

float AspectUndistortX(float x, float a)
{
     
    return (1.0 - a) * (x * x * x * x * x) + a * x;
}

float AspectUndistortU(float u)
{
     
    return AspectUndistortX((u - 0.5) * 2.0, undistort_factor) * 0.5 + 0.5;
}

vec2 undistort_coord(float xpos, float ypos)
{
    return vec2(AspectUndistortU(xpos), ypos);
}

vec4 undistort_pixel(float xpos, float ypos)
{
    return texture(image, undistort_coord(xpos, ypos));
}

vec4 undistort_line(vec3 xpos012, vec3 xpos345, float ypos, vec3 rowtap012, vec3 rowtap345)
{
    return
        undistort_pixel(xpos012.x, ypos) * rowtap012.x +
        undistort_pixel(xpos012.y, ypos) * rowtap012.y +
        undistort_pixel(xpos012.z, ypos) * rowtap012.z +
        undistort_pixel(xpos345.x, ypos) * rowtap345.x +
        undistort_pixel(xpos345.y, ypos) * rowtap345.y +
        undistort_pixel(xpos345.z, ypos) * rowtap345.z;
}

vec4 DrawLanczos(FragData f_in, bool undistort)
{
    vec2 pos = f_in.uv;
    vec2 pos2 = floor(pos - 0.5) + 0.5;
    vec2 f_neg = pos2 - pos;

    vec3 rowtap012, rowtap345;
    weight6(f_neg.x, rowtap012, rowtap345);

    vec3 coltap012, coltap345;
    weight6(f_neg.y, coltap012, coltap345);

    vec2 uv2 = pos2 * base_dimension_i;
    vec2 uv1 = uv2 - base_dimension_i;
    vec2 uv0 = uv1 - base_dimension_i;
    vec2 uv3 = uv2 + base_dimension_i;
    vec2 uv4 = uv3 + base_dimension_i;
    vec2 uv5 = uv4 + base_dimension_i;

    if (undistort) {
        vec3 xpos012 = vec3(uv0.x, uv1.x, uv2.x);
        vec3 xpos345 = vec3(uv3.x, uv4.x, uv5.x);
        return undistort_line(xpos012, xpos345, uv0.y, rowtap012, rowtap345) * coltap012.x +
               undistort_line(xpos012, xpos345, uv1.y, rowtap012, rowtap345) * coltap012.y +
               undistort_line(xpos012, xpos345, uv2.y, rowtap012, rowtap345) * coltap012.z +
               undistort_line(xpos012, xpos345, uv3.y, rowtap012, rowtap345) * coltap345.x +
               undistort_line(xpos012, xpos345, uv4.y, rowtap012, rowtap345) * coltap345.y +
               undistort_line(xpos012, xpos345, uv5.y, rowtap012, rowtap345) * coltap345.z;
    }

    float u_weight_sum = rowtap012.z + rowtap345.x;
    float u_middle_offset = rowtap345.x * base_dimension_i.x / u_weight_sum;
    float u_middle = uv2.x + u_middle_offset;

    float v_weight_sum = coltap012.z + coltap345.x;
    float v_middle_offset = coltap345.x * base_dimension_i.y / v_weight_sum;
    float v_middle = uv2.y + v_middle_offset;

    vec2 coord_limit = base_dimension - 0.5;
    vec2 coord0_f = max(uv0 * base_dimension, 0.5);
    vec2 coord1_f = max(uv1 * base_dimension, 0.5);
    vec2 coord4_f = min(uv4 * base_dimension, coord_limit);
    vec2 coord5_f = min(uv5 * base_dimension, coord_limit);

    ivec2 coord0 = ivec2(coord0_f);
    ivec2 coord1 = ivec2(coord1_f);
    ivec2 coord4 = ivec2(coord4_f);
    ivec2 coord5 = ivec2(coord5_f);

    vec4 row0 = obs_load_2d(image, ivec3(coord0, 0)) * rowtap012.x;
    row0 += obs_load_2d(image, ivec3(coord1.x, coord0.y, 0)) * rowtap012.y;
    row0 += texture(image, vec2(u_middle, uv0.y)) * u_weight_sum;
    row0 += obs_load
info: ======funcs =======
info: fname:srgb_linear_to_nonlinear_channel rtype:float mapping:(null) content:{
    return (u <= 0.0031308) ? (12.92 * u) : ((1.055 * pow(u, 1. / 2.4)) - 0.055);
}
info: fname:srgb_linear_to_nonlinear rtype:float3 mapping:(null) content:{
    return float3(srgb_linear_to_nonlinear_channel(v.r), srgb_linear_to_nonlinear_channel(v.g), srgb_linear_to_nonlinear_channel(v.b));
}
info: fname:srgb_nonlinear_to_linear_channel rtype:float mapping:(null) content:{
    return (u <= 0.04045) ? (u / 12.92) : pow((u + 0.055) / 1.055, 2.4);
}
info: fname:srgb_nonlinear_to_linear rtype:float3 mapping:(null) content:{
    return float3(srgb_nonlinear_to_linear_channel(v.r), srgb_nonlinear_to_linear_channel(v.g), srgb_nonlinear_to_linear_channel(v.b));
}
info: fname:rec709_to_rec2020 rtype:float3 mapping:(null) content:{
    float r = dot(v, float3(0.62740389593469903, 0.32928303837788370, 0.043313065687417225));
    float g = dot(v, float3(0.069097289358232075, 0.91954039507545871, 0.011362315566309178));
    float b = dot(v, float3(0.016391438875150280, 0.088013307877225749, 0.89559525324762401));
    return float3(r, g, b);
}
info: fname:d65p3_to_rec709 rtype:float3 mapping:(null) content:{
    float r = dot(v, float3(1.2249401762805598, -0.22494017628055996, 0.));
    float g = dot(v, float3(-0.042056954709688163, 1.0420569547096881, 0.));
    float b = dot(v, float3(-0.019637554590334432, -0.078636045550631889, 1.0982736001409663));
    return float3(r, g, b);
}
info: fname:rec2020_to_rec709 rtype:float3 mapping:(null) content:{
    float r = dot(v, float3(1.6604910021084345, -0.58764113878854951, -0.072849863319884883));
    float g = dot(v, float3(-0.12455047452159074, 1.1328998971259603, -0.0083494226043694768));
    float b = dot(v, float3(-0.018150763354905303, -0.10057889800800739, 1.1187296613629127));
    return float3(r, g, b);
}
info: fname:reinhard rtype:float3 mapping:(null) content:{
    rgb /= rgb + float3(1., 1., 1.);
    rgb = pow(rgb, float3(1. / 2.4, 1. / 2.4, 1. / 2.4));
    rgb = srgb_nonlinear_to_linear(rgb);
    return rgb;
}
info: fname:linear_to_st2084_channel rtype:float mapping:(null) content:{
    float c = pow(abs(x), 0.1593017578);
    return pow((0.8359375 + 18.8515625 * c) / (1. + 18.6875 * c), 78.84375);
}
info: fname:linear_to_st2084 rtype:float3 mapping:(null) content:{
    return float3(linear_to_st2084_channel(rgb.r), linear_to_st2084_channel(rgb.g), linear_to_st2084_channel(rgb.b));
}
info: fname:st2084_to_linear_channel rtype:float mapping:(null) content:{
    float c = pow(abs(u), 1. / 78.84375);
    return pow(abs(max(c - 0.8359375, 0.) / (18.8515625 - 18.6875 * c)), 1. / 0.1593017578);
}
info: fname:st2084_to_linear rtype:float3 mapping:(null) content:{
    return float3(st2084_to_linear_channel(rgb.r), st2084_to_linear_channel(rgb.g), st2084_to_linear_channel(rgb.b));
}
info: fname:eetf_0_Lmax rtype:float mapping:(null) content:{
    float Lw_pq = linear_to_st2084_channel(Lw / 10000.);
    float E1 = saturate(maxRGB1_pq / Lw_pq);
    float maxLum = linear_to_st2084_channel(Lmax / 10000.) / Lw_pq;
    float KS = (1.5 * maxLum) - 0.5;
    float E2 = E1;
    if (E1 > KS)
    {
        float T = (E1 - KS) / (1. - KS);
        float Tsquared = T * T;
        float Tcubed = Tsquared * T;
        float P = (2. * Tcubed - 3. * Tsquared + 1.) * KS + (Tcubed - 2. * Tsquared + T) * (1. - KS) + (-2. * Tcubed + 3. * Tsquared) * maxLum;
        E2 = P;
    }
    float E3 = E2;
    float E4 = E3 * Lw_pq;
    return E4;
}
info: fname:maxRGB_eetf_internal rtype:float3 mapping:(null) content:{
    float maxRGB2_pq = eetf_0_Lmax(maxRGB1_pq, Lw, Lmax);
    float maxRGB2_linear = st2084_to_linear_channel(maxRGB2_pq);

     
    maxRGB1_linear = max(6.10352e-5, maxRGB1_linear);

    rgb_linear *= maxRGB2_linear / maxRGB1_linear;
    return rgb_linear;
}
info: fname:maxRGB_eetf_pq_to_linear rtype:float3 mapping:(null) content:{
    float3 rgb_linear = st2084_to_linear(rgb_pq);
    float maxRGB1_linear = max(max(rgb_linear.r, rgb_linear.g), rgb_linear.b);
    float maxRGB1_pq = max(max(rgb_pq.r, rgb_pq.g), rgb_pq.b);
    return maxRGB_eetf_internal(rgb_linear, maxRGB1_linear, maxRGB1_pq, Lw, Lmax);
}
info: fname:maxRGB_eetf_linear_to_linear rtype:float3 mapping:(null) content:{
    float maxRGB1_linear = max(max(rgb_linear.r, rgb_linear.g), rgb_linear.b);
    float maxRGB1_pq = linear_to_st2084_channel(maxRGB1_linear);
    return maxRGB_eetf_internal(rgb_linear, maxRGB1_linear, maxRGB1_pq, Lw, Lmax);
}
info: fname:st2084_to_linear_eetf rtype:float3 mapping:(null) content:{
    return (Lw > Lmax) ? maxRGB_eetf_pq_to_linear(rgb, Lw, Lmax) : st2084_to_linear(rgb);
}
info: fname:linear_to_hlg_channel rtype:float mapping:(null) content:{
    float ln2_i = 1. / log(2.);
    float m = 0.17883277 / ln2_i;
    return (u <= (1. / 12.)) ? sqrt(3. * u) : ((log2((12. * u) - 0.28466892) * m) + 0.55991073);
}
info: fname:linear_to_hlg rtype:float3 mapping:(null) content:{
    rgb = saturate(rgb);

    if (Lw > 1000.)
    {
        rgb = maxRGB_eetf_linear_to_linear(rgb, Lw, 1000.);
        rgb *= 10000. / Lw;
    }
    else
    {
        rgb *= 10.;
    }

    float Yd = dot(rgb, float3(0.2627, 0.678, 0.0593));

     
    Yd = max(6.10352e-5, Yd);

    rgb *= pow(Yd, -1. / 6.);
    return float3(linear_to_hlg_channel(rgb.r), linear_to_hlg_channel(rgb.g), linear_to_hlg_channel(rgb.b));
}
info: fname:hlg_to_linear_channel rtype:float mapping:(null) content:{
    float ln2_i = 1. / log(2.);
    float m = ln2_i / 0.17883277;
    float a = -ln2_i * 0.55991073 / 0.17883277;
    return (u <= 0.5) ? ((u * u) / 3.) : ((exp2(u * m + a) + 0.28466892) / 12.);
}
info: fname:hlg_to_linear rtype:float3 mapping:(null) content:{
    float3 rgb = float3(hlg_to_linear_channel(v.r), hlg_to_linear_channel(v.g), hlg_to_linear_channel(v.b));
    float Ys = dot(rgb, float3(0.2627, 0.678, 0.0593));
    rgb *= pow(Ys, exponent);
    return rgb;
}
info: fname:VSDefault rtype:VertOut mapping:(null) content:{
    VertOut vert_out;
    vert_out.uv  = v_in.uv * base_dimension;
    vert_out.pos = mul(float4(v_in.pos.xyz, 1.0), ViewProj);

    return vert_out;
}
info: fname:weight rtype:float mapping:(null) content:{
    float x_pi = x * 3.141592654;
    return 3.0 * sin(x_pi) * sin(x_pi * (1.0 / 3.0)) / (x_pi * x_pi);
}
info: fname:weight6 rtype:void mapping:(null) content:{
    tap012 = float3(
        weight(f_neg - 2.0),
        weight(f_neg - 1.0),
        min(1.0, weight(f_neg)));
    tap345 = float3(
        weight(f_neg + 1.0),
        weight(f_neg + 2.0),
        weight(f_neg + 3.0));

     
    float sum = tap012.x + tap012.y + tap012.z + tap345.x + tap345.y + tap345.z;
    float sum_i = 1.0 / sum;
    tap012 = tap012 * sum_i;
    tap345 = tap345 * sum_i;
}
info: fname:AspectUndistortX rtype:float mapping:(null) content:{
     
    return (1.0 - a) * (x * x * x * x * x) + a * x;
}
info: fname:AspectUndistortU rtype:float mapping:(null) content:{
     
    return AspectUndistortX((u - 0.5) * 2.0, undistort_factor) * 0.5 + 0.5;
}
info: fname:undistort_coord rtype:float2 mapping:(null) content:{
    return float2(AspectUndistortU(xpos), ypos);
}
info: fname:undistort_pixel rtype:float4 mapping:(null) content:{
    return image.Sample(textureSampler, undistort_coord(xpos, ypos));
}
info: fname:undistort_line rtype:float4 mapping:(null) content:{
    return
        undistort_pixel(xpos012.x, ypos) * rowtap012.x +
        undistort_pixel(xpos012.y, ypos) * rowtap012.y +
        undistort_pixel(xpos012.z, ypos) * rowtap012.z +
        undistort_pixel(xpos345.x, ypos) * rowtap345.x +
        undistort_pixel(xpos345.y, ypos) * rowtap345.y +
        undistort_pixel(xpos345.z, ypos) * rowtap345.z;
}
info: fname:DrawLanczos rtype:float4 mapping:(null) content:{
    float2 pos = f_in.uv;
    float2 pos2 = floor(pos - 0.5) + 0.5;
    float2 f_neg = pos2 - pos;

    float3 rowtap012, rowtap345;
    weight6(f_neg.x, rowtap012, rowtap345);

    float3 coltap012, coltap345;
    weight6(f_neg.y, coltap012, coltap345);

    float2 uv2 = pos2 * base_dimension_i;
    float2 uv1 = uv2 - base_dimension_i;
    float2 uv0 = uv1 - base_dimension_i;
    float2 uv3 = uv2 + base_dimension_i;
    float2 uv4 = uv3 + base_dimension_i;
    float2 uv5 = uv4 + base_dimension_i;

    if (undistort) {
        float3 xpos012 = float3(uv0.x, uv1.x, uv2.x);
        float3 xpos345 = float3(uv3.x, uv4.x, uv5.x);
        return undistort_line(xpos012, xpos345, uv0.y, rowtap012, rowtap345) * coltap012.x +
               undistort_line(xpos012, xpos345, uv1.y, rowtap012, rowtap345) * coltap012.y +
               undistort_line(xpos012, xpos345, uv2.y, rowtap012, rowtap345) * coltap012.z +
               undistort_line(xpos012, xpos345, uv3.y, rowtap012, rowtap345) * coltap345.x +
               undistort_line(xpos012, xpos345, uv4.y, rowtap012, rowtap345) * coltap345.y +
               undistort_line(xpos012, xpos345, uv5.y, rowtap012, rowtap345) * coltap345.z;
    }

    float u_weight_sum = rowtap012.z + rowtap345.x;
    float u_middle_offset = rowtap345.x * base_dimension_i.x / u_weight_sum;
    float u_middle = uv2.x + u_middle_offset;

    float v_weight_sum = coltap012.z + coltap345.x;
    float v_middle_offset = coltap345.x * base_dimension_i.y / v_weight_sum;
    float v_middle = uv2.y + v_middle_offset;

    float2 coord_limit = base_dimension - 0.5;
    float2 coord0_f = max(uv0 * base_dimension, 0.5);
    float2 coord1_f = max(uv1 * base_dimension, 0.5);
    float2 coord4_f = min(uv4 * base_dimension, coord_limit);
    float2 coord5_f = min(uv5 * base_dimension, coord_limit);

    int2 coord0 = int2(coord0_f);
    int2 coord1 = int2(coord1_f);
    int2 coord4 = int2(coord4_f);
    int2 coord5 = int2(coord5_f);

    float4 row0 = image.Load(int3(coord0, 0)) * rowtap012.x;
    row0 += image.Load(int3(coord1.x, coord0.y, 0)) * rowtap012.y;
    row0 += image.Sample(textureSampler, float2(u_middle, uv0.y)) * u_weight_sum;
    row0 += image.Load(int3(coord4.x, coord0.y, 0)) * rowtap345.y;
    row0 += image.Load(int3(coord5.x, coord0.y, 0)) * rowtap345.z;
    float4 total = row0 * coltap012.x;

    float4 row1 = image.Load(int3(coord0.x, coord1.y, 0)) * rowtap012.x;
    row1 += image.Load(int3(coord1.x, coord1.y, 0)) * rowtap012.y;
    row1 += image.Sample(textureSampler, float2(u_middle, uv1.y)) * u_weight_sum;
    row1 += image.Load(int3(coord4.x, coord1.y, 0)) * rowtap345.y;
    row1 += image.Load(int3(coord5.x, coord1.y, 0)) * rowtap345.z;
    total += row1 * coltap012.y;

    float4 row23 = image.Sample(textureSampler, float2(uv0.x, v_middle)) * rowtap012.x;
    row23 += image.Sample(textureSampler, float2(uv1.x, v_middle)) * rowtap012.y;
    row23 += image.Sample(textureSampler, float2(u_middle, v_middle)) * u_weight_sum;
    row23 += image.Sample(textureSampler, float2(uv4.x, v_middle)) * rowtap345.y;
    row23 += image.Sample(textureSampler, float2(uv5.x, v_middle)) * rowtap345.z;
    total += row23 * v_weight_sum;

    float4 row4 = image.Load(int3(coord0.x, coord4.y, 0)) * rowtap012.x;
    row4 += image.Load(int3(coord1.x, coord4.y, 0)) * rowtap012.y;
    row4 += image.Sample(textureSampler, float2(u_middle, uv4.y)) * u_weight_sum;
    row4 += image.Load(int3(coord4.x, coord4.y, 0)) * rowtap345.y;
    row4 += image.Load(int3(coord5.x, coord4.y, 0)) * rowtap345.z;
    total += row4 * coltap345.y;

    float4 row5 = image.Load(int3(coord0.x, coord5.y, 0)) * rowtap012.x;
    row5 += image.Load(int3(coord1.x, coord5.y, 0)) * rowtap012.y;
    row5 += image.Sample(textureSampler, float2(u_middle, uv5.y)) * u_weight_sum;
    row5 += image.Load(int3(coord4.x, coord5.y, 0)) * rowtap345.y;
    row5 += image.Load(int3(coord5, 0)) * rowtap345.z;
    total += row5 * coltap345.z;

    return total;
}
info: fname:PSDrawLanczosRGBA rtype:float4 mapping:TARGET content:{
    return DrawLanczos(f_in, undistort);
}
info: fname:PSDrawLanczosRGBAMultiply rtype:float4 mapping:TARGET content:{
    float4 rgba = DrawLanczos(f_in, undistort);
    rgba.rgb *= multiplier;
    return rgba;
}
info: fname:PSDrawLanczosRGBATonemap rtype:float4 mapping:TARGET content:{
    float4 rgba = DrawLanczos(f_in, undistort);
    rgba.rgb = rec709_to_rec2020(rgba.rgb);
    rgba.rgb = reinhard(rgba.rgb);
    rgba.rgb = rec2020_to_rec709(rgba.rgb);
    return rgba;
}
info: fname:PSDrawLanczosRGBAMultiplyTonemap rtype:float4 mapping:TARGET content:{
    float4 rgba = DrawLanczos(f_in, undistort);
    rgba.rgb *= multiplier;
    rgba.rgb = rec709_to_rec2020(rgba.rgb);
    rgba.rgb = reinhard(rgba.rgb);
    rgba.rgb = rec2020_to_rec709(rgba.rgb);
    return rgba;
}
info: fname:PSDrawLanczosRGBADivide rtype:float4 mapping:TARGET content:{
    float4 rgba = DrawLanczos(f_in, false);
    rgba.rgb *= max(1. / rgba.a, 0.);
    return rgba;
}
info: ======params =======
info: fname:ViewProj type:float4x4
info: fname:image type:texture2d
info: fname:base_dimension type:float2
info: fname:base_dimension_i type:float2
info: fname:undistort_factor type:float
info: fname:multiplier type:float
info: ======structs =======
info: fname:VertData
info: fname:VertOut
info: fname:FragData
info: ======samplers =======
info: fname:textureSampler
info: ======techniques =======
info: fname:Draw
info: fname:DrawMultiply
info: fname:DrawTonemap
info: fname:DrawMultiplyTonemap
info: fname:DrawAlphaDivide
info: fname:DrawUndistort
info: fname:DrawUndistortMultiply
info: fname:DrawUndistortTonemap
info: fname:DrawUndistortMultiplyTonemap
info: ======files =======
info: ======tokens =======
info: ======techniques =======
info: tname:Draw
info: tname:(null)
info: tname:DrawMultiply
info: tname:(null)
info: tname:DrawTonemap
info: tname:(null)
info: tname:DrawMultiplyTonemap
info: tname:(null)
info: tname:DrawAlphaDivide
info: tname:(null)
info: tname:DrawUndistort
info: tname:(null)
info: tname:DrawUndistortMultiply
info: tname:(null)
info: tname:DrawUndistortTonemap
info: tname:(null)
info: tname:DrawUndistortMultiplyTonemap
info: tname:(null)
info: ======params =======
info: tname:ViewProj
info: tname:image
info: tname:base_dimension
info: tname:base_dimension_i
info: tname:undistort_factor
info: tname:multiplier
info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform mat4x4 ViewProj;

in vec4 _input_attrib0;
in vec2 _input_attrib1;

out vec2 _vertex_shader_attrib0;

out gl_PerVertex {
    vec4 gl_Position;
};

struct VertInOut {
    vec2 uv;
    vec4 pos;
};

struct VertData {
    vec4 pos;
    vec2 uv;
};

VertInOut VSDefault(VertData vert_in)
{
    VertInOut vert_out;
    vert_out.pos = ((vec4(vert_in.pos.xyz, 1.0)) * (ViewProj));
    vert_out.uv  = vert_in.uv;
    return vert_out;
}

VertInOut _main_wrap(VertData vert_in)
{
    return VSDefault(vert_in);
}

void main(void)
{
    VertData vert_in;
    VertInOut outputval;

    vert_in.pos = _input_attrib0;
    vert_in.uv = _input_attrib1;

    outputval = _main_wrap(vert_in);

    _vertex_shader_attrib0 = outputval.uv;
    gl_Position = outputval.pos;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform vec2 base_dimension;
uniform vec2 base_dimension_i;
uniform sampler2D image;

in vec2 _vertex_shader_attrib0;

out vec4 _pixel_shader_attrib0;

struct FragData {
    vec2 uv;
};

vec4 DrawArea(FragData frag_in)
{
    vec2 uv = frag_in.uv;
    vec2 uv_delta = vec2(dFdx(uv.x), dFdy(uv.y));

     
    if (obs_glsl_compile)
        uv_delta.y = abs(uv_delta.y);

    vec2 uv_min = uv - 0.5 * uv_delta;
    vec2 uv_max = uv_min + uv_delta;

    vec2 load_index_begin = floor(uv_min * base_dimension);
    vec2 load_index_end = ceil(uv_max * base_dimension);

    vec2 target_dimension = 1.0 / uv_delta;
    vec2 target_pos = uv * target_dimension;
    vec2 target_pos_min = target_pos - 0.5;
    vec2 target_pos_max = target_pos + 0.5;
    vec2 scale = base_dimension_i * target_dimension;

    vec4 total_color = vec4(0.0, 0.0, 0.0, 0.0);

    float load_index_y = load_index_begin.y;
    do {
        float source_y_min = load_index_y * scale.y;
        float source_y_max = source_y_min + scale.y;
        float y_min = max(source_y_min, target_pos_min.y);
        float y_max = min(source_y_max, target_pos_max.y);
        float height = y_max - y_min;

        float load_index_x = load_index_begin.x;
        do {
            float source_x_min = load_index_x * scale.x;
            float source_x_max = source_x_min + scale.x;
            float x_min = max(source_x_min, target_pos_min.x);
            float x_max = min(source_x_max, target_pos_max.x);
            float width = x_max - x_min;
            float area = width * height;

            vec4 color = obs_load_2d(image, ivec3(load_index_x, load_index_y, 0));
            total_color += area * color;

            ++load_index_x;
        } while (load_index_x < load_index_end.x);

        ++load_index_y;
    } while (load_index_y < load_index_end.y);

    return total_color;
}

vec4 PSDrawAreaRGBA(FragData frag_in)
{
    return DrawArea(frag_in);
}

vec4 _main_wrap(FragData frag_in)
{
    return PSDrawAreaRGBA(frag_in);
}

void main(void)
{
    FragData frag_in;
    frag_in.uv = _vertex_shader_attrib0;

    _pixel_shader_attrib0 = _main_wrap(frag_in);
}

info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform mat4x4 ViewProj;

in vec4 _input_attrib0;
in vec2 _input_attrib1;

out vec2 _vertex_shader_attrib0;

out gl_PerVertex {
    vec4 gl_Position;
};

struct VertInOut {
    vec2 uv;
    vec4 pos;
};

struct VertData {
    vec4 pos;
    vec2 uv;
};

VertInOut VSDefault(VertData vert_in)
{
    VertInOut vert_out;
    vert_out.pos = ((vec4(vert_in.pos.xyz, 1.0)) * (ViewProj));
    vert_out.uv  = vert_in.uv;
    return vert_out;
}

VertInOut _main_wrap(VertData vert_in)
{
    return VSDefault(vert_in);
}

void main(void)
{
    VertData vert_in;
    VertInOut outputval;

    vert_in.pos = _input_attrib0;
    vert_in.uv = _input_attrib1;

    outputval = _main_wrap(vert_in);

    _vertex_shader_attrib0 = outputval.uv;
    gl_Position = outputval.pos;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform float multiplier;
uniform vec2 base_dimension;
uniform vec2 base_dimension_i;
uniform sampler2D image;

in vec2 _vertex_shader_attrib0;

out vec4 _pixel_shader_attrib0;

struct FragData {
    vec2 uv;
};

vec4 DrawArea(FragData frag_in)
{
    vec2 uv = frag_in.uv;
    vec2 uv_delta = vec2(dFdx(uv.x), dFdy(uv.y));

     
    if (obs_glsl_compile)
        uv_delta.y = abs(uv_delta.y);

    vec2 uv_min = uv - 0.5 * uv_delta;
    vec2 uv_max = uv_min + uv_delta;

    vec2 load_index_begin = floor(uv_min * base_dimension);
    vec2 load_index_end = ceil(uv_max * base_dimension);

    vec2 target_dimension = 1.0 / uv_delta;
    vec2 target_pos = uv * target_dimension;
    vec2 target_pos_min = target_pos - 0.5;
    vec2 target_pos_max = target_pos + 0.5;
    vec2 scale = base_dimension_i * target_dimension;

    vec4 total_color = vec4(0.0, 0.0, 0.0, 0.0);

    float load_index_y = load_index_begin.y;
    do {
        float source_y_min = load_index_y * scale.y;
        float source_y_max = source_y_min + scale.y;
        float y_min = max(source_y_min, target_pos_min.y);
        float y_max = min(source_y_max, target_pos_max.y);
        float height = y_max - y_min;

        float load_index_x = load_index_begin.x;
        do {
            float source_x_min = load_index_x * scale.x;
            float source_x_max = source_x_min + scale.x;
            float x_min = max(source_x_min, target_pos_min.x);
            float x_max = min(source_x_max, target_pos_max.x);
            float width = x_max - x_min;
            float area = width * height;

            vec4 color = obs_load_2d(image, ivec3(load_index_x, load_index_y, 0));
            total_color += area * color;

            ++load_index_x;
        } while (load_index_x < load_index_end.x);

        ++load_index_y;
    } while (load_index_y < load_index_end.y);

    return total_color;
}

vec4 PSDrawAreaRGBAMultiply(FragData frag_in)
{
    vec4 rgba = DrawArea(frag_in);
    rgba.rgb *= multiplier;
    return rgba;
}

vec4 _main_wrap(FragData frag_in)
{
    return PSDrawAreaRGBAMultiply(frag_in);
}

void main(void)
{
    FragData frag_in;
    frag_in.uv = _vertex_shader_attrib0;

    _pixel_shader_attrib0 = _main_wrap(frag_in);
}

info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform mat4x4 ViewProj;

in vec4 _input_attrib0;
in vec2 _input_attrib1;

out vec2 _vertex_shader_attrib0;

out gl_PerVertex {
    vec4 gl_Position;
};

struct VertInOut {
    vec2 uv;
    vec4 pos;
};

struct VertData {
    vec4 pos;
    vec2 uv;
};

VertInOut VSDefault(VertData vert_in)
{
    VertInOut vert_out;
    vert_out.pos = ((vec4(vert_in.pos.xyz, 1.0)) * (ViewProj));
    vert_out.uv  = vert_in.uv;
    return vert_out;
}

VertInOut _main_wrap(VertData vert_in)
{
    return VSDefault(vert_in);
}

void main(void)
{
    VertData vert_in;
    VertInOut outputval;

    vert_in.pos = _input_attrib0;
    vert_in.uv = _input_attrib1;

    outputval = _main_wrap(vert_in);

    _vertex_shader_attrib0 = outputval.uv;
    gl_Position = outputval.pos;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform vec2 base_dimension;
uniform vec2 base_dimension_i;
uniform sampler2D image;

in vec2 _vertex_shader_attrib0;

out vec4 _pixel_shader_attrib0;

struct FragData {
    vec2 uv;
};

vec4 DrawArea(FragData frag_in)
{
    vec2 uv = frag_in.uv;
    vec2 uv_delta = vec2(dFdx(uv.x), dFdy(uv.y));

     
    if (obs_glsl_compile)
        uv_delta.y = abs(uv_delta.y);

    vec2 uv_min = uv - 0.5 * uv_delta;
    vec2 uv_max = uv_min + uv_delta;

    vec2 load_index_begin = floor(uv_min * base_dimension);
    vec2 load_index_end = ceil(uv_max * base_dimension);

    vec2 target_dimension = 1.0 / uv_delta;
    vec2 target_pos = uv * target_dimension;
    vec2 target_pos_min = target_pos - 0.5;
    vec2 target_pos_max = target_pos + 0.5;
    vec2 scale = base_dimension_i * target_dimension;

    vec4 total_color = vec4(0.0, 0.0, 0.0, 0.0);

    float load_index_y = load_index_begin.y;
    do {
        float source_y_min = load_index_y * scale.y;
        float source_y_max = source_y_min + scale.y;
        float y_min = max(source_y_min, target_pos_min.y);
        float y_max = min(source_y_max, target_pos_max.y);
        float height = y_max - y_min;

        float load_index_x = load_index_begin.x;
        do {
            float source_x_min = load_index_x * scale.x;
            float source_x_max = source_x_min + scale.x;
            float x_min = max(source_x_min, target_pos_min.x);
            float x_max = min(source_x_max, target_pos_max.x);
            float width = x_max - x_min;
            float area = width * height;

            vec4 color = obs_load_2d(image, ivec3(load_index_x, load_index_y, 0));
            total_color += area * color;

            ++load_index_x;
        } while (load_index_x < load_index_end.x);

        ++load_index_y;
    } while (load_index_y < load_index_end.y);

    return total_color;
}

vec3 rec709_to_rec2020(vec3 v)
{
    float r = dot(v, vec3(0.62740389593469903, 0.32928303837788370, 0.043313065687417225));
    float g = dot(v, vec3(0.069097289358232075, 0.91954039507545871, 0.011362315566309178));
    float b = dot(v, vec3(0.016391438875150280, 0.088013307877225749, 0.89559525324762401));
    return vec3(r, g, b);
}

float srgb_nonlinear_to_linear_channel(float u)
{
    return (u <= 0.04045) ? (u / 12.92) : pow((u + 0.055) / 1.055, 2.4);
}

vec3 srgb_nonlinear_to_linear(vec3 v)
{
    return vec3(srgb_nonlinear_to_linear_channel(v.r), srgb_nonlinear_to_linear_channel(v.g), srgb_nonlinear_to_linear_channel(v.b));
}

vec3 reinhard(vec3 rgb)
{
    rgb /= rgb + vec3(1., 1., 1.);
    rgb = pow(rgb, vec3(1. / 2.4, 1. / 2.4, 1. / 2.4));
    rgb = srgb_nonlinear_to_linear(rgb);
    return rgb;
}

vec3 rec2020_to_rec709(vec3 v)
{
    float r = dot(v, vec3(1.6604910021084345, -0.58764113878854951, -0.072849863319884883));
    float g = dot(v, vec3(-0.12455047452159074, 1.1328998971259603, -0.0083494226043694768));
    float b = dot(v, vec3(-0.018150763354905303, -0.10057889800800739, 1.1187296613629127));
    return vec3(r, g, b);
}

vec4 PSDrawAreaRGBATonemap(FragData frag_in)
{
    vec4 rgba = DrawArea(frag_in);
    rgba.rgb = rec709_to_rec2020(rgba.rgb);
    rgba.rgb = reinhard(rgba.rgb);
    rgba.rgb = rec2020_to_rec709(rgba.rgb);
    return rgba;
}

vec4 _main_wrap(FragData frag_in)
{
    return PSDrawAreaRGBATonemap(frag_in);
}

void main(void)
{
    FragData frag_in;
    frag_in.uv = _vertex_shader_attrib0;

    _pixel_shader_attrib0 = _main_wrap(frag_in);
}

info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform mat4x4 ViewProj;

in vec4 _input_attrib0;
in vec2 _input_attrib1;

out vec2 _vertex_shader_attrib0;

out gl_PerVertex {
    vec4 gl_Position;
};

struct VertInOut {
    vec2 uv;
    vec4 pos;
};

struct VertData {
    vec4 pos;
    vec2 uv;
};

VertInOut VSDefault(VertData vert_in)
{
    VertInOut vert_out;
    vert_out.pos = ((vec4(vert_in.pos.xyz, 1.0)) * (ViewProj));
    vert_out.uv  = vert_in.uv;
    return vert_out;
}

VertInOut _main_wrap(VertData vert_in)
{
    return VSDefault(vert_in);
}

void main(void)
{
    VertData vert_in;
    VertInOut outputval;

    vert_in.pos = _input_attrib0;
    vert_in.uv = _input_attrib1;

    outputval = _main_wrap(vert_in);

    _vertex_shader_attrib0 = outputval.uv;
    gl_Position = outputval.pos;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform float multiplier;
uniform vec2 base_dimension;
uniform vec2 base_dimension_i;
uniform sampler2D image;

in vec2 _vertex_shader_attrib0;

out vec4 _pixel_shader_attrib0;

struct FragData {
    vec2 uv;
};

vec4 DrawArea(FragData frag_in)
{
    vec2 uv = frag_in.uv;
    vec2 uv_delta = vec2(dFdx(uv.x), dFdy(uv.y));

     
    if (obs_glsl_compile)
        uv_delta.y = abs(uv_delta.y);

    vec2 uv_min = uv - 0.5 * uv_delta;
    vec2 uv_max = uv_min + uv_delta;

    vec2 load_index_begin = floor(uv_min * base_dimension);
    vec2 load_index_end = ceil(uv_max * base_dimension);

    vec2 target_dimension = 1.0 / uv_delta;
    vec2 target_pos = uv * target_dimension;
    vec2 target_pos_min = target_pos - 0.5;
    vec2 target_pos_max = target_pos + 0.5;
    vec2 scale = base_dimension_i * target_dimension;

    vec4 total_color = vec4(0.0, 0.0, 0.0, 0.0);

    float load_index_y = load_index_begin.y;
    do {
        float source_y_min = load_index_y * scale.y;
        float source_y_max = source_y_min + scale.y;
        float y_min = max(source_y_min, target_pos_min.y);
        float y_max = min(source_y_max, target_pos_max.y);
        float height = y_max - y_min;

        float load_index_x = load_index_begin.x;
        do {
            float source_x_min = load_index_x * scale.x;
            float source_x_max = source_x_min + scale.x;
            float x_min = max(source_x_min, target_pos_min.x);
            float x_max = min(source_x_max, target_pos_max.x);
            float width = x_max - x_min;
            float area = width * height;

            vec4 color = obs_load_2d(image, ivec3(load_index_x, load_index_y, 0));
            total_color += area * color;

            ++load_index_x;
        } while (load_index_x < load_index_end.x);

        ++load_index_y;
    } while (load_index_y < load_index_end.y);

    return total_color;
}

vec3 rec709_to_rec2020(vec3 v)
{
    float r = dot(v, vec3(0.62740389593469903, 0.32928303837788370, 0.043313065687417225));
    float g = dot(v, vec3(0.069097289358232075, 0.91954039507545871, 0.011362315566309178));
    float b = dot(v, vec3(0.016391438875150280, 0.088013307877225749, 0.89559525324762401));
    return vec3(r, g, b);
}

float srgb_nonlinear_to_linear_channel(float u)
{
    return (u <= 0.04045) ? (u / 12.92) : pow((u + 0.055) / 1.055, 2.4);
}

vec3 srgb_nonlinear_to_linear(vec3 v)
{
    return vec3(srgb_nonlinear_to_linear_channel(v.r), srgb_nonlinear_to_linear_channel(v.g), srgb_nonlinear_to_linear_channel(v.b));
}

vec3 reinhard(vec3 rgb)
{
    rgb /= rgb + vec3(1., 1., 1.);
    rgb = pow(rgb, vec3(1. / 2.4, 1. / 2.4, 1. / 2.4));
    rgb = srgb_nonlinear_to_linear(rgb);
    return rgb;
}

vec3 rec2020_to_rec709(vec3 v)
{
    float r = dot(v, vec3(1.6604910021084345, -0.58764113878854951, -0.072849863319884883));
    float g = dot(v, vec3(-0.12455047452159074, 1.1328998971259603, -0.0083494226043694768));
    float b = dot(v, vec3(-0.018150763354905303, -0.10057889800800739, 1.1187296613629127));
    return vec3(r, g, b);
}

vec4 PSDrawAreaRGBAMultiplyTonemap(FragData frag_in)
{
    vec4 rgba = DrawArea(frag_in);
    rgba.rgb *= multiplier;
    rgba.rgb = rec709_to_rec2020(rgba.rgb);
    rgba.rgb = reinhard(rgba.rgb);
    rgba.rgb = rec2020_to_rec709(rgba.rgb);
    return rgba;
}

vec4 _main_wrap(FragData frag_in)
{
    return PSDrawAreaRGBAMultiplyTonemap(frag_in);
}

void main(void)
{
    FragData frag_in;
    frag_in.uv = _vertex_shader_attrib0;

    _pixel_shader_attrib0 = _main_wrap(frag_in);
}

info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform mat4x4 ViewProj;

in vec4 _input_attrib0;
in vec2 _input_attrib1;

out vec2 _vertex_shader_attrib0;

out gl_PerVertex {
    vec4 gl_Position;
};

struct VertInOut {
    vec2 uv;
    vec4 pos;
};

struct VertData {
    vec4 pos;
    vec2 uv;
};

VertInOut VSDefault(VertData vert_in)
{
    VertInOut vert_out;
    vert_out.pos = ((vec4(vert_in.pos.xyz, 1.0)) * (ViewProj));
    vert_out.uv  = vert_in.uv;
    return vert_out;
}

VertInOut _main_wrap(VertData vert_in)
{
    return VSDefault(vert_in);
}

void main(void)
{
    VertData vert_in;
    VertInOut outputval;

    vert_in.pos = _input_attrib0;
    vert_in.uv = _input_attrib1;

    outputval = _main_wrap(vert_in);

    _vertex_shader_attrib0 = outputval.uv;
    gl_Position = outputval.pos;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform vec2 base_dimension;
uniform vec2 base_dimension_i;
uniform sampler2D image;

in vec2 _vertex_shader_attrib0;

out vec4 _pixel_shader_attrib0;

struct FragData {
    vec2 uv;
};

vec4 DrawArea(FragData frag_in)
{
    vec2 uv = frag_in.uv;
    vec2 uv_delta = vec2(dFdx(uv.x), dFdy(uv.y));

     
    if (obs_glsl_compile)
        uv_delta.y = abs(uv_delta.y);

    vec2 uv_min = uv - 0.5 * uv_delta;
    vec2 uv_max = uv_min + uv_delta;

    vec2 load_index_begin = floor(uv_min * base_dimension);
    vec2 load_index_end = ceil(uv_max * base_dimension);

    vec2 target_dimension = 1.0 / uv_delta;
    vec2 target_pos = uv * target_dimension;
    vec2 target_pos_min = target_pos - 0.5;
    vec2 target_pos_max = target_pos + 0.5;
    vec2 scale = base_dimension_i * target_dimension;

    vec4 total_color = vec4(0.0, 0.0, 0.0, 0.0);

    float load_index_y = load_index_begin.y;
    do {
        float source_y_min = load_index_y * scale.y;
        float source_y_max = source_y_min + scale.y;
        float y_min = max(source_y_min, target_pos_min.y);
        float y_max = min(source_y_max, target_pos_max.y);
        float height = y_max - y_min;

        float load_index_x = load_index_begin.x;
        do {
            float source_x_min = load_index_x * scale.x;
            float source_x_max = source_x_min + scale.x;
            float x_min = max(source_x_min, target_pos_min.x);
            float x_max = min(source_x_max, target_pos_max.x);
            float width = x_max - x_min;
            float area = width * height;

            vec4 color = obs_load_2d(image, ivec3(load_index_x, load_index_y, 0));
            total_color += area * color;

            ++load_index_x;
        } while (load_index_x < load_index_end.x);

        ++load_index_y;
    } while (load_index_y < load_index_end.y);

    return total_color;
}

vec4 PSDrawAreaRGBADivide(FragData frag_in)
{
    vec4 rgba = DrawArea(frag_in);
    rgba.rgb *= max(1. / rgba.a, 0.);
    return rgba;
}

vec4 _main_wrap(FragData frag_in)
{
    return PSDrawAreaRGBADivide(frag_in);
}

void main(void)
{
    FragData frag_in;
    frag_in.uv = _vertex_shader_attrib0;

    _pixel_shader_attrib0 = _main_wrap(frag_in);
}

info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform mat4x4 ViewProj;

in vec4 _input_attrib0;
in vec2 _input_attrib1;

out vec2 _vertex_shader_attrib0;

out gl_PerVertex {
    vec4 gl_Position;
};

struct VertInOut {
    vec2 uv;
    vec4 pos;
};

struct VertData {
    vec4 pos;
    vec2 uv;
};

VertInOut VSDefault(VertData vert_in)
{
    VertInOut vert_out;
    vert_out.pos = ((vec4(vert_in.pos.xyz, 1.0)) * (ViewProj));
    vert_out.uv  = vert_in.uv;
    return vert_out;
}

VertInOut _main_wrap(VertData vert_in)
{
    return VSDefault(vert_in);
}

void main(void)
{
    VertData vert_in;
    VertInOut outputval;

    vert_in.pos = _input_attrib0;
    vert_in.uv = _input_attrib1;

    outputval = _main_wrap(vert_in);

    _vertex_shader_attrib0 = outputval.uv;
    gl_Position = outputval.pos;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform vec2 base_dimension;
uniform vec2 base_dimension_i;
uniform sampler2D image;

in vec2 _vertex_shader_attrib0;

out vec4 _pixel_shader_attrib0;

struct FragData {
    vec2 uv;
};

vec4 DrawAreaUpscale(FragData frag_in)
{
    vec2 uv = frag_in.uv;
    vec2 uv_delta = vec2(dFdx(uv.x), dFdy(uv.y));

     
    if (obs_glsl_compile)
        uv_delta.y = abs(uv_delta.y);

    vec2 uv_min = uv - 0.5 * uv_delta;
    vec2 uv_max = uv_min + uv_delta;

    vec2 load_index_first = floor(uv_min * base_dimension);
    vec2 load_index_last = ceil(uv_max * base_dimension) - 1.0;

    if (load_index_first.x < load_index_last.x) {
        float uv_boundary_x = load_index_last.x * base_dimension_i.x;
        uv.x = ((uv.x - uv_boundary_x) / uv_delta.x) * base_dimension_i.x + uv_boundary_x;
    } else
        uv.x = (load_index_first.x + 0.5) * base_dimension_i.x;
    if (load_index_first.y < load_index_last.y) {
        float uv_boundary_y = load_index_last.y * base_dimension_i.y;
        uv.y = ((uv.y - uv_boundary_y) / uv_delta.y) * base_dimension_i.y + uv_boundary_y;
    } else
        uv.y = (load_index_first.y + 0.5) * base_dimension_i.y;

    return texture(image, uv);
}

vec4 PSDrawAreaRGBAUpscale(FragData frag_in)
{
    return DrawAreaUpscale(frag_in);
}

vec4 _main_wrap(FragData frag_in)
{
    return PSDrawAreaRGBAUpscale(frag_in);
}

void main(void)
{
    FragData frag_in;
    frag_in.uv = _vertex_shader_attrib0;

    _pixel_shader_attrib0 = _main_wrap(frag_in);
}

info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform mat4x4 ViewProj;

in vec4 _input_attrib0;
in vec2 _input_attrib1;

out vec2 _vertex_shader_attrib0;

out gl_PerVertex {
    vec4 gl_Position;
};

struct VertInOut {
    vec2 uv;
    vec4 pos;
};

struct VertData {
    vec4 pos;
    vec2 uv;
};

VertInOut VSDefault(VertData vert_in)
{
    VertInOut vert_out;
    vert_out.pos = ((vec4(vert_in.pos.xyz, 1.0)) * (ViewProj));
    vert_out.uv  = vert_in.uv;
    return vert_out;
}

VertInOut _main_wrap(VertData vert_in)
{
    return VSDefault(vert_in);
}

void main(void)
{
    VertData vert_in;
    VertInOut outputval;

    vert_in.pos = _input_attrib0;
    vert_in.uv = _input_attrib1;

    outputval = _main_wrap(vert_in);

    _vertex_shader_attrib0 = outputval.uv;
    gl_Position = outputval.pos;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform float multiplier;
uniform vec2 base_dimension;
uniform vec2 base_dimension_i;
uniform sampler2D image;

in vec2 _vertex_shader_attrib0;

out vec4 _pixel_shader_attrib0;

struct FragData {
    vec2 uv;
};

vec4 DrawAreaUpscale(FragData frag_in)
{
    vec2 uv = frag_in.uv;
    vec2 uv_delta = vec2(dFdx(uv.x), dFdy(uv.y));

     
    if (obs_glsl_compile)
        uv_delta.y = abs(uv_delta.y);

    vec2 uv_min = uv - 0.5 * uv_delta;
    vec2 uv_max = uv_min + uv_delta;

    vec2 load_index_first = floor(uv_min * base_dimension);
    vec2 load_index_last = ceil(uv_max * base_dimension) - 1.0;

    if (load_index_first.x < load_index_last.x) {
        float uv_boundary_x = load_index_last.x * base_dimension_i.x;
        uv.x = ((uv.x - uv_boundary_x) / uv_delta.x) * base_dimension_i.x + uv_boundary_x;
    } else
        uv.x = (load_index_first.x + 0.5) * base_dimension_i.x;
    if (load_index_first.y < load_index_last.y) {
        float uv_boundary_y = load_index_last.y * base_dimension_i.y;
        uv.y = ((uv.y - uv_boundary_y) / uv_delta.y) * base_dimension_i.y + uv_boundary_y;
    } else
        uv.y = (load_index_first.y + 0.5) * base_dimension_i.y;

    return texture(image, uv);
}

vec4 PSDrawAreaRGBAUpscaleMultiply(FragData frag_in)
{
    vec4 rgba = DrawAreaUpscale(frag_in);
    rgba.rgb *= multiplier;
    return rgba;
}

vec4 _main_wrap(FragData frag_in)
{
    return PSDrawAreaRGBAUpscaleMultiply(frag_in);
}

void main(void)
{
    FragData frag_in;
    frag_in.uv = _vertex_shader_attrib0;

    _pixel_shader_attrib0 = _main_wrap(frag_in);
}

info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform mat4x4 ViewProj;

in vec4 _input_attrib0;
in vec2 _input_attrib1;

out vec2 _vertex_shader_attrib0;

out gl_PerVertex {
    vec4 gl_Position;
};

struct VertInOut {
    vec2 uv;
    vec4 pos;
};

struct VertData {
    vec4 pos;
    vec2 uv;
};

VertInOut VSDefault(VertData vert_in)
{
    VertInOut vert_out;
    vert_out.pos = ((vec4(vert_in.pos.xyz, 1.0)) * (ViewProj));
    vert_out.uv  = vert_in.uv;
    return vert_out;
}

VertInOut _main_wrap(VertData vert_in)
{
    return VSDefault(vert_in);
}

void main(void)
{
    VertData vert_in;
    VertInOut outputval;

    vert_in.pos = _input_attrib0;
    vert_in.uv = _input_attrib1;

    outputval = _main_wrap(vert_in);

    _vertex_shader_attrib0 = outputval.uv;
    gl_Position = outputval.pos;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform vec2 base_dimension;
uniform vec2 base_dimension_i;
uniform sampler2D image;

in vec2 _vertex_shader_attrib0;

out vec4 _pixel_shader_attrib0;

struct FragData {
    vec2 uv;
};

vec4 DrawAreaUpscale(FragData frag_in)
{
    vec2 uv = frag_in.uv;
    vec2 uv_delta = vec2(dFdx(uv.x), dFdy(uv.y));

     
    if (obs_glsl_compile)
        uv_delta.y = abs(uv_delta.y);

    vec2 uv_min = uv - 0.5 * uv_delta;
    vec2 uv_max = uv_min + uv_delta;

    vec2 load_index_first = floor(uv_min * base_dimension);
    vec2 load_index_last = ceil(uv_max * base_dimension) - 1.0;

    if (load_index_first.x < load_index_last.x) {
        float uv_boundary_x = load_index_last.x * base_dimension_i.x;
        uv.x = ((uv.x - uv_boundary_x) / uv_delta.x) * base_dimension_i.x + uv_boundary_x;
    } else
        uv.x = (load_index_first.x + 0.5) * base_dimension_i.x;
    if (load_index_first.y < load_index_last.y) {
        float uv_boundary_y = load_index_last.y * base_dimension_i.y;
        uv.y = ((uv.y - uv_boundary_y) / uv_delta.y) * base_dimension_i.y + uv_boundary_y;
    } else
        uv.y = (load_index_first.y + 0.5) * base_dimension_i.y;

    return texture(image, uv);
}

vec3 rec709_to_rec2020(vec3 v)
{
    float r = dot(v, vec3(0.62740389593469903, 0.32928303837788370, 0.043313065687417225));
    float g = dot(v, vec3(0.069097289358232075, 0.91954039507545871, 0.011362315566309178));
    float b = dot(v, vec3(0.016391438875150280, 0.088013307877225749, 0.89559525324762401));
    return vec3(r, g, b);
}

float srgb_nonlinear_to_linear_channel(float u)
{
    return (u <= 0.04045) ? (u / 12.92) : pow((u + 0.055) / 1.055, 2.4);
}

vec3 srgb_nonlinear_to_linear(vec3 v)
{
    return vec3(srgb_nonlinear_to_linear_channel(v.r), srgb_nonlinear_to_linear_channel(v.g), srgb_nonlinear_to_linear_channel(v.b));
}

vec3 reinhard(vec3 rgb)
{
    rgb /= rgb + vec3(1., 1., 1.);
    rgb = pow(rgb, vec3(1. / 2.4, 1. / 2.4, 1. / 2.4));
    rgb = srgb_nonlinear_to_linear(rgb);
    return rgb;
}

vec3 rec2020_to_rec709(vec3 v)
{
    float r = dot(v, vec3(1.6604910021084345, -0.58764113878854951, -0.072849863319884883));
    float g = dot(v, vec3(-0.12455047452159074, 1.1328998971259603, -0.0083494226043694768));
    float b = dot(v, vec3(-0.018150763354905303, -0.10057889800800739, 1.1187296613629127));
    return vec3(r, g, b);
}

vec4 PSDrawAreaRGBAUpscaleTonemap(FragData frag_in)
{
    vec4 rgba = DrawAreaUpscale(frag_in);
    rgba.rgb = rec709_to_rec2020(rgba.rgb);
    rgba.rgb = reinhard(rgba.rgb);
    rgba.rgb = rec2020_to_rec709(rgba.rgb);
    return rgba;
}

vec4 _main_wrap(FragData frag_in)
{
    return PSDrawAreaRGBAUpscaleTonemap(frag_in);
}

void main(void)
{
    FragData frag_in;
    frag_in.uv = _vertex_shader_attrib0;

    _pixel_shader_attrib0 = _main_wrap(frag_in);
}

info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform mat4x4 ViewProj;

in vec4 _input_attrib0;
in vec2 _input_attrib1;

out vec2 _vertex_shader_attrib0;

out gl_PerVertex {
    vec4 gl_Position;
};

struct VertInOut {
    vec2 uv;
    vec4 pos;
};

struct VertData {
    vec4 pos;
    vec2 uv;
};

VertInOut VSDefault(VertData vert_in)
{
    VertInOut vert_out;
    vert_out.pos = ((vec4(vert_in.pos.xyz, 1.0)) * (ViewProj));
    vert_out.uv  = vert_in.uv;
    return vert_out;
}

VertInOut _main_wrap(VertData vert_in)
{
    return VSDefault(vert_in);
}

void main(void)
{
    VertData vert_in;
    VertInOut outputval;

    vert_in.pos = _input_attrib0;
    vert_in.uv = _input_attrib1;

    outputval = _main_wrap(vert_in);

    _vertex_shader_attrib0 = outputval.uv;
    gl_Position = outputval.pos;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform float multiplier;
uniform vec2 base_dimension;
uniform vec2 base_dimension_i;
uniform sampler2D image;

in vec2 _vertex_shader_attrib0;

out vec4 _pixel_shader_attrib0;

struct FragData {
    vec2 uv;
};

vec4 DrawAreaUpscale(FragData frag_in)
{
    vec2 uv = frag_in.uv;
    vec2 uv_delta = vec2(dFdx(uv.x), dFdy(uv.y));

     
    if (obs_glsl_compile)
        uv_delta.y = abs(uv_delta.y);

    vec2 uv_min = uv - 0.5 * uv_delta;
    vec2 uv_max = uv_min + uv_delta;

    vec2 load_index_first = floor(uv_min * base_dimension);
    vec2 load_index_last = ceil(uv_max * base_dimension) - 1.0;

    if (load_index_first.x < load_index_last.x) {
        float uv_boundary_x = load_index_last.x * base_dimension_i.x;
        uv.x = ((uv.x - uv_boundary_x) / uv_delta.x) * base_dimension_i.x + uv_boundary_x;
    } else
        uv.x = (load_index_first.x + 0.5) * base_dimension_i.x;
    if (load_index_first.y < load_index_last.y) {
        float uv_boundary_y = load_index_last.y * base_dimension_i.y;
        uv.y = ((uv.y - uv_boundary_y) / uv_delta.y) * base_dimension_i.y + uv_boundary_y;
    } else
        uv.y = (load_index_first.y + 0.5) * base_dimension_i.y;

    return texture(image, uv);
}

vec3 rec709_to_rec2020(vec3 v)
{
    float r = dot(v, vec3(0.62740389593469903, 0.32928303837788370, 0.043313065687417225));
    float g = dot(v, vec3(0.069097289358232075, 0.91954039507545871, 0.011362315566309178));
    float b = dot(v, vec3(0.016391438875150280, 0.088013307877225749, 0.89559525324762401));
    return vec3(r, g, b);
}

float srgb_nonlinear_to_linear_channel(float u)
{
    return (u <= 0.04045) ? (u / 12.92) : pow((u + 0.055) / 1.055, 2.4);
}

vec3 srgb_nonlinear_to_linear(vec3 v)
{
    return vec3(srgb_nonlinear_to_linear_channel(v.r), srgb_nonlinear_to_linear_channel(v.g), srgb_nonlinear_to_linear_channel(v.b));
}

vec3 reinhard(vec3 rgb)
{
    rgb /= rgb + vec3(1., 1., 1.);
    rgb = pow(rgb, vec3(1. / 2.4, 1. / 2.4, 1. / 2.4));
    rgb = srgb_nonlinear_to_linear(rgb);
    return rgb;
}

vec3 rec2020_to_rec709(vec3 v)
{
    float r = dot(v, vec3(1.6604910021084345, -0.58764113878854951, -0.072849863319884883));
    float g = dot(v, vec3(-0.12455047452159074, 1.1328998971259603, -0.0083494226043694768));
    float b = dot(v, vec3(-0.018150763354905303, -0.10057889800800739, 1.1187296613629127));
    return vec3(r, g, b);
}

vec4 PSDrawAreaRGBAUpscaleMultiplyTonemap(FragData frag_in)
{
    vec4 rgba = DrawAreaUpscale(frag_in);
    rgba.rgb *= multiplier;
    rgba.rgb = rec709_to_rec2020(rgba.rgb);
    rgba.rgb = reinhard(rgba.rgb);
    rgba.rgb = rec2020_to_rec709(rgba.rgb);
    return rgba;
}

vec4 _main_wrap(FragData frag_in)
{
    return PSDrawAreaRGBAUpscaleMultiplyTonemap(frag_in);
}

void main(void)
{
    FragData frag_in;
    frag_in.uv = _vertex_shader_attrib0;

    _pixel_shader_attrib0 = _main_wrap(frag_in);
}

info: ======funcs =======
info: fname:srgb_linear_to_nonlinear_channel rtype:float mapping:(null) content:{
    return (u <= 0.0031308) ? (12.92 * u) : ((1.055 * pow(u, 1. / 2.4)) - 0.055);
}
info: fname:srgb_linear_to_nonlinear rtype:float3 mapping:(null) content:{
    return float3(srgb_linear_to_nonlinear_channel(v.r), srgb_linear_to_nonlinear_channel(v.g), srgb_linear_to_nonlinear_channel(v.b));
}
info: fname:srgb_nonlinear_to_linear_channel rtype:float mapping:(null) content:{
    return (u <= 0.04045) ? (u / 12.92) : pow((u + 0.055) / 1.055, 2.4);
}
info: fname:srgb_nonlinear_to_linear rtype:float3 mapping:(null) content:{
    return float3(srgb_nonlinear_to_linear_channel(v.r), srgb_nonlinear_to_linear_channel(v.g), srgb_nonlinear_to_linear_channel(v.b));
}
info: fname:rec709_to_rec2020 rtype:float3 mapping:(null) content:{
    float r = dot(v, float3(0.62740389593469903, 0.32928303837788370, 0.043313065687417225));
    float g = dot(v, float3(0.069097289358232075, 0.91954039507545871, 0.011362315566309178));
    float b = dot(v, float3(0.016391438875150280, 0.088013307877225749, 0.89559525324762401));
    return float3(r, g, b);
}
info: fname:d65p3_to_rec709 rtype:float3 mapping:(null) content:{
    float r = dot(v, float3(1.2249401762805598, -0.22494017628055996, 0.));
    float g = dot(v, float3(-0.042056954709688163, 1.0420569547096881, 0.));
    float b = dot(v, float3(-0.019637554590334432, -0.078636045550631889, 1.0982736001409663));
    return float3(r, g, b);
}
info: fname:rec2020_to_rec709 rtype:float3 mapping:(null) content:{
    float r = dot(v, float3(1.6604910021084345, -0.58764113878854951, -0.072849863319884883));
    float g = dot(v, float3(-0.12455047452159074, 1.1328998971259603, -0.0083494226043694768));
    float b = dot(v, float3(-0.018150763354905303, -0.10057889800800739, 1.1187296613629127));
    return float3(r, g, b);
}
info: fname:reinhard rtype:float3 mapping:(null) content:{
    rgb /= rgb + float3(1., 1., 1.);
    rgb = pow(rgb, float3(1. / 2.4, 1. / 2.4, 1. / 2.4));
    rgb = srgb_nonlinear_to_linear(rgb);
    return rgb;
}
info: fname:linear_to_st2084_channel rtype:float mapping:(null) content:{
    float c = pow(abs(x), 0.1593017578);
    return pow((0.8359375 + 18.8515625 * c) / (1. + 18.6875 * c), 78.84375);
}
info: fname:linear_to_st2084 rtype:float3 mapping:(null) content:{
    return float3(linear_to_st2084_channel(rgb.r), linear_to_st2084_channel(rgb.g), linear_to_st2084_channel(rgb.b));
}
info: fname:st2084_to_linear_channel rtype:float mapping:(null) content:{
    float c = pow(abs(u), 1. / 78.84375);
    return pow(abs(max(c - 0.8359375, 0.) / (18.8515625 - 18.6875 * c)), 1. / 0.1593017578);
}
info: fname:st2084_to_linear rtype:float3 mapping:(null) content:{
    return float3(st2084_to_linear_channel(rgb.r), st2084_to_linear_channel(rgb.g), st2084_to_linear_channel(rgb.b));
}
info: fname:eetf_0_Lmax rtype:float mapping:(null) content:{
    float Lw_pq = linear_to_st2084_channel(Lw / 10000.);
    float E1 = saturate(maxRGB1_pq / Lw_pq);
    float maxLum = linear_to_st2084_channel(Lmax / 10000.) / Lw_pq;
    float KS = (1.5 * maxLum) - 0.5;
    float E2 = E1;
    if (E1 > KS)
    {
        float T = (E1 - KS) / (1. - KS);
        float Tsquared = T * T;
        float Tcubed = Tsquared * T;
        float P = (2. * Tcubed - 3. * Tsquared + 1.) * KS + (Tcubed - 2. * Tsquared + T) * (1. - KS) + (-2. * Tcubed + 3. * Tsquared) * maxLum;
        E2 = P;
    }
    float E3 = E2;
    float E4 = E3 * Lw_pq;
    return E4;
}
info: fname:maxRGB_eetf_internal rtype:float3 mapping:(null) content:{
    float maxRGB2_pq = eetf_0_Lmax(maxRGB1_pq, Lw, Lmax);
    float maxRGB2_linear = st2084_to_linear_channel(maxRGB2_pq);

     
    maxRGB1_linear = max(6.10352e-5, maxRGB1_linear);

    rgb_linear *= maxRGB2_linear / maxRGB1_linear;
    return rgb_linear;
}
info: fname:maxRGB_eetf_pq_to_linear rtype:float3 mapping:(null) content:{
    float3 rgb_linear = st2084_to_linear(rgb_pq);
    float maxRGB1_linear = max(max(rgb_linear.r, rgb_linear.g), rgb_linear.b);
    float maxRGB1_pq = max(max(rgb_pq.r, rgb_pq.g), rgb_pq.b);
    return maxRGB_eetf_internal(rgb_linear, maxRGB1_linear, maxRGB1_pq, Lw, Lmax);
}
info: fname:maxRGB_eetf_linear_to_linear rtype:float3 mapping:(null) content:{
    float maxRGB1_linear = max(max(rgb_linear.r, rgb_linear.g), rgb_linear.b);
    float maxRGB1_pq = linear_to_st2084_channel(maxRGB1_linear);
    return maxRGB_eetf_internal(rgb_linear, maxRGB1_linear, maxRGB1_pq, Lw, Lmax);
}
info: fname:st2084_to_linear_eetf rtype:float3 mapping:(null) content:{
    return (Lw > Lmax) ? maxRGB_eetf_pq_to_linear(rgb, Lw, Lmax) : st2084_to_linear(rgb);
}
info: fname:linear_to_hlg_channel rtype:float mapping:(null) content:{
    float ln2_i = 1. / log(2.);
    float m = 0.17883277 / ln2_i;
    return (u <= (1. / 12.)) ? sqrt(3. * u) : ((log2((12. * u) - 0.28466892) * m) + 0.55991073);
}
info: fname:linear_to_hlg rtype:float3 mapping:(null) content:{
    rgb = saturate(rgb);

    if (Lw > 1000.)
    {
        rgb = maxRGB_eetf_linear_to_linear(rgb, Lw, 1000.);
        rgb *= 10000. / Lw;
    }
    else
    {
        rgb *= 10.;
    }

    float Yd = dot(rgb, float3(0.2627, 0.678, 0.0593));

     
    Yd = max(6.10352e-5, Yd);

    rgb *= pow(Yd, -1. / 6.);
    return float3(linear_to_hlg_channel(rgb.r), linear_to_hlg_channel(rgb.g), linear_to_hlg_channel(rgb.b));
}
info: fname:hlg_to_linear_channel rtype:float mapping:(null) content:{
    float ln2_i = 1. / log(2.);
    float m = ln2_i / 0.17883277;
    float a = -ln2_i * 0.55991073 / 0.17883277;
    return (u <= 0.5) ? ((u * u) / 3.) : ((exp2(u * m + a) + 0.28466892) / 12.);
}
info: fname:hlg_to_linear rtype:float3 mapping:(null) content:{
    float3 rgb = float3(hlg_to_linear_channel(v.r), hlg_to_linear_channel(v.g), hlg_to_linear_channel(v.b));
    float Ys = dot(rgb, float3(0.2627, 0.678, 0.0593));
    rgb *= pow(Ys, exponent);
    return rgb;
}
info: fname:VSDefault rtype:VertInOut mapping:(null) content:{
    VertInOut vert_out;
    vert_out.pos = mul(float4(vert_in.pos.xyz, 1.0), ViewProj);
    vert_out.uv  = vert_in.uv;
    return vert_out;
}
info: fname:DrawArea rtype:float4 mapping:(null) content:{
    float2 uv = frag_in.uv;
    float2 uv_delta = float2(ddx(uv.x), ddy(uv.y));

     
    if (obs_glsl_compile)
        uv_delta.y = abs(uv_delta.y);

    float2 uv_min = uv - 0.5 * uv_delta;
    float2 uv_max = uv_min + uv_delta;

    float2 load_index_begin = floor(uv_min * base_dimension);
    float2 load_index_end = ceil(uv_max * base_dimension);

    float2 target_dimension = 1.0 / uv_delta;
    float2 target_pos = uv * target_dimension;
    float2 target_pos_min = target_pos - 0.5;
    float2 target_pos_max = target_pos + 0.5;
    float2 scale = base_dimension_i * target_dimension;

    float4 total_color = float4(0.0, 0.0, 0.0, 0.0);

    float load_index_y = load_index_begin.y;
    do {
        float source_y_min = load_index_y * scale.y;
        float source_y_max = source_y_min + scale.y;
        float y_min = max(source_y_min, target_pos_min.y);
        float y_max = min(source_y_max, target_pos_max.y);
        float height = y_max - y_min;

        float load_index_x = load_index_begin.x;
        do {
            float source_x_min = load_index_x * scale.x;
            float source_x_max = source_x_min + scale.x;
            float x_min = max(source_x_min, target_pos_min.x);
            float x_max = min(source_x_max, target_pos_max.x);
            float width = x_max - x_min;
            float area = width * height;

            float4 color = image.Load(int3(load_index_x, load_index_y, 0));
            total_color += area * color;

            ++load_index_x;
        } while (load_index_x < load_index_end.x);

        ++load_index_y;
    } while (load_index_y < load_index_end.y);

    return total_color;
}
info: fname:PSDrawAreaRGBA rtype:float4 mapping:TARGET content:{
    return DrawArea(frag_in);
}
info: fname:PSDrawAreaRGBAMultiply rtype:float4 mapping:TARGET content:{
    float4 rgba = DrawArea(frag_in);
    rgba.rgb *= multiplier;
    return rgba;
}
info: fname:PSDrawAreaRGBATonemap rtype:float4 mapping:TARGET content:{
    float4 rgba = DrawArea(frag_in);
    rgba.rgb = rec709_to_rec2020(rgba.rgb);
    rgba.rgb = reinhard(rgba.rgb);
    rgba.rgb = rec2020_to_rec709(rgba.rgb);
    return rgba;
}
info: fname:PSDrawAreaRGBAMultiplyTonemap rtype:float4 mapping:TARGET content:{
    float4 rgba = DrawArea(frag_in);
    rgba.rgb *= multiplier;
    rgba.rgb = rec709_to_rec2020(rgba.rgb);
    rgba.rgb = reinhard(rgba.rgb);
    rgba.rgb = rec2020_to_rec709(rgba.rgb);
    return rgba;
}
info: fname:PSDrawAreaRGBADivide rtype:float4 mapping:TARGET content:{
    float4 rgba = DrawArea(frag_in);
    rgba.rgb *= max(1. / rgba.a, 0.);
    return rgba;
}
info: fname:DrawAreaUpscale rtype:float4 mapping:(null) content:{
    float2 uv = frag_in.uv;
    float2 uv_delta = float2(ddx(uv.x), ddy(uv.y));

     
    if (obs_glsl_compile)
        uv_delta.y = abs(uv_delta.y);

    float2 uv_min = uv - 0.5 * uv_delta;
    float2 uv_max = uv_min + uv_delta;

    float2 load_index_first = floor(uv_min * base_dimension);
    float2 load_index_last = ceil(uv_max * base_dimension) - 1.0;

    if (load_index_first.x < load_index_last.x) {
        float uv_boundary_x = load_index_last.x * base_dimension_i.x;
        uv.x = ((uv.x - uv_boundary_x) / uv_delta.x) * base_dimension_i.x + uv_boundary_x;
    } else
        uv.x = (load_index_first.x + 0.5) * base_dimension_i.x;
    if (load_index_first.y < load_index_last.y) {
        float uv_boundary_y = load_index_last.y * base_dimension_i.y;
        uv.y = ((uv.y - uv_boundary_y) / uv_delta.y) * base_dimension_i.y + uv_boundary_y;
    } else
        uv.y = (load_index_first.y + 0.5) * base_dimension_i.y;

    return image.Sample(textureSampler, uv);
}
info: fname:PSDrawAreaRGBAUpscale rtype:float4 mapping:TARGET content:{
    return DrawAreaUpscale(frag_in);
}
info: fname:PSDrawAreaRGBAUpscaleMultiply rtype:float4 mapping:TARGET content:{
    float4 rgba = DrawAreaUpscale(frag_in);
    rgba.rgb *= multiplier;
    return rgba;
}
info: fname:PSDrawAreaRGBAUpscaleTonemap rtype:float4 mapping:TARGET content:{
    float4 rgba = DrawAreaUpscale(frag_in);
    rgba.rgb = rec709_to_rec2020(rgba.rgb);
    rgba.rgb = reinhard(rgba.rgb);
    rgba.rgb = rec2020_to_rec709(rgba.rgb);
    return rgba;
}
info: fname:PSDrawAreaRGBAUpscaleMultiplyTonemap rtype:float4 mapping:TARGET content:{
    float4 rgba = DrawAreaUpscale(frag_in);
    rgba.rgb *= multiplier;
    rgba.rgb = rec709_to_rec2020(rgba.rgb);
    rgba.rgb = reinhard(rgba.rgb);
    rgba.rgb = rec2020_to_rec709(rgba.rgb);
    return rgba;
}
info: ======params =======
info: fname:ViewProj type:float4x4
info: fname:base_dimension type:float2
info: fname:base_dimension_i type:float2
info: fname:image type:texture2d
info: fname:multiplier type:float
info: ======structs =======
info: fname:VertData
info: fname:VertInOut
info: fname:FragData
info: ======samplers =======
info: fname:textureSampler
info: ======techniques =======
info: fname:Draw
info: fname:DrawMultiply
info: fname:DrawTonemap
info: fname:DrawMultiplyTonemap
info: fname:DrawAlphaDivide
info: fname:DrawUpscale
info: fname:DrawUpscaleMultiply
info: fname:DrawUpscaleTonemap
info: fname:DrawUpscaleMultiplyTonemap
info: ======files =======
info: ======tokens =======
info: ======techniques =======
info: tname:Draw
info: tname:(null)
info: tname:DrawMultiply
info: tname:(null)
info: tname:DrawTonemap
info: tname:(null)
info: tname:DrawMultiplyTonemap
info: tname:(null)
info: tname:DrawAlphaDivide
info: tname:(null)
info: tname:DrawUpscale
info: tname:(null)
info: tname:DrawUpscaleMultiply
info: tname:(null)
info: tname:DrawUpscaleTonemap
info: tname:(null)
info: tname:DrawUpscaleMultiplyTonemap
info: tname:(null)
info: ======params =======
info: tname:ViewProj
info: tname:base_dimension
info: tname:base_dimension_i
info: tname:image
info: tname:multiplier
info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform mat4x4 ViewProj;

in vec4 _input_attrib0;
in vec2 _input_attrib1;

out vec2 _vertex_shader_attrib0;

out gl_PerVertex {
    vec4 gl_Position;
};

struct VertData {
    vec4 pos;
    vec2 uv;
};

VertData VSDefault(VertData v_in)
{
    VertData vert_out;
    vert_out.pos = ((vec4(v_in.pos.xyz, 1.0)) * (ViewProj));
    vert_out.uv  = v_in.uv;
    return vert_out;
}

VertData _main_wrap(VertData v_in)
{
    return VSDefault(v_in);
}

void main(void)
{
    VertData v_in;
    VertData outputval;

    v_in.pos = _input_attrib0;
    v_in.uv = _input_attrib1;

    outputval = _main_wrap(v_in);

    gl_Position = outputval.pos;
    _vertex_shader_attrib0 = outputval.uv;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform sampler2D image;

in vec2 _vertex_shader_attrib0;

out vec4 _pixel_shader_attrib0;

struct VertData {
    vec4 pos;
    vec2 uv;
};

vec4 pixel(vec2 uv)
{
    return texture(image, uv);
}

vec4 DrawLowresBilinear(VertData f_in)
{
    vec2 uv = f_in.uv;
    vec2 stepxy  = vec2(dFdx(uv.x), dFdy(uv.y));
    vec2 stepxy1 = stepxy * 0.0625;
    vec2 stepxy3 = stepxy * 0.1875;
    vec2 stepxy5 = stepxy * 0.3125;
    vec2 stepxy7 = stepxy * 0.4375;

     
    vec4 out_color;
    out_color  = pixel(uv + vec2( stepxy1.x, -stepxy3.y));
    out_color += pixel(uv + vec2(-stepxy1.x,  stepxy3.y));
    out_color += pixel(uv + vec2( stepxy5.x,  stepxy1.y));
    out_color += pixel(uv + vec2(-stepxy3.x, -stepxy5.y));
    out_color += pixel(uv + vec2(-stepxy5.x,  stepxy5.y));
    out_color += pixel(uv + vec2(-stepxy7.x, -stepxy1.y));
    out_color += pixel(uv + vec2( stepxy3.x,  stepxy7.y));
    out_color += pixel(uv + vec2( stepxy7.x, -stepxy7.y));
    return out_color * 0.125;
}

vec4 PSDrawLowresBilinearRGBA(VertData f_in)
{
    return DrawLowresBilinear(f_in);
}

vec4 _main_wrap(VertData f_in)
{
    return PSDrawLowresBilinearRGBA(f_in);
}

void main(void)
{
    VertData f_in;
    f_in.pos = gl_FragCoord;
    f_in.uv = _vertex_shader_attrib0;

    _pixel_shader_attrib0 = _main_wrap(f_in);
}

info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform mat4x4 ViewProj;

in vec4 _input_attrib0;
in vec2 _input_attrib1;

out vec2 _vertex_shader_attrib0;

out gl_PerVertex {
    vec4 gl_Position;
};

struct VertData {
    vec4 pos;
    vec2 uv;
};

VertData VSDefault(VertData v_in)
{
    VertData vert_out;
    vert_out.pos = ((vec4(v_in.pos.xyz, 1.0)) * (ViewProj));
    vert_out.uv  = v_in.uv;
    return vert_out;
}

VertData _main_wrap(VertData v_in)
{
    return VSDefault(v_in);
}

void main(void)
{
    VertData v_in;
    VertData outputval;

    v_in.pos = _input_attrib0;
    v_in.uv = _input_attrib1;

    outputval = _main_wrap(v_in);

    gl_Position = outputval.pos;
    _vertex_shader_attrib0 = outputval.uv;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform float multiplier;
uniform sampler2D image;

in vec2 _vertex_shader_attrib0;

out vec4 _pixel_shader_attrib0;

struct VertData {
    vec4 pos;
    vec2 uv;
};

vec4 pixel(vec2 uv)
{
    return texture(image, uv);
}

vec4 DrawLowresBilinear(VertData f_in)
{
    vec2 uv = f_in.uv;
    vec2 stepxy  = vec2(dFdx(uv.x), dFdy(uv.y));
    vec2 stepxy1 = stepxy * 0.0625;
    vec2 stepxy3 = stepxy * 0.1875;
    vec2 stepxy5 = stepxy * 0.3125;
    vec2 stepxy7 = stepxy * 0.4375;

     
    vec4 out_color;
    out_color  = pixel(uv + vec2( stepxy1.x, -stepxy3.y));
    out_color += pixel(uv + vec2(-stepxy1.x,  stepxy3.y));
    out_color += pixel(uv + vec2( stepxy5.x,  stepxy1.y));
    out_color += pixel(uv + vec2(-stepxy3.x, -stepxy5.y));
    out_color += pixel(uv + vec2(-stepxy5.x,  stepxy5.y));
    out_color += pixel(uv + vec2(-stepxy7.x, -stepxy1.y));
    out_color += pixel(uv + vec2( stepxy3.x,  stepxy7.y));
    out_color += pixel(uv + vec2( stepxy7.x, -stepxy7.y));
    return out_color * 0.125;
}

vec4 PSDrawLowresBilinearRGBAMultiply(VertData f_in)
{
    vec4 rgba = DrawLowresBilinear(f_in);
    rgba.rgb *= multiplier;
    return rgba;
}

vec4 _main_wrap(VertData f_in)
{
    return PSDrawLowresBilinearRGBAMultiply(f_in);
}

void main(void)
{
    VertData f_in;
    f_in.pos = gl_FragCoord;
    f_in.uv = _vertex_shader_attrib0;

    _pixel_shader_attrib0 = _main_wrap(f_in);
}

info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform mat4x4 ViewProj;

in vec4 _input_attrib0;
in vec2 _input_attrib1;

out vec2 _vertex_shader_attrib0;

out gl_PerVertex {
    vec4 gl_Position;
};

struct VertData {
    vec4 pos;
    vec2 uv;
};

VertData VSDefault(VertData v_in)
{
    VertData vert_out;
    vert_out.pos = ((vec4(v_in.pos.xyz, 1.0)) * (ViewProj));
    vert_out.uv  = v_in.uv;
    return vert_out;
}

VertData _main_wrap(VertData v_in)
{
    return VSDefault(v_in);
}

void main(void)
{
    VertData v_in;
    VertData outputval;

    v_in.pos = _input_attrib0;
    v_in.uv = _input_attrib1;

    outputval = _main_wrap(v_in);

    gl_Position = outputval.pos;
    _vertex_shader_attrib0 = outputval.uv;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform sampler2D image;

in vec2 _vertex_shader_attrib0;

out vec4 _pixel_shader_attrib0;

struct VertData {
    vec4 pos;
    vec2 uv;
};

vec4 pixel(vec2 uv)
{
    return texture(image, uv);
}

vec4 DrawLowresBilinear(VertData f_in)
{
    vec2 uv = f_in.uv;
    vec2 stepxy  = vec2(dFdx(uv.x), dFdy(uv.y));
    vec2 stepxy1 = stepxy * 0.0625;
    vec2 stepxy3 = stepxy * 0.1875;
    vec2 stepxy5 = stepxy * 0.3125;
    vec2 stepxy7 = stepxy * 0.4375;

     
    vec4 out_color;
    out_color  = pixel(uv + vec2( stepxy1.x, -stepxy3.y));
    out_color += pixel(uv + vec2(-stepxy1.x,  stepxy3.y));
    out_color += pixel(uv + vec2( stepxy5.x,  stepxy1.y));
    out_color += pixel(uv + vec2(-stepxy3.x, -stepxy5.y));
    out_color += pixel(uv + vec2(-stepxy5.x,  stepxy5.y));
    out_color += pixel(uv + vec2(-stepxy7.x, -stepxy1.y));
    out_color += pixel(uv + vec2( stepxy3.x,  stepxy7.y));
    out_color += pixel(uv + vec2( stepxy7.x, -stepxy7.y));
    return out_color * 0.125;
}

vec3 rec709_to_rec2020(vec3 v)
{
    float r = dot(v, vec3(0.62740389593469903, 0.32928303837788370, 0.043313065687417225));
    float g = dot(v, vec3(0.069097289358232075, 0.91954039507545871, 0.011362315566309178));
    float b = dot(v, vec3(0.016391438875150280, 0.088013307877225749, 0.89559525324762401));
    return vec3(r, g, b);
}

float srgb_nonlinear_to_linear_channel(float u)
{
    return (u <= 0.04045) ? (u / 12.92) : pow((u + 0.055) / 1.055, 2.4);
}

vec3 srgb_nonlinear_to_linear(vec3 v)
{
    return vec3(srgb_nonlinear_to_linear_channel(v.r), srgb_nonlinear_to_linear_channel(v.g), srgb_nonlinear_to_linear_channel(v.b));
}

vec3 reinhard(vec3 rgb)
{
    rgb /= rgb + vec3(1., 1., 1.);
    rgb = pow(rgb, vec3(1. / 2.4, 1. / 2.4, 1. / 2.4));
    rgb = srgb_nonlinear_to_linear(rgb);
    return rgb;
}

vec3 rec2020_to_rec709(vec3 v)
{
    float r = dot(v, vec3(1.6604910021084345, -0.58764113878854951, -0.072849863319884883));
    float g = dot(v, vec3(-0.12455047452159074, 1.1328998971259603, -0.0083494226043694768));
    float b = dot(v, vec3(-0.018150763354905303, -0.10057889800800739, 1.1187296613629127));
    return vec3(r, g, b);
}

vec4 PSDrawLowresBilinearRGBATonemap(VertData f_in)
{
    vec4 rgba = DrawLowresBilinear(f_in);
    rgba.rgb = rec709_to_rec2020(rgba.rgb);
    rgba.rgb = reinhard(rgba.rgb);
    rgba.rgb = rec2020_to_rec709(rgba.rgb);
    return rgba;
}

vec4 _main_wrap(VertData f_in)
{
    return PSDrawLowresBilinearRGBATonemap(f_in);
}

void main(void)
{
    VertData f_in;
    f_in.pos = gl_FragCoord;
    f_in.uv = _vertex_shader_attrib0;

    _pixel_shader_attrib0 = _main_wrap(f_in);
}

info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform mat4x4 ViewProj;

in vec4 _input_attrib0;
in vec2 _input_attrib1;

out vec2 _vertex_shader_attrib0;

out gl_PerVertex {
    vec4 gl_Position;
};

struct VertData {
    vec4 pos;
    vec2 uv;
};

VertData VSDefault(VertData v_in)
{
    VertData vert_out;
    vert_out.pos = ((vec4(v_in.pos.xyz, 1.0)) * (ViewProj));
    vert_out.uv  = v_in.uv;
    return vert_out;
}

VertData _main_wrap(VertData v_in)
{
    return VSDefault(v_in);
}

void main(void)
{
    VertData v_in;
    VertData outputval;

    v_in.pos = _input_attrib0;
    v_in.uv = _input_attrib1;

    outputval = _main_wrap(v_in);

    gl_Position = outputval.pos;
    _vertex_shader_attrib0 = outputval.uv;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform float multiplier;
uniform sampler2D image;

in vec2 _vertex_shader_attrib0;

out vec4 _pixel_shader_attrib0;

struct VertData {
    vec4 pos;
    vec2 uv;
};

vec4 pixel(vec2 uv)
{
    return texture(image, uv);
}

vec4 DrawLowresBilinear(VertData f_in)
{
    vec2 uv = f_in.uv;
    vec2 stepxy  = vec2(dFdx(uv.x), dFdy(uv.y));
    vec2 stepxy1 = stepxy * 0.0625;
    vec2 stepxy3 = stepxy * 0.1875;
    vec2 stepxy5 = stepxy * 0.3125;
    vec2 stepxy7 = stepxy * 0.4375;

     
    vec4 out_color;
    out_color  = pixel(uv + vec2( stepxy1.x, -stepxy3.y));
    out_color += pixel(uv + vec2(-stepxy1.x,  stepxy3.y));
    out_color += pixel(uv + vec2( stepxy5.x,  stepxy1.y));
    out_color += pixel(uv + vec2(-stepxy3.x, -stepxy5.y));
    out_color += pixel(uv + vec2(-stepxy5.x,  stepxy5.y));
    out_color += pixel(uv + vec2(-stepxy7.x, -stepxy1.y));
    out_color += pixel(uv + vec2( stepxy3.x,  stepxy7.y));
    out_color += pixel(uv + vec2( stepxy7.x, -stepxy7.y));
    return out_color * 0.125;
}

vec3 rec709_to_rec2020(vec3 v)
{
    float r = dot(v, vec3(0.62740389593469903, 0.32928303837788370, 0.043313065687417225));
    float g = dot(v, vec3(0.069097289358232075, 0.91954039507545871, 0.011362315566309178));
    float b = dot(v, vec3(0.016391438875150280, 0.088013307877225749, 0.89559525324762401));
    return vec3(r, g, b);
}

float srgb_nonlinear_to_linear_channel(float u)
{
    return (u <= 0.04045) ? (u / 12.92) : pow((u + 0.055) / 1.055, 2.4);
}

vec3 srgb_nonlinear_to_linear(vec3 v)
{
    return vec3(srgb_nonlinear_to_linear_channel(v.r), srgb_nonlinear_to_linear_channel(v.g), srgb_nonlinear_to_linear_channel(v.b));
}

vec3 reinhard(vec3 rgb)
{
    rgb /= rgb + vec3(1., 1., 1.);
    rgb = pow(rgb, vec3(1. / 2.4, 1. / 2.4, 1. / 2.4));
    rgb = srgb_nonlinear_to_linear(rgb);
    return rgb;
}

vec3 rec2020_to_rec709(vec3 v)
{
    float r = dot(v, vec3(1.6604910021084345, -0.58764113878854951, -0.072849863319884883));
    float g = dot(v, vec3(-0.12455047452159074, 1.1328998971259603, -0.0083494226043694768));
    float b = dot(v, vec3(-0.018150763354905303, -0.10057889800800739, 1.1187296613629127));
    return vec3(r, g, b);
}

vec4 PSDrawLowresBilinearRGBAMultiplyTonemap(VertData f_in)
{
    vec4 rgba = DrawLowresBilinear(f_in);
    rgba.rgb *= multiplier;
    rgba.rgb = rec709_to_rec2020(rgba.rgb);
    rgba.rgb = reinhard(rgba.rgb);
    rgba.rgb = rec2020_to_rec709(rgba.rgb);
    return rgba;
}

vec4 _main_wrap(VertData f_in)
{
    return PSDrawLowresBilinearRGBAMultiplyTonemap(f_in);
}

void main(void)
{
    VertData f_in;
    f_in.pos = gl_FragCoord;
    f_in.uv = _vertex_shader_attrib0;

    _pixel_shader_attrib0 = _main_wrap(f_in);
}

info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform mat4x4 ViewProj;

in vec4 _input_attrib0;
in vec2 _input_attrib1;

out vec2 _vertex_shader_attrib0;

out gl_PerVertex {
    vec4 gl_Position;
};

struct VertData {
    vec4 pos;
    vec2 uv;
};

VertData VSDefault(VertData v_in)
{
    VertData vert_out;
    vert_out.pos = ((vec4(v_in.pos.xyz, 1.0)) * (ViewProj));
    vert_out.uv  = v_in.uv;
    return vert_out;
}

VertData _main_wrap(VertData v_in)
{
    return VSDefault(v_in);
}

void main(void)
{
    VertData v_in;
    VertData outputval;

    v_in.pos = _input_attrib0;
    v_in.uv = _input_attrib1;

    outputval = _main_wrap(v_in);

    gl_Position = outputval.pos;
    _vertex_shader_attrib0 = outputval.uv;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform sampler2D image;

in vec2 _vertex_shader_attrib0;

out vec4 _pixel_shader_attrib0;

struct VertData {
    vec4 pos;
    vec2 uv;
};

vec4 pixel(vec2 uv)
{
    return texture(image, uv);
}

vec4 DrawLowresBilinear(VertData f_in)
{
    vec2 uv = f_in.uv;
    vec2 stepxy  = vec2(dFdx(uv.x), dFdy(uv.y));
    vec2 stepxy1 = stepxy * 0.0625;
    vec2 stepxy3 = stepxy * 0.1875;
    vec2 stepxy5 = stepxy * 0.3125;
    vec2 stepxy7 = stepxy * 0.4375;

     
    vec4 out_color;
    out_color  = pixel(uv + vec2( stepxy1.x, -stepxy3.y));
    out_color += pixel(uv + vec2(-stepxy1.x,  stepxy3.y));
    out_color += pixel(uv + vec2( stepxy5.x,  stepxy1.y));
    out_color += pixel(uv + vec2(-stepxy3.x, -stepxy5.y));
    out_color += pixel(uv + vec2(-stepxy5.x,  stepxy5.y));
    out_color += pixel(uv + vec2(-stepxy7.x, -stepxy1.y));
    out_color += pixel(uv + vec2( stepxy3.x,  stepxy7.y));
    out_color += pixel(uv + vec2( stepxy7.x, -stepxy7.y));
    return out_color * 0.125;
}

vec4 PSDrawLowresBilinearRGBADivide(VertData f_in)
{
    vec4 rgba = DrawLowresBilinear(f_in);
    rgba.rgb *= max(1. / rgba.a, 0.);
    return rgba;
}

vec4 _main_wrap(VertData f_in)
{
    return PSDrawLowresBilinearRGBADivide(f_in);
}

void main(void)
{
    VertData f_in;
    f_in.pos = gl_FragCoord;
    f_in.uv = _vertex_shader_attrib0;

    _pixel_shader_attrib0 = _main_wrap(f_in);
}

info: ======funcs =======
info: fname:srgb_linear_to_nonlinear_channel rtype:float mapping:(null) content:{
    return (u <= 0.0031308) ? (12.92 * u) : ((1.055 * pow(u, 1. / 2.4)) - 0.055);
}
info: fname:srgb_linear_to_nonlinear rtype:float3 mapping:(null) content:{
    return float3(srgb_linear_to_nonlinear_channel(v.r), srgb_linear_to_nonlinear_channel(v.g), srgb_linear_to_nonlinear_channel(v.b));
}
info: fname:srgb_nonlinear_to_linear_channel rtype:float mapping:(null) content:{
    return (u <= 0.04045) ? (u / 12.92) : pow((u + 0.055) / 1.055, 2.4);
}
info: fname:srgb_nonlinear_to_linear rtype:float3 mapping:(null) content:{
    return float3(srgb_nonlinear_to_linear_channel(v.r), srgb_nonlinear_to_linear_channel(v.g), srgb_nonlinear_to_linear_channel(v.b));
}
info: fname:rec709_to_rec2020 rtype:float3 mapping:(null) content:{
    float r = dot(v, float3(0.62740389593469903, 0.32928303837788370, 0.043313065687417225));
    float g = dot(v, float3(0.069097289358232075, 0.91954039507545871, 0.011362315566309178));
    float b = dot(v, float3(0.016391438875150280, 0.088013307877225749, 0.89559525324762401));
    return float3(r, g, b);
}
info: fname:d65p3_to_rec709 rtype:float3 mapping:(null) content:{
    float r = dot(v, float3(1.2249401762805598, -0.22494017628055996, 0.));
    float g = dot(v, float3(-0.042056954709688163, 1.0420569547096881, 0.));
    float b = dot(v, float3(-0.019637554590334432, -0.078636045550631889, 1.0982736001409663));
    return float3(r, g, b);
}
info: fname:rec2020_to_rec709 rtype:float3 mapping:(null) content:{
    float r = dot(v, float3(1.6604910021084345, -0.58764113878854951, -0.072849863319884883));
    float g = dot(v, float3(-0.12455047452159074, 1.1328998971259603, -0.0083494226043694768));
    float b = dot(v, float3(-0.018150763354905303, -0.10057889800800739, 1.1187296613629127));
    return float3(r, g, b);
}
info: fname:reinhard rtype:float3 mapping:(null) content:{
    rgb /= rgb + float3(1., 1., 1.);
    rgb = pow(rgb, float3(1. / 2.4, 1. / 2.4, 1. / 2.4));
    rgb = srgb_nonlinear_to_linear(rgb);
    return rgb;
}
info: fname:linear_to_st2084_channel rtype:float mapping:(null) content:{
    float c = pow(abs(x), 0.1593017578);
    return pow((0.8359375 + 18.8515625 * c) / (1. + 18.6875 * c), 78.84375);
}
info: fname:linear_to_st2084 rtype:float3 mapping:(null) content:{
    return float3(linear_to_st2084_channel(rgb.r), linear_to_st2084_channel(rgb.g), linear_to_st2084_channel(rgb.b));
}
info: fname:st2084_to_linear_channel rtype:float mapping:(null) content:{
    float c = pow(abs(u), 1. / 78.84375);
    return pow(abs(max(c - 0.8359375, 0.) / (18.8515625 - 18.6875 * c)), 1. / 0.1593017578);
}
info: fname:st2084_to_linear rtype:float3 mapping:(null) content:{
    return float3(st2084_to_linear_channel(rgb.r), st2084_to_linear_channel(rgb.g), st2084_to_linear_channel(rgb.b));
}
info: fname:eetf_0_Lmax rtype:float mapping:(null) content:{
    float Lw_pq = linear_to_st2084_channel(Lw / 10000.);
    float E1 = saturate(maxRGB1_pq / Lw_pq);
    float maxLum = linear_to_st2084_channel(Lmax / 10000.) / Lw_pq;
    float KS = (1.5 * maxLum) - 0.5;
    float E2 = E1;
    if (E1 > KS)
    {
        float T = (E1 - KS) / (1. - KS);
        float Tsquared = T * T;
        float Tcubed = Tsquared * T;
        float P = (2. * Tcubed - 3. * Tsquared + 1.) * KS + (Tcubed - 2. * Tsquared + T) * (1. - KS) + (-2. * Tcubed + 3. * Tsquared) * maxLum;
        E2 = P;
    }
    float E3 = E2;
    float E4 = E3 * Lw_pq;
    return E4;
}
info: fname:maxRGB_eetf_internal rtype:float3 mapping:(null) content:{
    float maxRGB2_pq = eetf_0_Lmax(maxRGB1_pq, Lw, Lmax);
    float maxRGB2_linear = st2084_to_linear_channel(maxRGB2_pq);

     
    maxRGB1_linear = max(6.10352e-5, maxRGB1_linear);

    rgb_linear *= maxRGB2_linear / maxRGB1_linear;
    return rgb_linear;
}
info: fname:maxRGB_eetf_pq_to_linear rtype:float3 mapping:(null) content:{
    float3 rgb_linear = st2084_to_linear(rgb_pq);
    float maxRGB1_linear = max(max(rgb_linear.r, rgb_linear.g), rgb_linear.b);
    float maxRGB1_pq = max(max(rgb_pq.r, rgb_pq.g), rgb_pq.b);
    return maxRGB_eetf_internal(rgb_linear, maxRGB1_linear, maxRGB1_pq, Lw, Lmax);
}
info: fname:maxRGB_eetf_linear_to_linear rtype:float3 mapping:(null) content:{
    float maxRGB1_linear = max(max(rgb_linear.r, rgb_linear.g), rgb_linear.b);
    float maxRGB1_pq = linear_to_st2084_channel(maxRGB1_linear);
    return maxRGB_eetf_internal(rgb_linear, maxRGB1_linear, maxRGB1_pq, Lw, Lmax);
}
info: fname:st2084_to_linear_eetf rtype:float3 mapping:(null) content:{
    return (Lw > Lmax) ? maxRGB_eetf_pq_to_linear(rgb, Lw, Lmax) : st2084_to_linear(rgb);
}
info: fname:linear_to_hlg_channel rtype:float mapping:(null) content:{
    float ln2_i = 1. / log(2.);
    float m = 0.17883277 / ln2_i;
    return (u <= (1. / 12.)) ? sqrt(3. * u) : ((log2((12. * u) - 0.28466892) * m) + 0.55991073);
}
info: fname:linear_to_hlg rtype:float3 mapping:(null) content:{
    rgb = saturate(rgb);

    if (Lw > 1000.)
    {
        rgb = maxRGB_eetf_linear_to_linear(rgb, Lw, 1000.);
        rgb *= 10000. / Lw;
    }
    else
    {
        rgb *= 10.;
    }

    float Yd = dot(rgb, float3(0.2627, 0.678, 0.0593));

     
    Yd = max(6.10352e-5, Yd);

    rgb *= pow(Yd, -1. / 6.);
    return float3(linear_to_hlg_channel(rgb.r), linear_to_hlg_channel(rgb.g), linear_to_hlg_channel(rgb.b));
}
info: fname:hlg_to_linear_channel rtype:float mapping:(null) content:{
    float ln2_i = 1. / log(2.);
    float m = ln2_i / 0.17883277;
    float a = -ln2_i * 0.55991073 / 0.17883277;
    return (u <= 0.5) ? ((u * u) / 3.) : ((exp2(u * m + a) + 0.28466892) / 12.);
}
info: fname:hlg_to_linear rtype:float3 mapping:(null) content:{
    float3 rgb = float3(hlg_to_linear_channel(v.r), hlg_to_linear_channel(v.g), hlg_to_linear_channel(v.b));
    float Ys = dot(rgb, float3(0.2627, 0.678, 0.0593));
    rgb *= pow(Ys, exponent);
    return rgb;
}
info: fname:VSDefault rtype:VertData mapping:(null) content:{
    VertData vert_out;
    vert_out.pos = mul(float4(v_in.pos.xyz, 1.0), ViewProj);
    vert_out.uv  = v_in.uv;
    return vert_out;
}
info: fname:pixel rtype:float4 mapping:(null) content:{
    return image.Sample(textureSampler, uv);
}
info: fname:DrawLowresBilinear rtype:float4 mapping:(null) content:{
    float2 uv = f_in.uv;
    float2 stepxy  = float2(ddx(uv.x), ddy(uv.y));
    float2 stepxy1 = stepxy * 0.0625;
    float2 stepxy3 = stepxy * 0.1875;
    float2 stepxy5 = stepxy * 0.3125;
    float2 stepxy7 = stepxy * 0.4375;

     
    float4 out_color;
    out_color  = pixel(uv + float2( stepxy1.x, -stepxy3.y));
    out_color += pixel(uv + float2(-stepxy1.x,  stepxy3.y));
    out_color += pixel(uv + float2( stepxy5.x,  stepxy1.y));
    out_color += pixel(uv + float2(-stepxy3.x, -stepxy5.y));
    out_color += pixel(uv + float2(-stepxy5.x,  stepxy5.y));
    out_color += pixel(uv + float2(-stepxy7.x, -stepxy1.y));
    out_color += pixel(uv + float2( stepxy3.x,  stepxy7.y));
    out_color += pixel(uv + float2( stepxy7.x, -stepxy7.y));
    return out_color * 0.125;
}
info: fname:PSDrawLowresBilinearRGBA rtype:float4 mapping:TARGET content:{
    return DrawLowresBilinear(f_in);
}
info: fname:PSDrawLowresBilinearRGBAMultiply rtype:float4 mapping:TARGET content:{
    float4 rgba = DrawLowresBilinear(f_in);
    rgba.rgb *= multiplier;
    return rgba;
}
info: fname:PSDrawLowresBilinearRGBATonemap rtype:float4 mapping:TARGET content:{
    float4 rgba = DrawLowresBilinear(f_in);
    rgba.rgb = rec709_to_rec2020(rgba.rgb);
    rgba.rgb = reinhard(rgba.rgb);
    rgba.rgb = rec2020_to_rec709(rgba.rgb);
    return rgba;
}
info: fname:PSDrawLowresBilinearRGBAMultiplyTonemap rtype:float4 mapping:TARGET content:{
    float4 rgba = DrawLowresBilinear(f_in);
    rgba.rgb *= multiplier;
    rgba.rgb = rec709_to_rec2020(rgba.rgb);
    rgba.rgb = reinhard(rgba.rgb);
    rgba.rgb = rec2020_to_rec709(rgba.rgb);
    return rgba;
}
info: fname:PSDrawLowresBilinearRGBADivide rtype:float4 mapping:TARGET content:{
    float4 rgba = DrawLowresBilinear(f_in);
    rgba.rgb *= max(1. / rgba.a, 0.);
    return rgba;
}
info: ======params =======
info: fname:ViewProj type:float4x4
info: fname:image type:texture2d
info: fname:multiplier type:float
info: ======structs =======
info: fname:VertData
info: ======samplers =======
info: fname:textureSampler
info: ======techniques =======
info: fname:Draw
info: fname:DrawMultiply
info: fname:DrawTonemap
info: fname:DrawMultiplyTonemap
info: fname:DrawAlphaDivide
info: ======files =======
info: ======tokens =======
info: ======techniques =======
info: tname:Draw
info: tname:(null)
info: tname:DrawMultiply
info: tname:(null)
info: tname:DrawTonemap
info: tname:(null)
info: tname:DrawMultiplyTonemap
info: tname:(null)
info: tname:DrawAlphaDivide
info: tname:(null)
info: ======params =======
info: tname:ViewProj
info: tname:image
info: tname:multiplier
info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform mat4x4 ViewProj;

in vec4 _input_attrib0;
in vec2 _input_attrib1;

out vec2 _vertex_shader_attrib0;

out gl_PerVertex {
    vec4 gl_Position;
};

struct VertInOut {
    vec4 pos;
    vec2 uv;
};

VertInOut VSDefault(VertInOut vert_in)
{
    VertInOut vert_out;
    vert_out.pos = ((vec4(vert_in.pos.xyz, 1.0)) * (ViewProj));
    vert_out.uv  = vert_in.uv;
    return vert_out;
}

VertInOut _main_wrap(VertInOut vert_in)
{
    return VSDefault(vert_in);
}

void main(void)
{
    VertInOut vert_in;
    VertInOut outputval;

    vert_in.pos = _input_attrib0;
    vert_in.uv = _input_attrib1;

    outputval = _main_wrap(vert_in);

    gl_Position = outputval.pos;
    _vertex_shader_attrib0 = outputval.uv;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform sampler2D image;

in vec2 _vertex_shader_attrib0;

out vec4 _pixel_shader_attrib0;

struct VertInOut {
    vec4 pos;
    vec2 uv;
};

vec4 PSDraw(VertInOut vert_in)
{
    vec4 rgba = texture(image, vert_in.uv);
    if (rgba.a > 0.0)
        rgba.rgb /= rgba.a;
    return clamp(rgba, 0.0, 1.0);
}

vec4 _main_wrap(VertInOut vert_in)
{
    return PSDraw(vert_in);
}

void main(void)
{
    VertInOut vert_in;
    vert_in.pos = gl_FragCoord;
    vert_in.uv = _vertex_shader_attrib0;

    _pixel_shader_attrib0 = _main_wrap(vert_in);
}

info: ======funcs =======
info: fname:VSDefault rtype:VertInOut mapping:(null) content:{
    VertInOut vert_out;
    vert_out.pos = mul(float4(vert_in.pos.xyz, 1.0), ViewProj);
    vert_out.uv  = vert_in.uv;
    return vert_out;
}
info: fname:PSDraw rtype:float4 mapping:TARGET content:{
    float4 rgba = image.Sample(def_sampler, vert_in.uv);
    if (rgba.a > 0.0)
        rgba.rgb /= rgba.a;
    return saturate(rgba);
}
info: ======params =======
info: fname:ViewProj type:float4x4
info: fname:image type:texture2d
info: ======structs =======
info: fname:VertInOut
info: ======samplers =======
info: fname:def_sampler
info: ======techniques =======
info: fname:Draw
info: ======files =======
info: ======tokens =======
info: ======techniques =======
info: tname:Draw
info: tname:(null)
info: ======params =======
info: tname:ViewProj
info: tname:image
info: ---------------------------------
info: video settings reset:
    base resolution:   1280x720
    output resolution: 1280x720
    downscale filter:  Bicubic
    fps:               30/1
    format:            NV12
    YUV mode:          Rec. 601/Partial
info: NV12 texture support not available
info: P010 texture support not available
info: Audio monitoring device:
    name: Basic.Settings.Advanced.Audio.MonitoringDevice.Default
    id: default
info: ---------------------------------
debug: ---------------------------------
debug: Loading module: avcapture
CMIOEnvironment.cpp:63:CMIOEnvironmentAllowsThirdPartyDALPlugins_block_invoke error received in message reply handler for allow-3p-plugins: Connection invalid
CMIO_DAL_PlugInManagement.cpp:111:Initialize_block_invoke connection invalid error for service com.apple.cmio.registerassistantservice.
CMIO_DAL_PlugInManagement.cpp:145:Initialize Missing device-camera entitlement
debug: ---------------------------------
debug: Loading module: image-source
debug: ---------------------------------
debug: Loading module: obs-ffmpeg
debug: ---------------------------------
debug: Loading module: obs-transitions
debug: ---------------------------------
debug: Loading module: obs-x264
info: ---------------------------------
info:   Loaded Modules:
info:     obs-x264
info:     obs-transitions
info:     obs-ffmpeg
info:     image-source
info:     avcapture
info: ---------------------------------
info: ResetOutputs

debug: encoder 'simple_h264_stream' (obs_x264) created
debug: AAC encoder bitrate mapping:
     64 kbit/s: 'FFmpeg AAC' (ffmpeg_aac)
     96 kbit/s: 'FFmpeg AAC' (ffmpeg_aac)
    128 kbit/s: 'FFmpeg AAC' (ffmpeg_aac)
    160 kbit/s: 'FFmpeg AAC' (ffmpeg_aac)
    192 kbit/s: 'FFmpeg AAC' (ffmpeg_aac)
    224 kbit/s: 'FFmpeg AAC' (ffmpeg_aac)
    256 kbit/s: 'FFmpeg AAC' (ffmpeg_aac)
    288 kbit/s: 'FFmpeg AAC' (ffmpeg_aac)
    320 kbit/s: 'FFmpeg AAC' (ffmpeg_aac)
    352 kbit/s: 'FFmpeg AAC' (ffmpeg_aac)
    384 kbit/s: 'FFmpeg AAC' (ffmpeg_aac)
    416 kbit/s: 'FFmpeg AAC' (ffmpeg_aac)
    448 kbit/s: 'FFmpeg AAC' (ffmpeg_aac)
    480 kbit/s: 'FFmpeg AAC' (ffmpeg_aac)
    512 kbit/s: 'FFmpeg AAC' (ffmpeg_aac)
    544 kbit/s: 'FFmpeg AAC' (ffmpeg_aac)
    576 kbit/s: 'FFmpeg AAC' (ffmpeg_aac)
    608 kbit/s: 'FFmpeg AAC' (ffmpeg_aac)
    640 kbit/s: 'FFmpeg AAC' (ffmpeg_aac)
    672 kbit/s: 'FFmpeg AAC' (ffmpeg_aac)
    704 kbit/s: 'FFmpeg AAC' (ffmpeg_aac)
    736 kbit/s: 'FFmpeg AAC' (ffmpeg_aac)
    768 kbit/s: 'FFmpeg AAC' (ffmpeg_aac)
    800 kbit/s: 'FFmpeg AAC' (ffmpeg_aac)
    832 kbit/s: 'FFmpeg AAC' (ffmpeg_aac)
    864 kbit/s: 'FFmpeg AAC' (ffmpeg_aac)
    896 kbit/s: 'FFmpeg AAC' (ffmpeg_aac)
    928 kbit/s: 'FFmpeg AAC' (ffmpeg_aac)
    960 kbit/s: 'FFmpeg AAC' (ffmpeg_aac)
    992 kbit/s: 'FFmpeg AAC' (ffmpeg_aac)
    1024 kbit/s: 'FFmpeg AAC' (ffmpeg_aac)
debug: encoder 'simple_aac' (ffmpeg_aac) created
debug: output 'simple_file_output' (ffmpeg_muxer) created
info: ResetService

error: Service 'rtmp_common' not found
info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform mat4x4 ViewProj;

in vec2 _input_attrib0;
in vec4 _input_attrib1;

out vec2 _vertex_shader_attrib0;

out gl_PerVertex {
    vec4 gl_Position;
};

struct VertData {
    vec2 uv;
    vec4 pos;
};

VertData VSDefault(VertData v_in)
{
    VertData vert_out;
    vert_out.uv  = v_in.uv;
    vert_out.pos = ((vec4(v_in.pos.xyz, 1.0)) * (ViewProj));
    return vert_out;
}

VertData _main_wrap(VertData v_in)
{
    return VSDefault(v_in);
}

void main(void)
{
    VertData v_in;
    VertData outputval;

    v_in.uv = _input_attrib0;
    v_in.pos = _input_attrib1;

    outputval = _main_wrap(v_in);

    _vertex_shader_attrib0 = outputval.uv;
    gl_Position = outputval.pos;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform sampler2D tex_a;
uniform sampler2D tex_b;
uniform float fade_val;

in vec2 _vertex_shader_attrib0;

out vec4 _pixel_shader_attrib0;

struct FragData {
    vec2 uv;
};

vec4 Fade(FragData f_in)
{
    vec4 a_val = texture(tex_a, f_in.uv);
    vec4 b_val = texture(tex_b, f_in.uv);
    vec4 rgba = mix(a_val, b_val, fade_val);
    return rgba;
}

float srgb_nonlinear_to_linear_channel(float u)
{
    return (u <= 0.04045) ? (u / 12.92) : pow((u + 0.055) / 1.055, 2.4);
}

vec3 srgb_nonlinear_to_linear(vec3 v)
{
    return vec3(srgb_nonlinear_to_linear_channel(v.r), srgb_nonlinear_to_linear_channel(v.g), srgb_nonlinear_to_linear_channel(v.b));
}

vec4 PSFade(FragData f_in)
{
    vec4 rgba = Fade(f_in);
    rgba.rgb = srgb_nonlinear_to_linear(rgba.rgb);
    return rgba;
}

vec4 _main_wrap(FragData f_in)
{
    return PSFade(f_in);
}

void main(void)
{
    FragData f_in;
    f_in.uv = _vertex_shader_attrib0;

    _pixel_shader_attrib0 = _main_wrap(f_in);
}

info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform mat4x4 ViewProj;

in vec2 _input_attrib0;
in vec4 _input_attrib1;

out vec2 _vertex_shader_attrib0;

out gl_PerVertex {
    vec4 gl_Position;
};

struct VertData {
    vec2 uv;
    vec4 pos;
};

VertData VSDefault(VertData v_in)
{
    VertData vert_out;
    vert_out.uv  = v_in.uv;
    vert_out.pos = ((vec4(v_in.pos.xyz, 1.0)) * (ViewProj));
    return vert_out;
}

VertData _main_wrap(VertData v_in)
{
    return VSDefault(v_in);
}

void main(void)
{
    VertData v_in;
    VertData outputval;

    v_in.uv = _input_attrib0;
    v_in.pos = _input_attrib1;

    outputval = _main_wrap(v_in);

    _vertex_shader_attrib0 = outputval.uv;
    gl_Position = outputval.pos;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform sampler2D tex_a;
uniform sampler2D tex_b;
uniform float fade_val;

in vec2 _vertex_shader_attrib0;

out vec4 _pixel_shader_attrib0;

struct FragData {
    vec2 uv;
};

vec4 Fade(FragData f_in)
{
    vec4 a_val = texture(tex_a, f_in.uv);
    vec4 b_val = texture(tex_b, f_in.uv);
    vec4 rgba = mix(a_val, b_val, fade_val);
    return rgba;
}

vec4 PSFadeLinear(FragData f_in)
{
    vec4 rgba = Fade(f_in);
    return rgba;
}

vec4 _main_wrap(FragData f_in)
{
    return PSFadeLinear(f_in);
}

void main(void)
{
    FragData f_in;
    f_in.uv = _vertex_shader_attrib0;

    _pixel_shader_attrib0 = _main_wrap(f_in);
}

info:
 ======vertex=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform mat4x4 ViewProj;

in vec2 _input_attrib0;
in vec4 _input_attrib1;

out vec2 _vertex_shader_attrib0;

out gl_PerVertex {
    vec4 gl_Position;
};

struct VertData {
    vec2 uv;
    vec4 pos;
};

VertData VSDefault(VertData v_in)
{
    VertData vert_out;
    vert_out.uv  = v_in.uv;
    vert_out.pos = ((vec4(v_in.pos.xyz, 1.0)) * (ViewProj));
    return vert_out;
}

VertData _main_wrap(VertData v_in)
{
    return VSDefault(v_in);
}

void main(void)
{
    VertData v_in;
    VertData outputval;

    v_in.uv = _input_attrib0;
    v_in.pos = _input_attrib1;

    outputval = _main_wrap(v_in);

    _vertex_shader_attrib0 = outputval.uv;
    gl_Position = outputval.pos;
}

info:
 ======fragment=======
info:
#version 330

const bool obs_glsl_compile = true;

vec4 obs_load_2d(sampler2D s, ivec3 p_lod)
{
    int lod = p_lod.z;
    vec2 size = textureSize(s, lod);
    vec2 p = (vec2(p_lod.xy) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

vec4 obs_load_3d(sampler3D s, ivec4 p_lod)
{
    int lod = p_lod.w;
    vec3 size = textureSize(s, lod);
    vec3 p = (vec3(p_lod.xyz) + 0.5) / size;
    vec4 color = textureLod(s, p, lod);
    return color;
}

uniform sampler2D tex_a;
uniform float fade_val;

in vec2 _vertex_shader_attrib0;

out vec4 _pixel_shader_attrib0;

struct FragData {
    vec2 uv;
};

vec4 FadeSingle(FragData f_in)
{
    vec4 a_val = texture(tex_a, f_in.uv);
    vec4 rgba = a_val * fade_val;
    return rgba;
}

vec4 PSFadeSingle(FragData f_in)
{
    vec4 rgba = FadeSingle(f_in);
    return rgba;
}

vec4 _main_wrap(FragData f_in)
{
    return PSFadeSingle(f_in);
}

void main(void)
{
    FragData f_in;
    f_in.uv = _vertex_shader_attrib0;

    _pixel_shader_attrib0 = _main_wrap(f_in);
}

